

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png">
  <link rel="icon" href="/img/fluid.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="bradin">
  <meta name="keywords" content="">
  
    <meta name="description" content="写在前面：这是针对2024春cau《面向对象的程序设计》以及我个人的学习积累整理的笔记，其中大纲的整理受到了https:&#x2F;&#x2F;blog.csdn.net&#x2F;chenlong_cxy&#x2F;article&#x2F;details&#x2F;127166206 的启发 (一)c++基础1.1数据类型相比于c多了一个bool（基本数据类型） 1.2命名空间 在C++编程中，命名空间是一种特性，用于将代码进行逻辑分组，以避免命名冲突">
<meta property="og:type" content="article">
<meta property="og:title" content="c++课堂笔记">
<meta property="og:url" content="http://example.com/2025/03/21/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/c++%E7%AC%94%E8%AE%B0/index.html">
<meta property="og:site_name" content="鸭蛋仙人的博客">
<meta property="og:description" content="写在前面：这是针对2024春cau《面向对象的程序设计》以及我个人的学习积累整理的笔记，其中大纲的整理受到了https:&#x2F;&#x2F;blog.csdn.net&#x2F;chenlong_cxy&#x2F;article&#x2F;details&#x2F;127166206 的启发 (一)c++基础1.1数据类型相比于c多了一个bool（基本数据类型） 1.2命名空间 在C++编程中，命名空间是一种特性，用于将代码进行逻辑分组，以避免命名冲突">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://www.freeimg.cn/i/2024/05/09/663cb010b9c3f.png">
<meta property="article:published_time" content="2025-03-21T15:58:12.000Z">
<meta property="article:modified_time" content="2024-07-11T13:37:38.000Z">
<meta property="article:author" content="bradin">
<meta property="article:tag" content="c++">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://www.freeimg.cn/i/2024/05/09/663cb010b9c3f.png">
  
  
    <meta name="referrer" content="no-referrer-when-downgrade">
  
  
  <title>c++课堂笔记 - 鸭蛋仙人的博客</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.9.6","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":{"measurement_id":null},"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 7.3.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>鸭蛋仙人</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/" target="_self">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/" target="_self">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/" target="_self">
                <i class="iconfont icon-category-fill"></i>
                <span>分类</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/" target="_self">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/" target="_self">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/example/" target="_self">
                <i class="iconfont icon-slack-fill"></i>
                <span>example</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/default.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="c++课堂笔记"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2025-03-21 23:58" pubdate>
          2025年3月21日 晚上
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          9.2k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          77 分钟
        
      </span>
    

    
    
      
        <span id="busuanzi_container_page_pv" style="display: none">
          <i class="iconfont icon-eye" aria-hidden="true"></i>
          <span id="busuanzi_value_page_pv"></span> 次
        </span>
        
      
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <h1 id="seo-header">c++课堂笔记</h1>
            
            
              <div class="markdown-body">
                
                <p>写在前面：这是针对2024春cau《面向对象的程序设计》以及我个人的学习积累整理的笔记，其中大纲的整理受到了<a target="_blank" rel="noopener" href="https://blog.csdn.net/chenlong_cxy/article/details/127166206">https://blog.csdn.net/chenlong_cxy/article/details/127166206</a> 的启发</p>
<h1 id="一-c-基础"><a href="#一-c-基础" class="headerlink" title="(一)c++基础"></a>(一)c++基础</h1><h2 id="1-1数据类型"><a href="#1-1数据类型" class="headerlink" title="1.1数据类型"></a>1.1数据类型</h2><p>相比于c多了一个bool（基本数据类型）</p>
<h2 id="1-2命名空间"><a href="#1-2命名空间" class="headerlink" title="1.2命名空间"></a>1.2命名空间</h2><p> 在C++编程中，命名空间是一种特性，用于将代码进行逻辑分组，以避免命名冲突和组织代码。命名空间可以被看作是一个容器，它封装了一组相关的类、函数、变量等，为它们提供了一个独立的命名空间域，从而可以避免在全局命名空间中因名称重复而导致的冲突。</p>
<p>命名空间的作用：<br>避免命名冲突：在大型项目中，不同的库或模块可能使用相同的函数名或变量名。通过将这些名称放在不同的命名空间中，可以确保它们不会发生冲突。</p>
<p>代码组织：命名空间有助于将相关的代码组织在一起，使得代码结构更清晰，更易于维护。</p>
<p>提高可读性：通过使用有意义的命名空间名称，可以使得代码更加易于理解。例如，一个名为MathFunctions的命名空间可能包含与数学计算相关的函数。</p>
<p>我们常用的库称为c++标准库（stl）</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span>  </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span>  </span><br>  <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;  <br>    std::vector&lt;<span class="hljs-type">int</span>&gt; numbers = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;;  <br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> num : numbers) &#123;  <br>        std::cout &lt;&lt; num &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;  <br>    &#125;  <br>    std::cout &lt;&lt; std::endl;  <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;  <br>&#125;<br>--------------------------------<br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span>  </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span>  </span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std; <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;  <br>    std::vector&lt;<span class="hljs-type">int</span>&gt; numbers = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;;  <br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> num : numbers) &#123;  <br>        std::cout &lt;&lt; num &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;  <br>    &#125;  <br>    cout &lt;&lt; std::endl;  <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;  <br>&#125;<br></code></pre></td></tr></table></figure>
<p>同样的，你也可以自己创建命名空间</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">namespace</span> MyNamespace &#123;  <br>    <span class="hljs-type">int</span> myVariable = <span class="hljs-number">10</span>;  <br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">myFunction</span><span class="hljs-params">()</span> </span>&#123;  <br>        <span class="hljs-comment">// 函数实现  </span><br>    &#125;  <br>&#125;<br><span class="hljs-keyword">using</span> MyNamespace::myFunction;  <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;  <br>    <span class="hljs-built_in">myFunction</span>();  <span class="hljs-comment">// 直接调用函数  </span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;  <br>&#125;<br>----------------------------------------------------<br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span>  </span><br><span class="hljs-keyword">namespace</span> MyMath &#123;  <br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> </span>&#123;  <br>        <span class="hljs-keyword">return</span> a + b;  <br>    &#125;  <br>&#125;  <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;  <br>    <span class="hljs-comment">// 使用完全限定名调用函数  </span><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Sum: &quot;</span> &lt;&lt; MyMath::<span class="hljs-built_in">add</span>(<span class="hljs-number">5</span>, <span class="hljs-number">7</span>) &lt;&lt; std::endl;  <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;  <br>&#125;<br><br></code></pre></td></tr></table></figure>
<h2 id="1-3缺省参数"><a href="#1-3缺省参数" class="headerlink" title="1.3缺省参数"></a>1.3缺省参数</h2><p>c++中，定义函数的时候可以让<strong>最右边的连续若干个参数</strong>有缺省值，在调用函数的时候，如果不写相应位置的参数，则调用的参数就为缺省值。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">fun</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b = <span class="hljs-number">1</span>, <span class="hljs-type">int</span> c = <span class="hljs-number">2</span>)</span> </span>&#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;a=&quot;</span> &lt;&lt; a &lt;&lt; <span class="hljs-string">&quot;\tb=&quot;</span> &lt;&lt; b &lt;&lt; <span class="hljs-string">&quot;\tc=&quot;</span> &lt;&lt; c &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>调用时，如果参数b和c的参数没有给出，则默认为缺省值。<br>不过函数的赋值是从左到右的</p>
<h2 id="1-4函数重载"><a href="#1-4函数重载" class="headerlink" title="1.4函数重载"></a>1.4函数重载</h2><p>所谓函数重载，就是说同一个函数名，如果接收参数不同，那么就不属于命名冲突，调用时会自动判断传入的参数来决定使用哪一个函数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c++"><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br> <br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br> <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">sumOfSquare</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span></span>;<br> <br><span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">sumOfSquare</span><span class="hljs-params">(<span class="hljs-type">double</span> x, <span class="hljs-type">double</span> y)</span></span>;<br> <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-type">int</span> x1, y1;<br>	<span class="hljs-type">double</span> x2, y2;<br>	cout&lt;&lt;<span class="hljs-string">&quot;Enter two integer:&quot;</span>&lt;&lt;endl;<br>	cin&gt;&gt;x1&gt;&gt;y1;<br>	cout&lt;&lt;<span class="hljs-string">&quot;Their sum of square = &quot;</span>&lt;&lt;<span class="hljs-built_in">sumOfSquare</span>(x1, y1)&lt;&lt;endl;<br>	cout&lt;&lt;<span class="hljs-string">&quot;Enter two Real Number:&quot;</span>&lt;&lt;endl;<br>	cin&gt;&gt;x2&gt;&gt;y2;<br>	cout&lt;&lt;<span class="hljs-string">&quot;Their sum of square = &quot;</span>&lt;&lt;<span class="hljs-built_in">sumOfSquare</span>(x2, y2)&lt;&lt;endl;<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">sumOfSquare</span><span class="hljs-params">(<span class="hljs-type">int</span> x1, <span class="hljs-type">int</span> y1)</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-keyword">return</span> (x1*x1+y1*y1);<br>&#125;<br><span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">sumOfSquare</span><span class="hljs-params">(<span class="hljs-type">double</span> x2, <span class="hljs-type">double</span> y2)</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-keyword">return</span> (x2*x2+y2*y2);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>ati:参数的默认值必须在函数声明中指定!!!</p>
<h2 id="1-5引用"><a href="#1-5引用" class="headerlink" title="1.5引用"></a>1.5引用</h2><h3 id="1-5-1引用的定义："><a href="#1-5-1引用的定义：" class="headerlink" title="1.5.1引用的定义："></a>1.5.1引用的定义：</h3><p>1引用是一个变量的别名，也就是说，它是某个已存在变量的另一个名字。<br>2一旦把引用初始化为某个变量，就可以使用该引用名称或变量名称来指向变量。   </p>
<h3 id="1-5-2引用与指针的区别："><a href="#1-5-2引用与指针的区别：" class="headerlink" title="1.5.2引用与指针的区别："></a>1.5.2引用与指针的区别：</h3><p>1不存在空引用。引用必须连接到一块合法的内存。一旦引用被初始化为一个对象，就不能被指向到另一个对象，指针可以在任何时候指向到另一个对象。(引用自带const属性)<br>C++ 标准不允许引用重新指向其他对象，这相当于引用具有内置的 const 属性（但不是指引用的对象本身是 const，而是指引用的指向是 const）。 </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;  <br>    <span class="hljs-type">int</span> x = <span class="hljs-number">5</span>;  <br>    <span class="hljs-type">int</span> &amp;ref = x; <span class="hljs-comment">// 引用被初始化为x，连接到x所占用的合法内存  </span><br>  <br>    <span class="hljs-comment">// ref现在引用x，且不能改变其引用的对象  </span><br>    <span class="hljs-comment">// 以下代码是非法的，因为C++中的引用不能在创建后改变其指向的对象  </span><br>    <span class="hljs-comment">// int y = 10;  </span><br>    <span class="hljs-comment">// ref = y; // 错误！C++中的引用不能在创建后重新指向其他对象  </span><br>  <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;  <br>&#125;<br></code></pre></td></tr></table></figure>

<p>2引用必须在创建时被初始化，而指针可以在任何时间被初始化。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;  <br>    <span class="hljs-type">int</span> x = <span class="hljs-number">5</span>;  <br>    <span class="hljs-type">int</span> *ptr; <span class="hljs-comment">// 指针声明，尚未初始化  </span><br>  <br>    <span class="hljs-comment">// 可以在后面的代码中任何时候初始化指针  </span><br>    ptr = &amp;x; <span class="hljs-comment">// 指针现在指向x  </span><br>  <br>    <span class="hljs-type">int</span> &amp;ref = x; <span class="hljs-comment">// 引用必须在声明时初始化  </span><br>    <span class="hljs-comment">// int &amp;anotherRef; // 错误！引用在声明时必须被初始化  </span><br>  <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;  <br>&#125;<br><br></code></pre></td></tr></table></figure>

<h3 id="1-5-3创建引用："><a href="#1-5-3创建引用：" class="headerlink" title="1.5.3创建引用："></a>1.5.3创建引用：</h3><p>假设变量名称是变量附属在内存位置中的标签，我们可以把引用当成是变量附属在内存位置中的第二个标签。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> i = <span class="hljs-number">17</span>;<br><span class="hljs-type">int</span>&amp; r = i; <span class="hljs-comment">// 创建一个整型引用 r，它是 i 的别名</span><br><br>r = <span class="hljs-number">42</span>; <span class="hljs-comment">// 修改 r，实际上也修改了 i</span><br>cout &lt;&lt; <span class="hljs-string">&quot;i 的值：&quot;</span> &lt;&lt; i &lt;&lt; endl; <span class="hljs-comment">// 输出 42</span><br><br><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-comment">// 交换两个整数的值</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">swapIntegers</span><span class="hljs-params">(<span class="hljs-type">int</span>&amp; x, <span class="hljs-type">int</span>&amp; y)</span> </span>&#123;<br>    <span class="hljs-type">int</span> temp = x;<br>    x = y;<br>    y = temp;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> a = <span class="hljs-number">10</span>, b = <span class="hljs-number">20</span>;<br>    cout &lt;&lt; <span class="hljs-string">&quot;Before swapping: a = &quot;</span> &lt;&lt; a &lt;&lt; <span class="hljs-string">&quot;, b = &quot;</span> &lt;&lt; b &lt;&lt; endl;<br>    <span class="hljs-built_in">swapIntegers</span>(a, b);<br>    cout &lt;&lt; <span class="hljs-string">&quot;After swapping: a = &quot;</span> &lt;&lt; a &lt;&lt; <span class="hljs-string">&quot;, b = &quot;</span> &lt;&lt; b &lt;&lt; endl;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="1-5-4常量引用和值传递的内存分析"><a href="#1-5-4常量引用和值传递的内存分析" class="headerlink" title="1.5.4常量引用和值传递的内存分析"></a>1.5.4常量引用和值传递的内存分析</h3><p>值传递（Pass by Value）和常量引用（Constant Reference）是编程中参数传递的两种方式，它们在内存中的表现和行为有所不同。下面我将结合内存来详细解释这两种概念。</p>
<h4 id="值传递（Pass-by-Value）"><a href="#值传递（Pass-by-Value）" class="headerlink" title="值传递（Pass by Value）"></a>值传递（Pass by Value）</h4><p>在值传递中，函数的参数是通过复制实际参数的值来创建的。这意味着在内存中会为这些参数分配新的空间，并将实际参数的值复制到这些新分配的空间中。因此，函数内部对参数的任何修改都不会影响到实际参数。<br>以C++为例，如果你有一个函数void func(int x)，并且在调用这个函数时传入了一个整数变量int a &#x3D; 5; func(a);，那么在调用func时，会在栈上为新变量x分配空间，并将a的值（即5）复制到x中。如果函数func修改了x的值，这个修改不会反映到a上，因为x和a是两个不同的内存位置中的值。</p>
<h4 id="常量引用（Constant-Reference）"><a href="#常量引用（Constant-Reference）" class="headerlink" title="常量引用（Constant Reference）"></a>常量引用（Constant Reference）</h4><p>常量引用是一种特殊的引用类型，它允许你通过引用来传递参数，但不允许在函数内部修改引用的值。在内存中，常量引用并不创建参数的副本，而是直接使用了实际参数的内存地址。这意味着常量引用提供了一种效率更高的参数传递方式，因为它避免了复制数据。</p>
<p>继续上面的例子，如果你将函数改为void func(const int&amp; x)并使用相同的调用方式func(a)，那么在调用func时，不会为x分配新的内存空间。相反，x会直接引用a的内存地址。由于x是一个常量引用，所以你不能在func内部修改x的值（尝试这样做会导致编译错误）。但是，你可以读取x的值，它将是a的值（即5）。</p>
<p>常量引用的好处之一是它可以避免不必要的复制操作，特别是当处理大型对象或数据结构时，这可以显著提高性能。另一个好处是它可以处理不可修改的数据或需要保护的数据，确保这些数据在函数内部不会被意外修改。</p>
<p>总的来说，值传递和常量引用在内存中的表现和行为有所不同。值传递会创建参数的副本并分配新的内存空间，而常量引用则直接使用实际参数的内存地址并禁止修改引用的值。选择哪种传递方式取决于你的具体需求和程序的上下文。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span>  </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span>  </span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-comment">// 定义一个Person类  </span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;  <br><span class="hljs-keyword">private</span>:  <br>    string name; <span class="hljs-comment">// 私有数据成员：姓名  </span><br>    <span class="hljs-type">int</span> age;          <span class="hljs-comment">// 私有数据成员：年龄  </span><br>  <br><span class="hljs-keyword">public</span>:  <br>    <span class="hljs-comment">// 公共成员函数：构造函数，用于初始化对象  </span><br>    <span class="hljs-built_in">Person</span>(<span class="hljs-type">const</span> string&amp; n, <span class="hljs-type">int</span> a) : <span class="hljs-built_in">name</span>(n), <span class="hljs-built_in">age</span>(a) &#123;&#125;<br>    <span class="hljs-comment">// 也可以采用值传递</span><br>    <span class="hljs-comment">// Person(string n,int a) : name(n),age(a) &#123;&#125;</span><br>&#125;<br></code></pre></td></tr></table></figure>

<h1 id="（二）类和对象"><a href="#（二）类和对象" class="headerlink" title="（二）类和对象"></a>（二）类和对象</h1><h2 id="2-1类的基本概念"><a href="#2-1类的基本概念" class="headerlink" title="2.1类的基本概念"></a>2.1类的基本概念</h2><h3 id="2-1-1类的定义"><a href="#2-1-1类的定义" class="headerlink" title="2.1.1类的定义"></a>2.1.1类的定义</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> &#123;  <br><span class="hljs-keyword">public</span>:  <br>    <span class="hljs-type">int</span> myVariable;  <br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">myFunction</span><span class="hljs-params">()</span> </span>&#123;  <br>        <span class="hljs-comment">// 类成员函数的实现  </span><br>    &#125;  <br>&#125;;<br></code></pre></td></tr></table></figure>
<h3 id="2-1-2类的封装"><a href="#2-1-2类的封装" class="headerlink" title="2.1.2类的封装"></a>2.1.2类的封装</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">EncapsulatedClass</span> &#123;  <br><span class="hljs-keyword">private</span>:  <br>    <span class="hljs-type">int</span> hiddenVariable;  <br>  <br><span class="hljs-keyword">public</span>:  <br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setValue</span><span class="hljs-params">(<span class="hljs-type">int</span> value)</span> </span>&#123;  <br>        hiddenVariable = value;  <br>    &#125;  <br>  <br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getValue</span><span class="hljs-params">()</span> </span>&#123;  <br>        <span class="hljs-keyword">return</span> hiddenVariable;  <br>    &#125;  <br>&#125;;<br></code></pre></td></tr></table></figure>



<h3 id="2-1-3this指针"><a href="#2-1-3this指针" class="headerlink" title="2.1.3this指针"></a>2.1.3this指针</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ThisPointerExample</span> &#123;  <br><span class="hljs-keyword">private</span>:  <br>    <span class="hljs-type">int</span> value;  <br>  <br><span class="hljs-keyword">public</span>:  <br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setValue</span><span class="hljs-params">(<span class="hljs-type">int</span> newValue)</span> </span>&#123;  <br>        <span class="hljs-keyword">this</span>-&gt;value = newValue; <span class="hljs-comment">// 使用this指针明确指定当前对象的成员变量  </span><br>    &#125;  <br>  <br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getValue</span><span class="hljs-params">()</span> </span>&#123;  <br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>-&gt;value; <span class="hljs-comment">// 使用this指针明确指定当前对象的成员变量  </span><br>    &#125;  <br>&#125;;<br></code></pre></td></tr></table></figure>
<h3 id="2-1-4类的初始化列表"><a href="#2-1-4类的初始化列表" class="headerlink" title="2.1.4类的初始化列表"></a>2.1.4类的初始化列表</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ScopedClass</span> &#123;  <br><span class="hljs-keyword">private</span>:  <br>    <span class="hljs-type">int</span> x, y;  <br>  <br><span class="hljs-keyword">public</span>:  <br>    <span class="hljs-comment">// 构造函数初始化列表  </span><br>    <span class="hljs-built_in">ScopedClass</span>(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b) : <span class="hljs-built_in">x</span>(a), <span class="hljs-built_in">y</span>(b) &#123;&#125;  <br>  <br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printValues</span><span class="hljs-params">()</span> </span>&#123;  <br>        <span class="hljs-comment">// 在类的作用域内访问成员变量  </span><br>        std::cout &lt;&lt; <span class="hljs-string">&quot;x: &quot;</span> &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot;, y: &quot;</span> &lt;&lt; y &lt;&lt; std::endl;  <br>    &#125;  <br>&#125;;  <br>  <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;  <br>    <span class="hljs-function">ScopedClass <span class="hljs-title">obj</span><span class="hljs-params">(<span class="hljs-number">10</span>, <span class="hljs-number">20</span>)</span></span>; <span class="hljs-comment">// 使用初始化列表进行实例化  </span><br>    obj.<span class="hljs-built_in">printValues</span>(); <span class="hljs-comment">// 输出：x: 10, y: 20  </span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;  <br>&#125;<br></code></pre></td></tr></table></figure>


<h2 id="2-2构造函数与析构函数"><a href="#2-2构造函数与析构函数" class="headerlink" title="2.2构造函数与析构函数"></a>2.2构造函数与析构函数</h2><h3 id="2-2-1构造函数"><a href="#2-2-1构造函数" class="headerlink" title="2.2.1构造函数"></a>2.2.1构造函数</h3><p>构造函数是一种特殊的成员函数，它在创建类的对象时被自动调用，用于初始化对象的状态。构造函数的名字与类的名称相同，且没有返回类型，甚至连void也没有。它的主要任务是初始化对象的成员变量或执行一些在创建对象时需要进行的操作。</p>
<p>构造函数可以根据需要设置参数，这些参数用于初始化对象的状态。当创建类的对象时，可以通过构造函数传递参数来初始化对象的属性。如果没有提供显式的构造函数，编译器会自动生成一个默认的无参构造函数。但是，如果类中定义了任何一个构造函数（无论是有参还是无参），编译器就不会自动生成默认构造函数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Teacher</span>&#123;<br>	<span class="hljs-keyword">private</span>:<br>		string name;<br>		<span class="hljs-type">int</span> age;<br>	<span class="hljs-keyword">public</span>:<br>		<span class="hljs-built_in">Teacher</span>()&#123;<br>			name=<span class="hljs-string">&quot;张三&quot;</span>; <br>			age=<span class="hljs-number">18</span>;<br>			cout &lt;&lt; <span class="hljs-string">&quot;自定义无参构造函数&quot;</span> &lt;&lt; std::endl; <br>		&#125;<br>		<span class="hljs-built_in">Teacher</span>(string name1,<span class="hljs-type">int</span> age1)<br>		&#123;<br>			name=name1;<br>			age=age1;<br>			cout &lt;&lt; <span class="hljs-string">&quot;自定义有参构造函数&quot;</span> &lt;&lt; std::endl; <br>		&#125;<br>		<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setname</span><span class="hljs-params">(string name1)</span> </span>&#123;  <br>        name = name1;  <br>    &#125;  <br>  <br>    <span class="hljs-comment">// 获取姓名  </span><br>    <span class="hljs-function">string <span class="hljs-title">getname</span><span class="hljs-params">()</span> </span>&#123;  <br>        <span class="hljs-keyword">return</span> name;  <br>    &#125;  <br>  <br>    <span class="hljs-comment">// 设置年龄  </span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setage</span><span class="hljs-params">(<span class="hljs-type">int</span> age1)</span> </span>&#123;  <br>        age = age1;  <br>    &#125;  <br>  <br>    <span class="hljs-comment">// 获取年龄  </span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getage</span><span class="hljs-params">()</span> </span>&#123;  <br>        <span class="hljs-keyword">return</span> age;  <br>    &#125;  <br>	<br>	<br>&#125;;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>	Teacher t1;   <span class="hljs-comment">//这里不带括号   初始化为 张三 18</span><br>	<span class="hljs-function">Teacher <span class="hljs-title">t2</span><span class="hljs-params">(<span class="hljs-string">&quot;jam&quot;</span>,<span class="hljs-number">18</span>)</span></span>;<br>	cout&lt;&lt;t<span class="hljs-number">1.</span><span class="hljs-built_in">getname</span>()&lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;t<span class="hljs-number">1.</span><span class="hljs-built_in">getage</span>()&lt;&lt;endl;<br>	cout&lt;&lt;t<span class="hljs-number">2.</span><span class="hljs-built_in">getname</span>()&lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;t<span class="hljs-number">2.</span><span class="hljs-built_in">getage</span>()&lt;&lt;endl;<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;   <br><br></code></pre></td></tr></table></figure>

<h3 id="2-2-2析构函数"><a href="#2-2-2析构函数" class="headerlink" title="2.2.2析构函数"></a>2.2.2析构函数</h3><p>在C++中，~B() 通常表示类 B 的析构函数的声明。析构函数是一个特殊的成员函数，当对象的生命周期结束时，它会被自动调用，用于释放对象可能持有的资源（如内存、文件句柄等）。</p>
<p>析构函数的名称与类名相同，但前面要加一个波浪符（~），并且没有返回类型，也没有参数。例如，如果有一个类名为 B，那么它的析构函数就会声明为 ~B()。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span> &#123;  <br><span class="hljs-keyword">public</span>:  <br>    <span class="hljs-comment">// 构造函数  </span><br>    <span class="hljs-built_in">B</span>() &#123;  <br>        <span class="hljs-comment">// 初始化代码，例如分配内存或打开文件等  </span><br>    &#125;  <br>      <br>    <span class="hljs-comment">// 析构函数  </span><br>    ~<span class="hljs-built_in">B</span>() &#123;  <br>        <span class="hljs-comment">// 清理代码，例如释放内存或关闭文件等  </span><br>    &#125;  <br>&#125;;  <br>  <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;  <br>    B b; <span class="hljs-comment">// 创建B类对象，构造函数被调用  </span><br>    <span class="hljs-comment">// 当b离开作用域时，析构函数~B()会被自动调用  </span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;  <br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="2-3对象的复制-引用-指针创建"><a href="#2-3对象的复制-引用-指针创建" class="headerlink" title="2.3对象的复制,引用,指针创建"></a>2.3对象的复制,引用,指针创建</h2><h3 id="2-3-2浅拷贝与深拷贝"><a href="#2-3-2浅拷贝与深拷贝" class="headerlink" title="2.3.2浅拷贝与深拷贝"></a>2.3.2浅拷贝与深拷贝</h3><h2 id="2-4const关键字与类"><a href="#2-4const关键字与类" class="headerlink" title="2.4const关键字与类"></a>2.4const关键字与类</h2><p>const是一种声明，对于const声明的变量&#x2F;函数&#x2F;对象等，我们不可以改变其数值（等），否则编译器会报错。</p>
<h3 id="常量变量-指针"><a href="#常量变量-指针" class="headerlink" title="常量变量&#x2F;指针"></a>常量变量&#x2F;指针</h3><p>使用const声明的变量必须在声明时就赋值，且其值在程序运行期间不能再被修改</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">const</span> <span class="hljs-type">int</span> a = <span class="hljs-number">10</span>; <span class="hljs-comment">// a 是一个常量，其值不能被修改  </span><br><span class="hljs-comment">// a = 20; // 错误！不能修改常量a的值</span><br><br><br><span class="hljs-type">int</span> x = <span class="hljs-number">10</span>;  <br><span class="hljs-type">int</span> *<span class="hljs-type">const</span> ptr = &amp;x; <span class="hljs-comment">// 常指针，指向x的地址，但ptr的值不能被改变  </span><br>*ptr = <span class="hljs-number">20</span>; <span class="hljs-comment">// 合法，因为可以修改指针所指向的内容  </span><br><span class="hljs-comment">// ptr++; // 非法，因为ptr是常指针，其值不能改变</span><br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> x = <span class="hljs-number">10</span>;  <br><span class="hljs-type">const</span> <span class="hljs-type">int</span> *ptr = &amp;x; <span class="hljs-comment">// 指向常量的指针，不能通过ptr修改x的值  </span><br><span class="hljs-comment">// *ptr = 20; // 非法，因为ptr指向的内容是常量  </span><br><span class="hljs-type">int</span> y = <span class="hljs-number">20</span>;  <br>ptr = &amp;y; <span class="hljs-comment">// 合法，因为可以改变ptr的值</span><br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> x = <span class="hljs-number">10</span>;  <br><span class="hljs-type">const</span> <span class="hljs-type">int</span> *<span class="hljs-type">const</span> ptr = &amp;x; <span class="hljs-comment">// 指向常量的常指针  </span><br><span class="hljs-comment">// *ptr = 20; // 非法，因为ptr指向的内容是常量  </span><br><span class="hljs-comment">// ptr++; // 非法，因为ptr是常指针，其值不能改变</span><br><br></code></pre></td></tr></table></figure>
<h3 id="const函数参数"><a href="#const函数参数" class="headerlink" title="const函数参数"></a>const函数参数</h3><p>使用const修饰函数参数，可以保证在函数体内不会修改该参数的值。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printLength</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; str)</span> </span>&#123;  <br>    std::cout &lt;&lt; <span class="hljs-string">&quot;String length: &quot;</span> &lt;&lt; str.<span class="hljs-built_in">length</span>() &lt;&lt; std::endl;  <br>    <span class="hljs-comment">// str = &quot;another string&quot;; // 错误！不能在函数体内修改const参数  </span><br>&#125;<br><span class="hljs-comment">//注意</span><br><span class="hljs-comment">// 按引用传递，更高效  </span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printLengthByRef</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; str)</span> </span>&#123;    <br>    std::cout &lt;&lt; <span class="hljs-string">&quot;String length (by reference): &quot;</span> &lt;&lt; str.<span class="hljs-built_in">length</span>() &lt;&lt; std::endl;  <br>&#125;  <br>  <br><span class="hljs-comment">// 按值传递，会复制字符串  </span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printLengthByValue</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string str)</span> </span>&#123;    <br>    std::cout &lt;&lt; <span class="hljs-string">&quot;String length (by value): &quot;</span> &lt;&lt; str.<span class="hljs-built_in">length</span>() &lt;&lt; std::endl;  <br>&#125;<br><span class="hljs-comment">//但是二者都不允许更改string！</span><br></code></pre></td></tr></table></figure>

<p>简单地说，&amp;是高效传参的手段，但是不具有const性质，我们选择在参数传递前面加上const，提高代码的可读性，又保证了const引用。</p>
<h3 id="const成员函数"><a href="#const成员函数" class="headerlink" title="const成员函数"></a>const成员函数</h3><p>在成员函数中，const关键字表示该成员函数不会修改类的任何成员变量（除了被声明为mutable的成员）。这通常用于确保某些成员函数不会意外地修改对象的状态。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> &#123;  <br><span class="hljs-keyword">private</span>:  <br>    <span class="hljs-type">int</span> value;  <br><span class="hljs-keyword">public</span>:  <br>    <span class="hljs-built_in">MyClass</span>(<span class="hljs-type">int</span> v) : <span class="hljs-built_in">value</span>(v) &#123;&#125;  <br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getValue</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> value; &#125; <span class="hljs-comment">// 常量成员函数，不能修改类的任何成员变量  </span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setValue</span><span class="hljs-params">(<span class="hljs-type">int</span> v)</span> </span>&#123; value = v; &#125; <span class="hljs-comment">// 可以修改类的成员变量  </span><br>&#125;;<br><span class="hljs-comment">// void setValue(int v) const &#123; value = v; &#125; // 错误！不能在常成员函数中修改成员变量</span><br></code></pre></td></tr></table></figure>

<h3 id="常对象（const-Object）"><a href="#常对象（const-Object）" class="headerlink" title="常对象（const Object）"></a>常对象（const Object）</h3><p>常对象是用const关键字声明的对象。一旦一个对象被声明为const，就不能调用该对象的任何非const成员函数（因为这些函数可能会修改对象的状态），只能调用const成员函数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">const</span> MyClass <span class="hljs-title">obj</span><span class="hljs-params">(<span class="hljs-number">10</span>)</span></span>; <span class="hljs-comment">// 常对象  </span><br><span class="hljs-comment">// obj.setValue(20); // 错误！不能调用非const成员函数来修改const对象  </span><br><span class="hljs-type">int</span> val = obj.<span class="hljs-built_in">getValue</span>(); <span class="hljs-comment">// 正确！可以调用const成员函数</span><br></code></pre></td></tr></table></figure>

<h3 id="常对象成员（Members-of-a-const-Object）"><a href="#常对象成员（Members-of-a-const-Object）" class="headerlink" title="常对象成员（Members of a const Object）"></a>常对象成员（Members of a const Object）</h3><p>当一个对象是const时，它的所有成员变量也都被视为const，即不能被修改。这意味着你不能在常对象内部修改任何成员变量的值。但是，你可以通过const成员函数来访问这些成员变量的值。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> &#123;  <br><span class="hljs-keyword">public</span>:  <br>    <span class="hljs-type">int</span> x;  <br>    <span class="hljs-built_in">MyClass</span>(<span class="hljs-type">int</span> val) : <span class="hljs-built_in">x</span>(val) &#123;&#125;  <br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">showX</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-comment">// 常成员函数可以访问常对象的成员  </span><br>        std::cout &lt;&lt; x &lt;&lt; std::endl;  <br>    &#125;  <br>    <span class="hljs-comment">// void modifyX(int newVal) const &#123; x = newVal; &#125; // 错误！不能在const成员函数中修改成员  </span><br>&#125;;  <br>  <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;  <br>    <span class="hljs-function"><span class="hljs-type">const</span> MyClass <span class="hljs-title">myConstObj</span><span class="hljs-params">(<span class="hljs-number">5</span>)</span></span>; <span class="hljs-comment">// 常对象  </span><br>    myConstObj.<span class="hljs-built_in">showX</span>(); <span class="hljs-comment">// 可以调用const成员函数来访问成员  </span><br>    <span class="hljs-comment">// myConstObj.x = 10; // 错误！不能修改const对象的成员  </span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;  <br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="几种写法对比"><a href="#几种写法对比" class="headerlink" title="几种写法对比"></a>几种写法对比</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br>	<span class="hljs-keyword">class</span> <span class="hljs-title class_">Point</span> &#123;<br><span class="hljs-keyword">public</span>:<br>	<span class="hljs-built_in">Point</span>(<span class="hljs-type">int</span> x = <span class="hljs-number">0</span>, <span class="hljs-type">int</span> y = <span class="hljs-number">0</span>) : <span class="hljs-built_in">x</span>(x), <span class="hljs-built_in">y</span>(y) &#123; &#125;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getX</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>-&gt;x; &#125;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getY</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>-&gt;y; &#125;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> x, y;<br>&#125;;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-function">Point <span class="hljs-title">a</span><span class="hljs-params">(<span class="hljs-number">4</span>, <span class="hljs-number">5</span>)</span></span>; <span class="hljs-comment">//普通对象</span><br>    <span class="hljs-function">Point <span class="hljs-type">const</span> <span class="hljs-title">b</span><span class="hljs-params">(<span class="hljs-number">6</span>,<span class="hljs-number">7</span>)</span></span>; <span class="hljs-comment">//常对象</span><br>    Point* pa = &amp;a; <span class="hljs-comment">//定义对象指针，用a的地址初始化</span><br>    <span class="hljs-type">const</span> Point* pb= &amp;b; <span class="hljs-comment">//定义指向常对象的指针，用常对象b的地址初始化</span><br>    <span class="hljs-type">const</span> Point&amp; rb=  b; <span class="hljs-comment">//定义常引用rb（对于常对象的引用），常对象b的别名</span><br>    cout &lt;&lt; pa-&gt;<span class="hljs-built_in">getX</span>() &lt;&lt; endl;<span class="hljs-comment">//用指针访问对象成员</span><br>    cout&lt;&lt; a.<span class="hljs-built_in">getY</span>() &lt;&lt;endl;<br>    cout &lt;&lt; (*pb).<span class="hljs-built_in">getY</span>() &lt;&lt; endl; <span class="hljs-comment">//用指针求内容运算符访问对象成员</span><br>    cout &lt;&lt; rb.<span class="hljs-built_in">getX</span>() &lt;&lt; endl; <span class="hljs-comment">//用常引用来访问对象成员</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<p>注意：在 C++ 中，Point&amp; const rb &#x3D; b; 这样的写法实际上是不合法的。原因在于，引用本身在初始化后就不能改变其所绑定的对象，因此将引用本身声明为 const 是没有意义的。换句话说，引用本质上就是常量，一旦它绑定到了一个对象，就不能再被重新绑定到另一个对象。</p>
<p>所以，Point&amp; const rb &#x3D; b; 这样的声明是多余的，因为 rb 作为一个引用，本身就是不可变的。正确的声明应该只是 Point&amp; rb &#x3D; b;，表示 rb 是对 b 的一个引用。</p>
<h2 id="2-5static-成员"><a href="#2-5static-成员" class="headerlink" title="2.5static 成员"></a>2.5static 成员</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//当你在函数内部声明一个 static 局部变量时，比如:</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">function</span><span class="hljs-params">()</span> </span>&#123;  <br>    <span class="hljs-type">static</span> <span class="hljs-type">int</span> calls = <span class="hljs-number">0</span>;  <br>    calls++;  <br>    <span class="hljs-comment">// ...  </span><br>&#125;<br></code></pre></td></tr></table></figure>
<p>这里的 calls 变量有以下几个特点：</p>
<p>生命周期：calls 的生命周期贯穿整个程序的执行期间，与全局变量的生命周期相同。这意味着，<strong>即使 function 函数返回后，calls 也不会被销毁</strong>，它的值会保留到下一次调用 function。</p>
<p>初始化：calls 只在程序第一次执行到该变量定义时被初始化一次，之后的函数调用中不会再次初始化。</p>
<p>作用域：与全局变量不同的是，calls 的作用域仅限于定义它的函数内部。这意味着，只有在 function 函数内部才能访问和修改 calls。在函数外部是无法直接访问这个变量的。</p>
<p>存储类别：static 局部变量存储在静态存储区，而不是栈内存。</p>
<p>因此，虽然 static int calls &#x3D; 0; 在函数内部给 calls 赋予了类似全局变量的生命周期和存储类别，但它的作用域仍然是局部的，仅限于定义它的函数内。这与全局变量（在整个程序中都可见）是有所不同的。</p>
<p>注意：<strong>初始化静态成员变量必须在类外定义</strong></p>
<h2 id="2-6类的组合"><a href="#2-6类的组合" class="headerlink" title="2.6类的组合"></a>2.6类的组合</h2><p>在C++中，类的组合指的是在一个类中使用其他类的对象作为成员。这种技术允许我们构建更复杂的类，这些类由更简单的组件类组成。下面是一个简单的代码实例，展示了如何在C++中使用类的组合。</p>
<p>假设我们有一个Student类和一个Address类。每个学生都有一个地址，因此我们可以将Address类的对象作为Student类的一个成员。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span>  </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span>  </span><br>  <br><span class="hljs-comment">// Address类  </span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Address</span> &#123;  <br><span class="hljs-keyword">public</span>:  <br>    <span class="hljs-built_in">Address</span>(<span class="hljs-type">const</span> std::string&amp; street, <span class="hljs-type">const</span> std::string&amp; city, <span class="hljs-type">const</span> std::string&amp; country)  <br>        : <span class="hljs-built_in">street_</span>(street), <span class="hljs-built_in">city_</span>(city), <span class="hljs-built_in">country_</span>(country) &#123;&#125;  <br>  <br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Print</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;  <br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Street: &quot;</span> &lt;&lt; street_ &lt;&lt; <span class="hljs-string">&quot;, City: &quot;</span> &lt;&lt; city_ &lt;&lt; <span class="hljs-string">&quot;, Country: &quot;</span> &lt;&lt; country_ &lt;&lt; std::endl;  <br>    &#125;  <br>  <br><span class="hljs-keyword">private</span>:  <br>    std::string street_;  <br>    std::string city_;  <br>    std::string country_;  <br>&#125;;  <br>  <br><span class="hljs-comment">// Student类，它组合了一个Address对象  </span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> &#123;  <br><span class="hljs-keyword">public</span>:  <br>    <span class="hljs-built_in">Student</span>(<span class="hljs-type">const</span> std::string&amp; name, <span class="hljs-type">const</span> Address&amp; address)  <br>        : <span class="hljs-built_in">name_</span>(name), <span class="hljs-built_in">address_</span>(address) &#123;&#125;  <br>  <br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Introduce</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;  <br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Hello, my name is &quot;</span> &lt;&lt; name_ &lt;&lt; <span class="hljs-string">&quot;. I live at: &quot;</span>;  <br>        address_.<span class="hljs-built_in">Print</span>();  <br>    &#125;  <br>  <br><span class="hljs-keyword">private</span>:  <br>    std::string name_;  <br>    Address address_;  <span class="hljs-comment">// 组合了一个Address对象  </span><br>&#125;;  <br>  <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;  <br>    <span class="hljs-comment">// 创建一个Address对象  </span><br>    <span class="hljs-function">Address <span class="hljs-title">address</span><span class="hljs-params">(<span class="hljs-string">&quot;Main Street&quot;</span>, <span class="hljs-string">&quot;Smallville&quot;</span>, <span class="hljs-string">&quot;Country X&quot;</span>)</span></span>;  <br>    <span class="hljs-comment">// 创建一个Student对象，并传入Address对象作为组合成员  </span><br>    <span class="hljs-function">Student <span class="hljs-title">student</span><span class="hljs-params">(<span class="hljs-string">&quot;John Doe&quot;</span>, address)</span></span>;  <br>    <span class="hljs-comment">// 学生介绍自己，包括姓名和地址信息  </span><br>    student.<span class="hljs-built_in">Introduce</span>();  <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;  <br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="2-7友元"><a href="#2-7友元" class="headerlink" title="2.7友元"></a>2.7友元</h2><p>C++中的“友元”（friend）是一个特殊的声明，它允许一个或多个非成员函数或另一个类访问类的私有和保护成员。这是一种<strong>突破数据封装</strong>的方式，通常应当谨慎使用，但在某些情况下，它可以提供很大的便利，特别是在操作符重载和实现某些设计模式时。</p>
<p><strong>注意事项</strong></p>
<p>1 过度使用友元可能会破坏封装性，因此应谨慎使用。<br>2 友元关系不是对称的，也不是传递的。即，如果类A是类B的友元，这并不意味着类B也是类A的友元；同样，如果类A是类B的友元，类B是类C的友元，这并不意味着类A是类C的友元。<br>3 友元可以是全局函数、其他类的成员函数或整个类。在类定义中，使用friend关键字声明友元。<br>友元可以是一个函数，也可以是另一个类。下面，我将分别给出这两种情况的代码示例。    </p>
<h3 id="友元函数"><a href="#友元函数" class="headerlink" title="友元函数"></a>友元函数</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span>  </span><br>  <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> &#123;  <br><span class="hljs-keyword">private</span>:  <br>    <span class="hljs-type">int</span> privateVar;  <br>  <br><span class="hljs-keyword">public</span>:  <br>    <span class="hljs-built_in">MyClass</span>(<span class="hljs-type">int</span> var) : <span class="hljs-built_in">privateVar</span>(var) &#123;&#125;  <br>  <br>    <span class="hljs-comment">// 声明 printMyClass 为友元函数  </span><br>    <span class="hljs-function"><span class="hljs-keyword">friend</span> <span class="hljs-type">void</span> <span class="hljs-title">printMyClass</span><span class="hljs-params">(<span class="hljs-type">const</span> MyClass&amp; obj)</span></span>;  <br>&#125;;  <br>  <br><span class="hljs-comment">// 由于 printMyClass 是 MyClass 的友元函数，所以它可以访问 MyClass 的私有成员  </span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printMyClass</span><span class="hljs-params">(<span class="hljs-type">const</span> MyClass&amp; obj)</span> </span>&#123;  <br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Private variable is: &quot;</span> &lt;&lt; obj.privateVar &lt;&lt; std::endl;  <br>&#125;  <br>  <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;  <br>    <span class="hljs-function">MyClass <span class="hljs-title">obj</span><span class="hljs-params">(<span class="hljs-number">42</span>)</span></span>;  <br>    <span class="hljs-built_in">printMyClass</span>(obj);  <span class="hljs-comment">// 输出: Private variable is: 42  </span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;  <br>&#125;<br></code></pre></td></tr></table></figure>
<p>当然，如果如果我把<code>void printMyClass(const MyClass&amp; obj) &#123;       std::cout &lt;&lt; &quot;Private variable is: &quot; &lt;&lt; obj.privateVar &lt;&lt; std::endl;   &#125;  </code>放进class的定义里面就不需要使用友元,因为成员函数可以直接访问类的所有成员，包括私有成员。</p>
<h3 id="友元类"><a href="#友元类" class="headerlink" title="友元类"></a>友元类</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span>  </span><br>  <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> &#123;  <br><span class="hljs-keyword">private</span>:  <br>    <span class="hljs-type">int</span> privateVar;  <br>  <br><span class="hljs-keyword">public</span>:  <br>    <span class="hljs-built_in">MyClass</span>(<span class="hljs-type">int</span> var) : <span class="hljs-built_in">privateVar</span>(var) &#123;&#125;  <br>  <br>    <span class="hljs-comment">// 声明 AnotherClass 为友元类  </span><br>    <span class="hljs-keyword">friend</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AnotherClass</span>;  <br>&#125;;  <br>  <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">AnotherClass</span> &#123;  <br><span class="hljs-keyword">public</span>:  <br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printMyClassPrivateVar</span><span class="hljs-params">(<span class="hljs-type">const</span> MyClass&amp; obj)</span> </span>&#123;  <br>        std::cout &lt;&lt; <span class="hljs-string">&quot;MyClass&#x27;s private variable is: &quot;</span> &lt;&lt; obj.privateVar &lt;&lt; std::endl;  <br>    &#125;  <br>&#125;;  <br>  <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;  <br>    <span class="hljs-function">MyClass <span class="hljs-title">obj</span><span class="hljs-params">(<span class="hljs-number">42</span>)</span></span>;  <br>    AnotherClass anotherObj;  <br>    anotherObj.<span class="hljs-built_in">printMyClassPrivateVar</span>(obj);  <span class="hljs-comment">// 输出: MyClass&#x27;s private variable is: 42  </span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;  <br>&#125;<br><br></code></pre></td></tr></table></figure>

<h1 id="（三）多态与继承"><a href="#（三）多态与继承" class="headerlink" title="（三）多态与继承"></a>（三）多态与继承</h1><h2 id="3-1-运算符重载"><a href="#3-1-运算符重载" class="headerlink" title="3.1 运算符重载"></a>3.1 运算符重载</h2><p>重载，就是赋予新的含义。函数重载（Function Overloading）可以让一个函数名有多种功能，在不同情况下进行不同的操作。运算符重载（Operator Overloading）也是一个道理，同一个运算符可以有不同的功能。</p>
<h3 id="3-1-1运算符重载"><a href="#3-1-1运算符重载" class="headerlink" title="3.1.1运算符重载"></a>3.1.1运算符重载</h3><p>举个例子：复数的加法</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span>    </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span>    </span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;  <br>  <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Cmycomplex</span> &#123;    <br><span class="hljs-keyword">private</span>:    <br>    <span class="hljs-type">double</span> real;    <br>    <span class="hljs-type">double</span> imag;    <br><span class="hljs-keyword">public</span>:    <br>    <span class="hljs-built_in">Cmycomplex</span>(<span class="hljs-type">double</span> r = <span class="hljs-number">0.0</span>, <span class="hljs-type">double</span> i = <span class="hljs-number">0.0</span>) : <span class="hljs-built_in">real</span>(r), <span class="hljs-built_in">imag</span>(i) &#123;&#125;    <br>    <span class="hljs-comment">//加法运算实现</span><br>    <span class="hljs-function">Cmycomplex <span class="hljs-title">Add</span><span class="hljs-params">(<span class="hljs-type">const</span> Cmycomplex&amp; oz)</span>  </span>&#123;  <br>        Cmycomplex t;  <br>        t.real = real + oz.real;  <br>        t.imag = imag + oz.imag;  <br>        <span class="hljs-keyword">return</span> t;  <br>    &#125;  <br>    <span class="hljs-comment">// 重载 + 运算符，作为成员函数  </span><br>    Cmycomplex <span class="hljs-keyword">operator</span>+(<span class="hljs-type">const</span> Cmycomplex&amp; oz)  &#123;  <br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">Add</span>(oz);  <br>    &#125;  <br>&#125;;  <br>  <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;  <br>    <span class="hljs-function">Cmycomplex <span class="hljs-title">z1</span><span class="hljs-params">(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>)</span>, z2, <span class="hljs-title">z3</span><span class="hljs-params">(<span class="hljs-number">3</span>)</span></span>;  <br>    z2 = z1 + z3;  <span class="hljs-comment">// 使用重载的 + 运算符  </span><br>    z<span class="hljs-number">2.</span><span class="hljs-built_in">Show</span>();    <span class="hljs-comment">// 输出: (5+3i) 或者 (5+3i) 根据虚部的正负  </span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;  <br>&#125;<br></code></pre></td></tr></table></figure>
<p>格式即</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp">返回值类型 <span class="hljs-keyword">operator</span> 运算符名称 (形参表列)&#123;<br>    <span class="hljs-comment">//<span class="hljs-doctag">TODO:</span></span><br>&#125;<br></code></pre></td></tr></table></figure>
<p>在C++中，当你使用c1 + c2这样的表达式时，实际上是调用了c1对象的operator+成员函数，并将c2作为参数传递进去。因此，c1是隐式传递的，因为它是调用该成员函数的对象。</p>
<p>这里是详细的过程：</p>
<p>1.当你写c1 + c2时，编译器会查找Cmycomplex类中是否定义了operator+成员函数。</p>
<p>2.编译器发现Cmycomplex类中确实定义了这样一个成员函数，于是它开始准备调用这个函数。</p>
<p>3.由于operator+是一个成员函数，它会自动地绑定到调用它的对象上，即c1。因此，c1本身就是函数的调用者（或称为接收者），不需要显式传递。</p>
<p>4.编译器将c2作为参数传递给c1.operator+(const Cmycomplex&amp; oz)函数。在这个上下文中，oz就是c2的引用。</p>
<p>5.函数执行加法操作，并返回一个新的Cmycomplex对象，这个对象表示c1和c2的和。</p>
<p>6.所以，虽然看起来你只传递了一个参数（即c2），但实际上c1也参与了操作，因为它是调用operator+函数的对象。这就是为什么在成员函数内部可以通过this指针来访问调用对象的成员，因为成员函数隐式地与调用它的对象绑定。</p>
<p>简而言之，c1是通过成员函数调用的隐式绑定机制传入的，而c2是作为参数显式传入的。</p>
<p><strong>那么如何重载”3+z1”这样的式子呢？</strong></p>
<p>为了支持 3 + z1 这样的表达式，我们需要为 Cmycomplex 类提供一个非成员函数（友元函数）来重载 operator+，使其能够接受一个 double（或 int）作为第一个参数，和一个 Cmycomplex 对象作为第二个参数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span>  </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span>  </span><br><span class="hljs-comment">//规范小驼峰命名从我做起 </span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Cmycomplex</span> &#123;  <br><span class="hljs-keyword">private</span>:  <br>    <span class="hljs-type">double</span> real;  <br>    <span class="hljs-type">double</span> imag;  <br><span class="hljs-keyword">public</span>:  <br>    <span class="hljs-built_in">Cmycomplex</span>(<span class="hljs-type">double</span> r = <span class="hljs-number">3.0</span>, <span class="hljs-type">double</span> i = <span class="hljs-number">0.0</span>) : <span class="hljs-built_in">real</span>(r), <span class="hljs-built_in">imag</span>(i) &#123;&#125;  <br>	<span class="hljs-comment">//运算实现</span><br>	<span class="hljs-function">Cmycomplex <span class="hljs-title">Add</span><span class="hljs-params">(<span class="hljs-type">const</span> Cmycomplex&amp; oz)</span></span><br><span class="hljs-function">	</span>&#123;<br>		Cmycomplex t;<br>		t.real=real+oz.real;<br>		t.imag=imag+oz.imag;<br>		<span class="hljs-keyword">return</span> t;<br>	&#125;<br>	<span class="hljs-comment">//运算符重载</span><br>	Cmycomplex <span class="hljs-keyword">operator</span>+(<span class="hljs-type">const</span> Cmycomplex&amp; oz) &#123;<br>		<span class="hljs-keyword">return</span> <span class="hljs-built_in">Add</span>(oz);<br>	&#125;<br>	<span class="hljs-comment">//后缀求和 </span><br>	<span class="hljs-keyword">friend</span> Cmycomplex <span class="hljs-keyword">operator</span>+(<span class="hljs-type">double</span> n, <span class="hljs-type">const</span> Cmycomplex &amp;oz) &#123;<br>             Cmycomplex t;<br>            t.real=n+oz.real;<br>			t.imag=oz.imag; <br>            <span class="hljs-keyword">return</span> t;<br>        &#125;<br>&#125;;  <br></code></pre></td></tr></table></figure>
<p>这在语法上是可行的，但是我们通常不把友元函数的功能在class内部实现，规范的代码应当将定义放在类外以保持代码的清晰和封装性。这样做也有助于将类的接口（即公共成员函数和变量）与其实现细节（即私有和保护成员）分离开来。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span>  </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span>  </span><br><span class="hljs-comment">//规范小驼峰命名从我做起 </span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Cmycomplex</span> &#123;  <br><span class="hljs-keyword">private</span>:  <br>    <span class="hljs-type">double</span> real;  <br>    <span class="hljs-type">double</span> imag;  <br><span class="hljs-keyword">public</span>:  <br>    <span class="hljs-built_in">Cmycomplex</span>(<span class="hljs-type">double</span> r = <span class="hljs-number">3.0</span>, <span class="hljs-type">double</span> i = <span class="hljs-number">0.0</span>) : <span class="hljs-built_in">real</span>(r), <span class="hljs-built_in">imag</span>(i) &#123;&#125;  <br>	<span class="hljs-comment">//运算实现</span><br>	<span class="hljs-function">Cmycomplex <span class="hljs-title">Add</span><span class="hljs-params">(<span class="hljs-type">const</span> Cmycomplex&amp; oz)</span></span><br><span class="hljs-function">	</span>&#123;<br>		Cmycomplex t;<br>		t.real=real+oz.real;<br>		t.imag=imag+oz.imag;<br>		<span class="hljs-keyword">return</span> t;<br>	&#125;<br>	<span class="hljs-comment">//运算符重载</span><br>	Cmycomplex <span class="hljs-keyword">operator</span>+(<span class="hljs-type">const</span> Cmycomplex&amp; oz) &#123;<br>		<span class="hljs-keyword">return</span> <span class="hljs-built_in">Add</span>(oz);<br>	&#125;<br>	<span class="hljs-comment">//后缀求和 </span><br>	<span class="hljs-keyword">friend</span> Cmycomplex <span class="hljs-keyword">operator</span>+(<span class="hljs-type">double</span> , <span class="hljs-type">const</span> Cmycomplex &amp;) ;<br>        <br>&#125;;  <br>Cmycomplex <span class="hljs-keyword">operator</span>+(<span class="hljs-type">double</span> n, <span class="hljs-type">const</span> Cmycomplex &amp;oz) &#123;<br>             Cmycomplex t;<br>            t.real=n+oz.real;<br>			t.imag=oz.imag; <br>            <span class="hljs-keyword">return</span> t;<br>        &#125;<br></code></pre></td></tr></table></figure>


<h3 id="3-1-2流运算符重载"><a href="#3-1-2流运算符重载" class="headerlink" title="3.1.2流运算符重载"></a>3.1.2流运算符重载</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span>  </span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std<br>  <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Complex</span> &#123;  <br><span class="hljs-keyword">public</span>:  <br>    <span class="hljs-keyword">friend</span> ostream&amp; <span class="hljs-keyword">operator</span>&lt;&lt;(ostream&amp; out, <span class="hljs-type">const</span> Complex&amp; c);  <br>    <span class="hljs-keyword">friend</span> istream&amp; <span class="hljs-keyword">operator</span>&gt;&gt;(istream&amp; in, Complex&amp; c);  <br>  <br><span class="hljs-keyword">private</span>:  <br>    <span class="hljs-type">double</span> real, imag;  <br>&#125;;  <br>  <br><span class="hljs-comment">// 实现输出运算符重载  </span><br>ostream&amp; <span class="hljs-keyword">operator</span>&lt;&lt;(ostream&amp; out, <span class="hljs-type">const</span> Complex&amp; c) &#123;  <br>    out &lt;&lt; <span class="hljs-string">&quot;(&quot;</span> &lt;&lt; c.real &lt;&lt; <span class="hljs-string">&quot;+&quot;</span> &lt;&lt; c.imag &lt;&lt; <span class="hljs-string">&quot;i)&quot;</span>;  <br>    <span class="hljs-keyword">return</span> out;  <br>&#125;  <br>  <br><span class="hljs-comment">// 实现输入运算符重载  </span><br>istream&amp; <span class="hljs-keyword">operator</span>&gt;&gt;(istream&amp; in, Complex&amp; c) &#123;  <br>    in &gt;&gt; c.real &gt;&gt; c.imag;  <br>    <span class="hljs-keyword">return</span> in;  <br>&#125;  <br></code></pre></td></tr></table></figure>
<p><strong>注意istream&amp; operator&gt;&gt;(istream&amp; in, Complex&amp; c)无const,因为要改变c的内部状态了！！！</strong></p>
<h3 id="3-1-3自增和自减运算符重载"><a href="#3-1-3自增和自减运算符重载" class="headerlink" title="3.1.3自增和自减运算符重载"></a>3.1.3自增和自减运算符重载</h3><p>这个功能只能在类内实现。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Time</span> &#123;  <br><span class="hljs-keyword">private</span>:  <br>    <span class="hljs-type">int</span> hour, minute, second;  <br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">normalizeTime</span><span class="hljs-params">()</span> </span>&#123;  <span class="hljs-comment">//用这个时间进位初始化 </span><br>        <span class="hljs-comment">//******</span><br>    &#125;  <br><span class="hljs-keyword">public</span>:  <br>    <span class="hljs-comment">//******</span><br>      <br>    Time&amp; <span class="hljs-keyword">operator</span>--() &#123;   <span class="hljs-comment">//前缀 </span><br>        second--;  <br>        <span class="hljs-built_in">normalizeTime</span>();  <br>        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;  <br>    &#125;  <br>    Time <span class="hljs-keyword">operator</span>--(<span class="hljs-type">int</span>)&#123;  <span class="hljs-comment">//后缀</span><br>    	Time temp=*<span class="hljs-keyword">this</span>;<br>    	second--;<br>    	<span class="hljs-keyword">return</span> temp;<br>	&#125;  <br>    <span class="hljs-keyword">friend</span> Time <span class="hljs-keyword">operator</span>+(<span class="hljs-type">int</span> ,<span class="hljs-type">const</span> Time&amp;) ;<br>      <br>    <span class="hljs-comment">//*****</span><br>&#125;;<br>Time <span class="hljs-keyword">operator</span>+(<span class="hljs-type">int</span> increase,<span class="hljs-type">const</span> Time&amp; t) &#123;  <br>    	<span class="hljs-function">Time <span class="hljs-title">result</span><span class="hljs-params">(t)</span></span>; <span class="hljs-comment">// Make a copy of t  </span><br>    	result.second += increase;  <br>    	result.<span class="hljs-built_in">normalizeTime</span>();  <br>    	<span class="hljs-keyword">return</span> result;  <br>&#125;    <br></code></pre></td></tr></table></figure>

<h2 id="3-2继承"><a href="#3-2继承" class="headerlink" title="3.2继承"></a>3.2继承</h2><p>保持已有类的特性而构造新类的过程称为继承(inheritance)。      </p>
<p>在已有类的基础上新增自己的特性而产生新类的过程称为派生。   </p>
<p>被继承的已有类称为基类(based class)（或父类）。   </p>
<p>派生出的新类称为派生类(derived class)（或子类）   </p>
<p>继承的目的：实现代码重用。</p>
<p>派生的目的：实现代码的可扩充性。当新的问题出现，原有程序无法解决（或不能完全解决）时，需要对原有程序进行改造。</p>
<p>继承的真正魅力在于<strong>能够添加基类所没有的特点以及取代和改进从基类继承来的特点。</strong></p>
<p><img src="https://www.freeimg.cn/i/2024/05/09/663cb010b9c3f.png" srcset="/img/loading.gif" lazyload></p>
<h3 id="3-2-1子类父类"><a href="#3-2-1子类父类" class="headerlink" title="3.2.1子类父类"></a>3.2.1子类父类</h3><p><strong>关于protected和private的区别:</strong>                </p>
<p>简而言之，友元类既可以访问private也可以访问protected，但是派生类(子类)只能访问父类的protected</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span>  </span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;  <br>  <br><span class="hljs-comment">// 基类（父类）  </span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Animal</span> &#123;  <br><span class="hljs-keyword">public</span>:  <br>    <span class="hljs-built_in">Animal</span>(string name) : <span class="hljs-built_in">name</span>(name) &#123;&#125;  <br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">eat</span><span class="hljs-params">()</span> </span>&#123;  <br>        cout &lt;&lt; name &lt;&lt; <span class="hljs-string">&quot; is eating.&quot;</span> &lt;&lt; endl;  <br>    &#125;  <br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">sleep</span><span class="hljs-params">()</span> </span>&#123;  <br>        cout &lt;&lt; name &lt;&lt; <span class="hljs-string">&quot; is sleeping.&quot;</span> &lt;&lt; endl;  <br>    &#125;  <br><span class="hljs-keyword">protected</span>:  <span class="hljs-comment">//改为private则子类Dog不可访问</span><br>    string name; <span class="hljs-comment">// 受保护的成员变量，子类可以访问  </span><br>&#125;;  <br>  <br><span class="hljs-comment">// 派生类（子类）  </span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Dog</span> : <span class="hljs-keyword">public</span> Animal &#123; <span class="hljs-comment">// 使用 public 继承  </span><br><span class="hljs-keyword">public</span>:  <br>    <span class="hljs-built_in">Dog</span>(string name) : <span class="hljs-built_in">Animal</span>(name) &#123;&#125; <span class="hljs-comment">// 调用基类的构造函数  </span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">bark</span><span class="hljs-params">()</span> </span>&#123;  <br>        cout &lt;&lt; name &lt;&lt; <span class="hljs-string">&quot; is barking.&quot;</span> &lt;&lt; endl;  <br>    &#125;  <br>&#125;;  <br>  <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;  <br>    <span class="hljs-function">Dog <span class="hljs-title">myDog</span><span class="hljs-params">(<span class="hljs-string">&quot;Rex&quot;</span>)</span></span>; <span class="hljs-comment">// 创建一个 Dog 对象  </span><br>    myDog.<span class="hljs-built_in">eat</span>();     <span class="hljs-comment">// 调用从 Animal 继承的方法  </span><br>    myDog.<span class="hljs-built_in">sleep</span>();   <span class="hljs-comment">// 调用从 Animal 继承的方法  </span><br>    myDog.<span class="hljs-built_in">bark</span>();    <span class="hljs-comment">// 调用 Dog 特有的方法  </span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;  <br>&#125;<br><br><br></code></pre></td></tr></table></figure>
<p>在这个示例中，我们定义了一个基类 Animal，它包含两个方法：eat() 和 sleep()，以及一个受保护的成员变量 name。然后，我们定义了一个派生类 Dog，它继承自 Animal 类。在 Dog 类中，我们添加了一个新的方法 bark()。</p>
<p>在 main() 函数中，我们创建了一个 Dog 类的对象 myDog，并调用了它的方法。注意，由于 Dog 继承自 Animal，所以 myDog 可以调用 Animal 类中定义的方法（eat() 和 sleep()），也可以调用 Dog 类中特有的方法（bark()）。</p>
<p><strong>关于public继承和private继承的区别</strong></p>
<p><strong>public继承</strong><br>基类的public成员在派生类中仍然是public的。<br>基类的protected成员在派生类中仍然是protected的。<br>派生类外部的代码可以访问派生类中继承自基类的public和protected成员（如果派生类提供了访问这些成员的接口）。<br><strong>private继承</strong><br>基类的public和protected成员在派生类中都变成了private的。<br>派生类外部的代码无法直接访问派生类中继承自基类的任何成员。   </p>
<p>在C++中，当派生类中存在与基类同名的成员变量或成员函数时，编译器需要一种机制来区分它们。这种情况通常发生在派生类重写（override）基类的成员函数，或者在派生类中声明了与基类同名的成员变量。</p>
<p><strong>同名成员变量</strong><br>对于成员变量，如果派生类中声明了与基类同名的成员变量，编译器会选择派生类中的变量。这意味着，如果你在派生类的方法中直接使用这个成员变量名，那么编译器将默认使用派生类中的变量，而不是基类中的。</p>
<p>如果你需要在派生类中访问基类中的同名成员变量，你可以使用作用域解析运算符（::）来明确指定基类的成员变量。例如：</p>
<p><strong>同名成员函数（非虚函数）对于非虚成员函数，如果你在派生类中定义了一个与基类同名的成员函数（即没有使用 virtual 关键字），这个函数将隐藏基类中的同名函数，而不是重写它。这意味着，如果你通过派生类对象调用这个函数，将执行派生类中的版本。如果你有一个基类指针或引用指向派生类对象，并且调用了这个函数，那么将执行基类中的版本，因为这不是多态行为</strong></p>
<h3 id="3-2-2多继承"><a href="#3-2-2多继承" class="headerlink" title="3.2.2多继承"></a>3.2.2多继承</h3><p>多继承是指一个类可以同时继承多个基类。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//多继承：</span><br><span class="hljs-keyword">class</span> 派生类名：继承方式  基类名<span class="hljs-number">1</span>，继承方式  基类名<span class="hljs-number">2</span>，......<br>&#123;<br>        成员声明；<br>&#125;;<br>-----------------------------------------------<br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span>  </span><br>  <br><span class="hljs-comment">// 第一个基类：Animal  </span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Animal</span> &#123;  <br><span class="hljs-keyword">public</span>:  <br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">eat</span><span class="hljs-params">()</span> </span>&#123;  <br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Animal eats.&quot;</span> &lt;&lt; std::endl;  <br>    &#125;  <br>&#125;;  <br>  <br><span class="hljs-comment">// 第二个基类：Flyable  </span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Flyable</span> &#123;  <br><span class="hljs-keyword">public</span>:  <br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">fly</span><span class="hljs-params">()</span> </span>&#123;  <br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Flying high in the sky.&quot;</span> &lt;&lt; std::endl;  <br>    &#125;  <br>&#125;;  <br>  <br><span class="hljs-comment">// 派生类：Bird，它继承了Animal和Flyable  </span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Bird</span> : <span class="hljs-keyword">public</span> Animal, <span class="hljs-keyword">public</span> Flyable &#123;  <br><span class="hljs-keyword">public</span>:  <br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">sing</span><span class="hljs-params">()</span> </span>&#123;  <br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Bird sings a beautiful song.&quot;</span> &lt;&lt; std::endl;  <br>    &#125;  <br>&#125;;  <br>  <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;  <br>    Bird bird;  <br>    bird.<span class="hljs-built_in">eat</span>();    <span class="hljs-comment">// 调用继承自Animal的方法  </span><br>    bird.<span class="hljs-built_in">fly</span>();    <span class="hljs-comment">// 调用继承自Flyable的方法  </span><br>    bird.<span class="hljs-built_in">sing</span>();   <span class="hljs-comment">// Bird自己的方法  </span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;  <br>&#125;<br><br></code></pre></td></tr></table></figure>
<p>在这个例子中，我们有两个基类：Animal 和 Flyable。Animal 类有一个 eat 方法，而 Flyable 类有一个 fly 方法。然后，我们定义了一个派生类 Bird，它同时继承了 Animal 和 Flyable。Bird 类还定义了自己的 sing 方法。</p>
<p>在 main 函数中，我们创建了一个 Bird 对象，并调用了它的 eat、fly 和 sing 方法。由于 Bird 继承了 Animal 和 Flyable，因此它可以访问这两个基类的方法。</p>
<p>然而，多继承也可能导致一些问题，特别是菱形继承问题（也称为钻石继承或死亡钻石），这通常发生在当一个类从多个路径继承同一个基类时。这可能导致基类的多个实例在派生类中存在，从而引发歧义和浪费内存。这个问题可以通过虚继承（virtual inheritance）来解决，它确保在继承层次结构中只有一个共享的基类实例。</p>
<h3 id="3-2-3继承时的构造函数"><a href="#3-2-3继承时的构造函数" class="headerlink" title="3.2.3继承时的构造函数"></a>3.2.3继承时的构造函数</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span>  </span><br>  <br><span class="hljs-comment">// 基类  </span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Vehicle</span> &#123;  <br><span class="hljs-keyword">protected</span>:  <br>    <span class="hljs-type">int</span> wheels;  <br>    <span class="hljs-type">float</span> enginePower;  <br>  <br><span class="hljs-keyword">public</span>:  <br>    <span class="hljs-comment">// 基类的构造函数  </span><br>    <span class="hljs-built_in">Vehicle</span>(<span class="hljs-type">int</span> w, <span class="hljs-type">float</span> p) : <span class="hljs-built_in">wheels</span>(w), <span class="hljs-built_in">enginePower</span>(p) &#123;  <br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Vehicle constructor called with &quot;</span> &lt;&lt; wheels &lt;&lt; <span class="hljs-string">&quot; wheels and &quot;</span> &lt;&lt; enginePower &lt;&lt; <span class="hljs-string">&quot; power.&quot;</span> &lt;&lt; std::endl;  <br>    &#125;  <br>  <br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">displayVehicleInfo</span><span class="hljs-params">()</span> </span>&#123;  <br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Vehicle has &quot;</span> &lt;&lt; wheels &lt;&lt; <span class="hljs-string">&quot; wheels and &quot;</span> &lt;&lt; enginePower &lt;&lt; <span class="hljs-string">&quot; engine power.&quot;</span> &lt;&lt; std::endl;  <br>    &#125;  <br>&#125;;  <br>  <br><span class="hljs-comment">// 派生类  </span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Car</span> : <span class="hljs-keyword">public</span> Vehicle &#123;  <br><span class="hljs-keyword">private</span>:  <br>    <span class="hljs-type">int</span> doors;  <br>  <br><span class="hljs-keyword">public</span>:  <br>    <span class="hljs-comment">// 派生类的构造函数  </span><br>    <span class="hljs-built_in">Car</span>(<span class="hljs-type">int</span> w, <span class="hljs-type">float</span> p, <span class="hljs-type">int</span> d) : <span class="hljs-built_in">Vehicle</span>(w, p), <span class="hljs-built_in">doors</span>(d) &#123;  <br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Car constructor called with &quot;</span> &lt;&lt; doors &lt;&lt; <span class="hljs-string">&quot; doors.&quot;</span> &lt;&lt; std::endl;  <br>    &#125;  <br>  <br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">displayCarInfo</span><span class="hljs-params">()</span> </span>&#123;  <br>        <span class="hljs-built_in">displayVehicleInfo</span>(); <span class="hljs-comment">// 调用基类的成员函数  </span><br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Car has &quot;</span> &lt;&lt; doors &lt;&lt; <span class="hljs-string">&quot; doors.&quot;</span> &lt;&lt; std::endl;  <br>    &#125;  <br>&#125;;  <br>  <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;  <br>    <span class="hljs-function">Car <span class="hljs-title">myCar</span><span class="hljs-params">(<span class="hljs-number">4</span>, <span class="hljs-number">150.0f</span>, <span class="hljs-number">5</span>)</span></span>; <span class="hljs-comment">// 创建一个Car对象，该对象会先调用Vehicle的构造函数，然后调用Car的构造函数  </span><br>    myCar.<span class="hljs-built_in">displayCarInfo</span>(); <span class="hljs-comment">// 显示汽车的信息，包括车轮数量、发动机功率和车门数量  </span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;  <br>&#125;<br></code></pre></td></tr></table></figure>
<p>在上面的示例中，我们有一个基类Vehicle和一个派生类Car。Vehicle类有一个受保护的成员变量wheels和enginePower，以及一个公共的构造函数来初始化这些变量。Car类继承自Vehicle，并添加了一个新的私有成员变量doors。</p>
<p>在Car类的构造函数中，我们通过成员初始化列表来调用Vehicle的构造函数，以初始化从Vehicle继承的成员变量。这是通过: Vehicle(w, p)部分完成的，其中w和p是传递给Car构造函数的参数。然后，Car的构造函数继续初始化其自己的成员变量doors。</p>
<p>在main函数中，我们创建了一个Car对象，并传递了车轮数量、发动机功率和车门数量作为参数。这将依次调用Vehicle和Car的构造函数。最后，我们调用displayCarInfo函数来显示汽车的信息，该函数内部调用了基类的displayVehicleInfo函数来显示车轮数量和发动机功率的信息。</p>
<h3 id="3-2-4虚函数"><a href="#3-2-4虚函数" class="headerlink" title="3.2.4虚函数"></a>3.2.4虚函数</h3><p>定义了一个基类Animal和两个派生类Dog和Cat。基类Animal中有一个虚函数makeSound()，它在派生类中被重写以提供不同的实现。在main()函数中，我们使用基类指针来调用不同派生类的makeSound()函数，展示了多态性的效果。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span>  </span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;  <br>  <br><span class="hljs-comment">// 基类Animal  </span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Animal</span> &#123;  <br><span class="hljs-keyword">public</span>:  <br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">makeSound</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-comment">// 虚函数声明  </span><br>        cout &lt;&lt; <span class="hljs-string">&quot;Animal makes a sound&quot;</span> &lt;&lt; endl;  <br>    &#125;  <br>&#125;;  <br>  <br><span class="hljs-comment">// 派生类Dog  </span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Dog</span> : <span class="hljs-keyword">public</span> Animal &#123;  <br><span class="hljs-keyword">public</span>:  <br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">makeSound</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span> </span>&#123; <span class="hljs-comment">// 虚函数重写  </span><br>        cout &lt;&lt; <span class="hljs-string">&quot;Dog barks&quot;</span> &lt;&lt; endl;  <br>    &#125;  <br>&#125;;  <br>  <br><span class="hljs-comment">// 派生类Cat  </span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Cat</span> : <span class="hljs-keyword">public</span> Animal &#123;  <br><span class="hljs-keyword">public</span>:  <br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">makeSound</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span> </span>&#123; <span class="hljs-comment">// 虚函数重写  </span><br>        cout &lt;&lt; <span class="hljs-string">&quot;Cat meows&quot;</span> &lt;&lt; endl;  <br>    &#125;  <br>&#125;;  <br>  <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;  <br>    Animal* animalPtr; <span class="hljs-comment">// 基类指针  </span><br>    Dog dog;  <br>    Cat cat;  <br>      <br>    <span class="hljs-comment">// 使用基类指针指向Dog对象，并调用其虚函数  </span><br>    animalPtr = &amp;dog;  <br>    animalPtr-&gt;<span class="hljs-built_in">makeSound</span>(); <span class="hljs-comment">// 输出: Dog barks  </span><br>      <br>    <span class="hljs-comment">// 使用基类指针指向Cat对象，并调用其虚函数  </span><br>    animalPtr = &amp;cat;  <br>    animalPtr-&gt;<span class="hljs-built_in">makeSound</span>(); <span class="hljs-comment">// 输出: Cat meows  </span><br>      <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;  <br>&#125;<br></code></pre></td></tr></table></figure>

<p>多态性就体现在指针类型是基类*指针，但是却可以指向他的所有派生类并调用所有的重写后的虚函数</p>
<p>如果一个类中的虚函数没有实现（即函数体为空），则这个函数被称为纯虚函数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">AbstractBase</span> &#123;  <br><span class="hljs-keyword">public</span>:  <br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">pureFunc</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>; <span class="hljs-comment">// 纯虚函数声明  </span><br>&#125;;<br><br></code></pre></td></tr></table></figure>

<h3 id="3-2-5虚析构函数"><a href="#3-2-5虚析构函数" class="headerlink" title="3.2.5虚析构函数"></a>3.2.5虚析构函数</h3><p>对比几段代码</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//创建子类对象b，然后删除</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span>  </span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;  <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> &#123;  <br><span class="hljs-keyword">public</span>:  <br>     ~<span class="hljs-built_in">A</span>() &#123;  <br>        cout &lt;&lt;<span class="hljs-string">&quot;destructor A\n&quot;</span>;  <br>    &#125;  <br>&#125;; <br><span class="hljs-comment">/*或者写为</span><br><span class="hljs-comment">public:  </span><br><span class="hljs-comment">     virtual ~A() &#123;  </span><br><span class="hljs-comment">        cout &lt;&lt;&quot;destructor A\n&quot;;  </span><br><span class="hljs-comment">    &#125;  </span><br><span class="hljs-comment">&#125;;  </span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span> : <span class="hljs-keyword">public</span> A &#123;  <br><span class="hljs-keyword">public</span>:  <br>    ~<span class="hljs-built_in">B</span>() &#123;  <br>        cout &lt;&lt;<span class="hljs-string">&quot;destructor B\n&quot;</span>;  <br>    &#125;  <br>&#125;;  <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    B* b= <span class="hljs-keyword">new</span> <span class="hljs-built_in">B</span>();<br>	<span class="hljs-keyword">delete</span> b;<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; <br><br>&#125;  <br><span class="hljs-comment">/*</span><br><span class="hljs-comment">运行结果</span><br><span class="hljs-comment">destructor B</span><br><span class="hljs-comment">destructor A</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure>
<p>创建A*指针指向子类对象，一个指向派生类的指针可以隐式地转换为一个指向其基类的指针，这是类型安全的向上转型（upcasting）。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span>  </span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;  <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> &#123;  <br><span class="hljs-keyword">public</span>:  <br>      ~<span class="hljs-built_in">A</span>() &#123;  <br>        cout &lt;&lt;<span class="hljs-string">&quot;destructor A\n&quot;</span>;  <br>    &#125;  <br>&#125;;  <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span> : <span class="hljs-keyword">public</span> A &#123;  <br><span class="hljs-keyword">public</span>:  <br>    ~<span class="hljs-built_in">B</span>() &#123;  <br>        cout &lt;&lt;<span class="hljs-string">&quot;destructor B\n&quot;</span>;  <br>    &#125;  <br>&#125;;  <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    A* pa=<span class="hljs-keyword">new</span> <span class="hljs-built_in">B</span>();<br>    <span class="hljs-keyword">delete</span> pa;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>&#125;  <br><span class="hljs-comment">/*</span><br><span class="hljs-comment">destructor A</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure>
<p>如果改成</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span>  </span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;  <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> &#123;  <br><span class="hljs-keyword">public</span>:  <br>      <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">A</span>() &#123;  <br>        cout &lt;&lt;<span class="hljs-string">&quot;destructor A\n&quot;</span>;  <br>    &#125;  <br>&#125;;  <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span> : <span class="hljs-keyword">public</span> A &#123;  <br><span class="hljs-keyword">public</span>:  <br>    ~<span class="hljs-built_in">B</span>() &#123;  <br>        cout &lt;&lt;<span class="hljs-string">&quot;destructor B\n&quot;</span>;  <br>    &#125;  <br>&#125;;  <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    A* pa=<span class="hljs-keyword">new</span> <span class="hljs-built_in">B</span>();<br>    <span class="hljs-keyword">delete</span> pa;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>&#125;  <br><span class="hljs-comment">/*</span><br><span class="hljs-comment">destructor B</span><br><span class="hljs-comment">destructor A</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure>
<p>这是因为当 delete pa; 被执行时，由于 pa 实际上指向的是一个 B 类的对象，所以需要调用 B 的析构函数来释放 B 部分的资源。<br>由于 B 是从 A 继承的，并且在 A 中定义了虚析构函数，所以在 B 的析构函数执行完毕后，会自动调用基类 A 的析构函数来释放 A 部分的资源。<br>重要的是，基类 A 的析构函数被声明为 virtual。这是非常关键的，因为如果基类析构函数不是虚的，那么在删除派生类对象时就不会调用派生类的析构函数，编译器会根据删除指针的类型调用需要的函数。</p>
<h3 id="3-2-6-虚继承"><a href="#3-2-6-虚继承" class="headerlink" title="3.2.6 虚继承"></a>3.2.6 虚继承</h3><p>虚继承是面向对象编程中为了解决多重继承时的数据成员重复问题而引入的一种技术。<br>当一个指定的基类在继承体系中被多次继承时，虚继承可以确保这个基类的成员数据在派生类中只存在一份实例。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span>  </span><br>  <br><span class="hljs-comment">// 一个共同的基类  </span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">CommonBase</span> &#123;  <br><span class="hljs-keyword">public</span>:  <br>    <span class="hljs-type">int</span> commonData;  <br>    <span class="hljs-built_in">CommonBase</span>() : <span class="hljs-built_in">commonData</span>(<span class="hljs-number">100</span>) &#123;&#125;  <br>&#125;;  <br>  <br><span class="hljs-comment">// 两个基类，都继承自CommonBase  </span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base1</span> : <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">public</span> CommonBase &#123; <span class="hljs-comment">// 虚继承  </span><br><span class="hljs-keyword">public</span>:  <br>    <span class="hljs-type">int</span> base1Data;  <br>    <span class="hljs-built_in">Base1</span>() : <span class="hljs-built_in">base1Data</span>(<span class="hljs-number">1</span>) &#123;&#125;  <br>&#125;;  <br>  <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base2</span> : <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">public</span> CommonBase &#123; <span class="hljs-comment">// 虚继承  </span><br><span class="hljs-keyword">public</span>:  <br>    <span class="hljs-type">int</span> base2Data;  <br>    <span class="hljs-built_in">Base2</span>() : <span class="hljs-built_in">base2Data</span>(<span class="hljs-number">2</span>) &#123;&#125;  <br>&#125;;  <br>  <br><span class="hljs-comment">// 派生类，多重继承自Base1和Base2  </span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Derived</span> : <span class="hljs-keyword">public</span> Base1, <span class="hljs-keyword">public</span> Base2 &#123;  <br><span class="hljs-keyword">public</span>:  <br>    <span class="hljs-type">int</span> derivedData;  <br>    <span class="hljs-built_in">Derived</span>() : <span class="hljs-built_in">derivedData</span>(<span class="hljs-number">3</span>) &#123;&#125;  <br>&#125;;  <br>  <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;  <br>    Derived d;  <br>      <br>    <span class="hljs-comment">// 如果不使用虚继承，CommonBase的数据成员在Derived中会有两份  </span><br>    <span class="hljs-comment">// 使用虚继承后，Derived中CommonBase的数据成员只有一份  </span><br>    d.commonData = <span class="hljs-number">50</span>; <span class="hljs-comment">// 只有一份commonData，不会有二义性  </span><br>  <br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Derived commonData: &quot;</span> &lt;&lt; d.commonData &lt;&lt; std::endl;  <br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Derived base1Data: &quot;</span> &lt;&lt; d.base1Data &lt;&lt; std::endl;  <br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Derived base2Data: &quot;</span> &lt;&lt; d.base2Data &lt;&lt; std::endl;  <br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Derived derivedData: &quot;</span> &lt;&lt; d.derivedData &lt;&lt; std::endl;  <br>  <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;  <br>&#125;<br><br></code></pre></td></tr></table></figure>

<h3 id="子类父类相互赋值"><a href="#子类父类相互赋值" class="headerlink" title="子类父类相互赋值"></a>子类父类相互赋值</h3><p>父类对象不能直接赋值给子类对象，因为子类可能包含父类没有的额外成员。但是，子类对象可以赋值给父类对象,即只保留子类对象中父类的部分。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span>  </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span>  </span><br>  <br><span class="hljs-comment">// 父类（基类）  </span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Animal</span> &#123;  <br><span class="hljs-keyword">public</span>:  <br>    std::string name;  <br>    <span class="hljs-built_in">Animal</span>(<span class="hljs-type">const</span> std::string&amp; n) : <span class="hljs-built_in">name</span>(n) &#123;&#125;  <br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">speak</span><span class="hljs-params">()</span> </span>&#123;  <br>        std::cout &lt;&lt; <span class="hljs-string">&quot;I&#x27;m an animal named &quot;</span> &lt;&lt; name &lt;&lt; std::endl;  <br>    &#125;  <br>&#125;;  <br>  <br><span class="hljs-comment">// 子类（派生类）  </span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Dog</span> : <span class="hljs-keyword">public</span> Animal &#123;  <br><span class="hljs-keyword">public</span>:  <br>    std::string breed;  <br>    <span class="hljs-built_in">Dog</span>(<span class="hljs-type">const</span> std::string&amp; n, <span class="hljs-type">const</span> std::string&amp; b) : <span class="hljs-built_in">Animal</span>(n), <span class="hljs-built_in">breed</span>(b) &#123;&#125;  <br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">speak</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span> </span>&#123;  <br>        std::cout &lt;&lt; <span class="hljs-string">&quot;I&#x27;m a dog named &quot;</span> &lt;&lt; name &lt;&lt; <span class="hljs-string">&quot; of breed &quot;</span> &lt;&lt; breed &lt;&lt; std::endl;  <br>    &#125;  <br>&#125;;  <br>  <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;  <br>    <span class="hljs-comment">// 创建一个Dog对象  </span><br>    <span class="hljs-function">Dog <span class="hljs-title">myDog</span><span class="hljs-params">(<span class="hljs-string">&quot;Rex&quot;</span>, <span class="hljs-string">&quot;Bulldog&quot;</span>)</span></span>;  <br>    myDog.<span class="hljs-built_in">speak</span>();  <span class="hljs-comment">// 输出: I&#x27;m a dog named Rex of breed Bulldog  </span><br>  <br>    <span class="hljs-comment">// 将Dog对象赋值给Animal对象（切片）  </span><br>    Animal myAnimal = myDog;  <span class="hljs-comment">// 切片发生在这里，只有Animal部分被复制  </span><br>    myAnimal.<span class="hljs-built_in">speak</span>();  <span class="hljs-comment">// 输出: I&#x27;m an animal named Rex  </span><br>  <br>    <span class="hljs-comment">// 注意：以下代码是非法的，因为不能将父类对象赋值给子类对象  </span><br>    <span class="hljs-comment">// Dog anotherDog = myAnimal;  // 编译错误！  </span><br>  <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;  <br>&#125;<br></code></pre></td></tr></table></figure>
<p>利用指针进行子类父类赋值      </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++">Animal* animalPtr = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Dog</span>(<span class="hljs-string">&quot;Rex&quot;</span>, <span class="hljs-string">&quot;Bulldog&quot;</span>);  <br>animalPtr-&gt;<span class="hljs-built_in">speak</span>();  <span class="hljs-comment">// 如果speak是虚函数，则会调用Dog类的speak实现</span><br><br></code></pre></td></tr></table></figure>
<p>利用引用进行子类父类赋值<br>与使用指针类似，我们也可以使用引用来实现多态性。引用允许我们直接通过基类引用来访问派生类对象，同时保持多态行为。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">Dog <span class="hljs-title">myDog</span><span class="hljs-params">(<span class="hljs-string">&quot;Rex&quot;</span>, <span class="hljs-string">&quot;Bulldog&quot;</span>)</span></span>;  <br>Animal&amp; animalRef = myDog;  <br>animalRef.<span class="hljs-built_in">speak</span>();  <span class="hljs-comment">// 如果speak是虚函数，则会调用Dog类的speak实现</span><br></code></pre></td></tr></table></figure>

<h2 id="3-3-理解“绑定”"><a href="#3-3-理解“绑定”" class="headerlink" title="3.3 理解“绑定”"></a>3.3 理解“绑定”</h2><p>在C++中，”绑定”通常指的是将函数调用与具体的函数实现关联起来的过程。根据绑定的时机，我们可以将其分为静态绑定（Static Binding）和动态绑定（Dynamic Binding）。</p>
<p><strong>静态绑定（Static Binding）</strong></p>
<p>静态绑定，也称为早期绑定（Early Binding），是指在编译时期就确定函数调用与具体实现的关联。在C++中，非虚函数的调用通常采用静态绑定。编译器在编译时会根据函数名和签名直接解析到具体的函数实现。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span>  </span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;  <br>  <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base</span> &#123;  <br><span class="hljs-keyword">public</span>:  <br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">staticFunc</span><span class="hljs-params">()</span> </span>&#123;  <br>        cout &lt;&lt; <span class="hljs-string">&quot;Base::staticFunc()&quot;</span> &lt;&lt; endl;  <br>    &#125;  <br>&#125;;  <br>  <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Derived</span> : <span class="hljs-keyword">public</span> Base &#123;  <br><span class="hljs-keyword">public</span>:  <br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">staticFunc</span><span class="hljs-params">()</span> </span>&#123;  <br>        cout &lt;&lt; <span class="hljs-string">&quot;Derived::staticFunc()&quot;</span> &lt;&lt; endl;  <br>    &#125;  <br>&#125;;  <br>  <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;  <br>    Base base;  <br>    Derived derived;  <br>  <br>    base.<span class="hljs-built_in">staticFunc</span>();      <span class="hljs-comment">// 输出: Base::staticFunc()  </span><br>    derived.<span class="hljs-built_in">staticFunc</span>();   <span class="hljs-comment">// 输出: Derived::staticFunc()，但这并不是多态，而是隐藏（shadowing）  </span><br>  <br>    Base* basePtr = &amp;derived;  <br>    basePtr-&gt;<span class="hljs-built_in">staticFunc</span>();  <span class="hljs-comment">// 输出: Base::staticFunc()，静态绑定到Base类的函数  </span><br>  <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;  <br>&#125;<br></code></pre></td></tr></table></figure>
<p>staticFunc 是一个非虚函数，因此它的调用在编译时期就已经确定。即使我们通过基类指针指向派生类对象，并尝试调用 staticFunc，也仍然会调用基类版本的函数。</p>
<p><strong>动态绑定</strong></p>
<p>动态绑定，也称为晚期绑定（Late Binding），是指在运行时才确定函数调用与具体实现的关联。在C++中，这通常通过虚函数来实现。当使用基类指针或引用调用虚函数时，实际调用的函数版本会根据指针或引用实际指向的对象类型动态确定。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span>  </span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;  <br>  <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base</span> &#123;  <br><span class="hljs-keyword">public</span>:  <br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">dynamicFunc</span><span class="hljs-params">()</span> </span>&#123;  <br>        cout &lt;&lt; <span class="hljs-string">&quot;Base::dynamicFunc()&quot;</span> &lt;&lt; endl;  <br>    &#125;  <br>&#125;;  <br>  <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Derived</span> : <span class="hljs-keyword">public</span> Base &#123;  <br><span class="hljs-keyword">public</span>:  <br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dynamicFunc</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span> </span>&#123;  <br>        cout &lt;&lt; <span class="hljs-string">&quot;Derived::dynamicFunc()&quot;</span> &lt;&lt; endl;  <br>    &#125;  <br>&#125;;  <br>  <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;  <br>    Base base;  <br>    Derived derived;  <br>    Base* basePtr;  <br>  <br>    base.<span class="hljs-built_in">dynamicFunc</span>();      <span class="hljs-comment">// 输出: Base::dynamicFunc()  </span><br>    derived.<span class="hljs-built_in">dynamicFunc</span>();   <span class="hljs-comment">// 输出: Derived::dynamicFunc()  </span><br>  <br>    basePtr = &amp;base;  <br>    basePtr-&gt;<span class="hljs-built_in">dynamicFunc</span>();  <span class="hljs-comment">// 输出: Base::dynamicFunc()  </span><br>  <br>    basePtr = &amp;derived;  <br>    basePtr-&gt;<span class="hljs-built_in">dynamicFunc</span>();  <span class="hljs-comment">// 输出: Derived::dynamicFunc()，动态绑定到派生类的函数  </span><br>  <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;  <br>&#125;<br></code></pre></td></tr></table></figure>

<p>dynamicFunc 是一个虚函数。当我们通过基类指针调用它时，实际调用的函数版本会根据指针指向的对象类型动态确定。这就是动态绑定的特点，它允许在运行时实现多态行为。</p>
<p>总结：</p>
<p>静态绑定在编译时期确定函数调用，而动态绑定在运行时确定。<br>静态绑定通常与非虚函数相关，而动态绑定则与虚函数相关。<br>动态绑定是实现多态性的关键机制之一。        </p>
<h1 id="4-c-模版"><a href="#4-c-模版" class="headerlink" title="4.c++模版"></a>4.c++模版</h1><h2 id="4-1函数模版"><a href="#4-1函数模版" class="headerlink" title="4.1函数模版"></a>4.1函数模版</h2><h3 id="函数模版定义与调用"><a href="#函数模版定义与调用" class="headerlink" title="函数模版定义与调用"></a>函数模版定义与调用</h3><p>定义一个函数模板之后，没有指定类型，编译器会实现参数类型的自动推导。考虑单一类型T的场景</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;   <span class="hljs-comment">//开始泛型编程，由于历史原因，typename也可以写成class</span><br><span class="hljs-function">T <span class="hljs-title">Max</span><span class="hljs-params">(<span class="hljs-type">const</span> T&amp; a,<span class="hljs-type">const</span> T&amp; b)</span> </span>&#123;<br>	<span class="hljs-keyword">return</span> a &gt; b ? a : b;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><br>	<span class="hljs-type">int</span>  n = <span class="hljs-number">1</span>;<br>	<span class="hljs-type">int</span>	 m = <span class="hljs-number">2</span>;<br>	cout &lt;&lt; <span class="hljs-string">&quot;max(1, 2) = &quot;</span> &lt;&lt; <span class="hljs-built_in">Max</span>(n, m) &lt;&lt; endl;<br><br>	<span class="hljs-type">float</span> a = <span class="hljs-number">2.0</span>;<br>	<span class="hljs-type">float</span> b = <span class="hljs-number">3.0</span>;<br>	cout &lt;&lt; <span class="hljs-string">&quot;max(2.0, 3.0) = &quot;</span> &lt;&lt; <span class="hljs-built_in">Max</span>(a, b) &lt;&lt; endl;<br><br>	<span class="hljs-type">char</span> i = <span class="hljs-string">&#x27;a&#x27;</span>;<br>	<span class="hljs-type">char</span> j = <span class="hljs-string">&#x27;b&#x27;</span>;<br>	cout &lt;&lt; <span class="hljs-string">&quot;max(&#x27;a&#x27;, &#x27;b&#x27;) = &quot;</span> &lt;&lt; <span class="hljs-built_in">Max</span>(i, j) &lt;&lt; endl;<br>	<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>也可引入多个类型<br><code>template &lt;typename T, typename T2&gt; </code><br>注意T，T2必须在下文函数中使用，否则编译器会报错。尽管在下面的函数中，T,T2是允许被推导为同一个类型的。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">Max</span>&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt;(a, b); <span class="hljs-comment">//显式类型调用</span><br><span class="hljs-built_in">Max</span>(a, b); <span class="hljs-comment">//自动数据类型推导</span><br></code></pre></td></tr></table></figure>

<h3 id="函数模版与普通函数并存"><a href="#函数模版与普通函数并存" class="headerlink" title="函数模版与普通函数并存"></a>函数模版与普通函数并存</h3><p>当函数模版和普通函数并存的时候：<br>如果函数模板会产生更好的匹配，使用函数模板；<br>其他情况调用普通函数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Test</span><span class="hljs-params">(T&amp; a, T&amp; b)</span> </span>&#123;<br>	T c;<br>	c = a;<br>	a = b;<br>	b = c;<br><br>	cout &lt;&lt; <span class="hljs-string">&quot;Test 函数模板被调用了..&quot;</span> &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Test</span><span class="hljs-params">(<span class="hljs-type">int</span>&amp; a, <span class="hljs-type">int</span>&amp; b)</span> </span>&#123;<br>	<span class="hljs-type">int</span> c;<br>	c = a;<br>	a = b;<br>	b = c;<br><br>	cout &lt;&lt; <span class="hljs-string">&quot;Test 普通函数被调用..&quot;</span> &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>对于这个函数模版      </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> </span>&#123;<br>	<span class="hljs-type">int</span> n = <span class="hljs-number">99</span>;<br>	<span class="hljs-type">int</span> m = <span class="hljs-number">65</span>;<br><br>	<span class="hljs-built_in">Test</span>(n, m);<br>	<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;   <span class="hljs-comment">//调用普通函数</span><br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> </span>&#123;<br>	<span class="hljs-type">int</span> n = <span class="hljs-number">99</span>;<br>	<span class="hljs-type">int</span> m = <span class="hljs-number">65</span>;<br><br>	Test&lt;&gt;(n, m);<br>	<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;   <span class="hljs-comment">//调用函数模版</span><br>&#125;<br></code></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> </span>&#123;<br>	<span class="hljs-type">double</span> n = <span class="hljs-number">99.1</span>;<br>	<span class="hljs-type">double</span> m = <span class="hljs-number">65.1</span>;<br><br>	<span class="hljs-built_in">Test</span>(n, m);<br>	<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    <span class="hljs-comment">//调用函数模版</span><br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> n=<span class="hljs-number">1</span>;<br><span class="hljs-type">char</span> m=<span class="hljs-string">&#x27;c&#x27;</span>;<br><span class="hljs-comment">//报错</span><br></code></pre></td></tr></table></figure>

<p>函数模版必须严格匹配，函数模板不允许自动类型转化！</p>
<h3 id="嵌套使用"><a href="#嵌套使用" class="headerlink" title="嵌套使用"></a>嵌套使用</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span><br><span class="hljs-function">T <span class="hljs-title">Max</span><span class="hljs-params">(T a, T b)</span></span><br><span class="hljs-function"></span>&#123;<br>	cout &lt;&lt; <span class="hljs-string">&quot;调用 T Max(T a, T b)&quot;</span> &lt;&lt; endl;<br>	<span class="hljs-keyword">return</span> a &gt; b ? a : b;<br>&#125;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-function">T <span class="hljs-title">Max</span><span class="hljs-params">(T a, T b, T c)</span> </span>&#123;<br>	cout &lt;&lt; <span class="hljs-string">&quot;调用 T Max(T a, T b, T c)&quot;</span> &lt;&lt; endl;<br>	<span class="hljs-keyword">return</span> <span class="hljs-built_in">Max</span>(<span class="hljs-built_in">Max</span>(a, b), c);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> </span>&#123;<br>	<span class="hljs-type">int</span> a = <span class="hljs-number">1</span>;<br>	<span class="hljs-type">int</span> b = <span class="hljs-number">2</span>;<br>	<span class="hljs-type">int</span> c = <span class="hljs-number">3</span>;<br><br>	<span class="hljs-built_in">Max</span>(a, b, c);<br><br>	<span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>注意每一个函数模版都需要写自己的 template,如果你试图只写一个 template 声明，然后定义两个函数体，那么编译器将无法识别你的意图，并且会报错。每个模板函数都需要它自己的 template 声明。</p>
<h2 id="4-2类模版"><a href="#4-2类模版" class="headerlink" title="4.2类模版"></a>4.2类模版</h2><h3 id="模版类的定义"><a href="#模版类的定义" class="headerlink" title="模版类的定义"></a>模版类的定义</h3><p>模板类（也称为类模板）提供了一种泛型编程的机制，它允许用户为类定义一个蓝图，这个蓝图可以适应不同的数据类型或参数。<br>模版类的含义就是提供一组可以泛型编程的变量给下面定义的类使用        </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;  <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Array</span> &#123;  <br><span class="hljs-keyword">private</span>:  <br>    T* data;  <br>    <span class="hljs-type">int</span> size;  <br><span class="hljs-keyword">public</span>:  <br>    <span class="hljs-built_in">Array</span>(<span class="hljs-type">int</span> s) : <span class="hljs-built_in">size</span>(s) &#123;  <br>        data = <span class="hljs-keyword">new</span> T[size];  <br>    &#125;  <br>      <br>    ~<span class="hljs-built_in">Array</span>() &#123;  <br>        <span class="hljs-keyword">delete</span>[] data;  <br>    &#125;  <br>  <br>    T&amp; <span class="hljs-keyword">operator</span>[](<span class="hljs-type">int</span> index) &#123;  <br>        <span class="hljs-keyword">return</span> data[index];  <br>    &#125;  <br>  <br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getSize</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;  <br>        <span class="hljs-keyword">return</span> size;  <br>    &#125;  <br>&#125;;<br></code></pre></td></tr></table></figure>
<p>使用模版类的时候，需要提供具体的数据&#x2F;数据类型实例化这个类</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">Array&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">intArray</span><span class="hljs-params">(<span class="hljs-number">10</span>)</span></span>;    <span class="hljs-comment">// 创建一个存储整数的数组  </span><br><span class="hljs-function">Array&lt;<span class="hljs-type">double</span>&gt; <span class="hljs-title">doubleArray</span><span class="hljs-params">(<span class="hljs-number">5</span>)</span></span>; <span class="hljs-comment">// 创建一个存储双精度浮点数的数组</span><br><br></code></pre></td></tr></table></figure>

<p>含有常量的实例化</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span>  </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cassert&gt;</span>  </span><br>  <br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-type">int</span> N&gt;  <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">FixedArray</span> &#123;  <br><span class="hljs-keyword">private</span>:  <br>    T data[N];  <br>  <br><span class="hljs-keyword">public</span>:  <br>    <span class="hljs-comment">// 默认构造函数  </span><br>    <span class="hljs-built_in">FixedArray</span>() &#123;&#125;  <br>  <br>    <span class="hljs-comment">// 获取数组大小  </span><br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title">size</span><span class="hljs-params">()</span> </span>&#123;  <br>        <span class="hljs-keyword">return</span> N;  <br>    &#125;  <br>  <br>    <span class="hljs-comment">// 索引操作符重载  </span><br>    T&amp; <span class="hljs-keyword">operator</span>[](<span class="hljs-type">int</span> index) &#123;  <br>        <span class="hljs-built_in">assert</span>(index &gt;= <span class="hljs-number">0</span> &amp;&amp; index &lt; N);  <br>        <span class="hljs-keyword">return</span> data[index];  <br>    &#125;  <br>  <br>    <span class="hljs-comment">// 常量索引操作符重载  </span><br>    <span class="hljs-type">const</span> T&amp; <span class="hljs-keyword">operator</span>[](<span class="hljs-type">int</span> index) <span class="hljs-type">const</span> &#123;  <br>        <span class="hljs-built_in">assert</span>(index &gt;= <span class="hljs-number">0</span> &amp;&amp; index &lt; N);  <br>        <span class="hljs-keyword">return</span> data[index];  <br>    &#125;  <br>&#125;;  <br>  <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;  <br>    <span class="hljs-comment">// 创建一个包含5个整数的FixedArray  </span><br>    FixedArray&lt;<span class="hljs-type">int</span>, <span class="hljs-number">5</span>&gt; intArray;  <br>  <br>    <span class="hljs-comment">// 赋值和访问数组元素  </span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; intArray.<span class="hljs-built_in">size</span>(); ++i) &#123;  <br>        intArray[i] = i * <span class="hljs-number">2</span>;  <br>        std::cout &lt;&lt; intArray[i] &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span>;  <br>    &#125;  <br>    std::cout &lt;&lt; std::endl;  <br>  <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;  <br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="模版类的偏特化与全特化"><a href="#模版类的偏特化与全特化" class="headerlink" title="模版类的偏特化与全特化"></a>模版类的偏特化与全特化</h3><p>所谓特化。就是说我们有时候并不想泛化所有模版，我们希望有些类型的模版实现特殊的泛化，为此：      </p>
<p><strong>全特化（Full Specialization）</strong>     </p>
<p>全特化是指针对模板类的所有模板参数都提供具体的类型。下面是一个模板类及其全特化的示例：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 通用模板类  </span><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;  <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> &#123;  <br><span class="hljs-keyword">public</span>:  <br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">()</span> </span>&#123;  <br>        std::cout &lt;&lt; <span class="hljs-string">&quot;General template for type: &quot;</span> &lt;&lt; <span class="hljs-built_in">typeid</span>(T).<span class="hljs-built_in">name</span>() &lt;&lt; std::endl;  <br>    &#125;  <br>&#125;;  <br>  <br><span class="hljs-comment">// 针对int类型的全特化  </span><br><span class="hljs-keyword">template</span>&lt;&gt;    <span class="hljs-comment">//依然需要写一个空的模版参数列表</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span>&lt;<span class="hljs-type">int</span>&gt; &#123;  <br><span class="hljs-keyword">public</span>:  <br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">()</span> </span>&#123;  <br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Specialized template for int&quot;</span> &lt;&lt; std::endl;  <br>    &#125;  <br>&#125;;  <br>  <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;  <br>    MyClass&lt;<span class="hljs-type">double</span>&gt; obj1;  <br>    obj<span class="hljs-number">1.</span><span class="hljs-built_in">print</span>(); <span class="hljs-comment">// 输出: General template for type: d  </span><br>  <br>    MyClass&lt;<span class="hljs-type">int</span>&gt; obj2;  <br>    obj<span class="hljs-number">2.</span><span class="hljs-built_in">print</span>(); <span class="hljs-comment">// 输出: Specialized template for int  </span><br>  <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;  <br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>偏特化（Partial Specialization）</strong><br>偏特化是指只针对模板类的部分模板参数提供具体的类型。这通常用于模板类有多个类型参数的情况。下面是一个模板类及其偏特化的示例：  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 通用模板类，有两个类型参数  </span><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T1, <span class="hljs-keyword">typename</span> T2&gt;  <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyPair</span> &#123;  <br><span class="hljs-keyword">public</span>:  <br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">()</span> </span>&#123;  <br>        std::cout &lt;&lt; <span class="hljs-string">&quot;General template for types: &quot;</span> &lt;&lt; <span class="hljs-built_in">typeid</span>(T1).<span class="hljs-built_in">name</span>() &lt;&lt; <span class="hljs-string">&quot; and &quot;</span> &lt;&lt; <span class="hljs-built_in">typeid</span>(T2).<span class="hljs-built_in">name</span>() &lt;&lt; std::endl;  <br>    &#125;  <br>&#125;;    <br><span class="hljs-comment">// 针对T2为int类型的偏特化  </span><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T1&gt;  <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyPair</span>&lt;T1, <span class="hljs-type">int</span>&gt; &#123;  <br><span class="hljs-keyword">public</span>:  <br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">()</span> </span>&#123;  <br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Partially specialized template for int as the second type&quot;</span> &lt;&lt; std::endl;  <br>    &#125;  <br>&#125;;    <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;  <br>    MyPair&lt;<span class="hljs-type">double</span>, std::string&gt; obj1;  <br>    obj<span class="hljs-number">1.</span><span class="hljs-built_in">print</span>(); <span class="hljs-comment">// 输出: General template for types: d and NSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE  </span><br>  <br>    MyPair&lt;std::string, <span class="hljs-type">int</span>&gt; obj2;  <br>    obj<span class="hljs-number">2.</span><span class="hljs-built_in">print</span>(); <span class="hljs-comment">// 输出: Partially specialized template for int as the second type  </span><br>  <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;  <br>&#125;<br></code></pre></td></tr></table></figure>

<h1 id="5-异常处理"><a href="#5-异常处理" class="headerlink" title="5.异常处理"></a>5.异常处理</h1><p>给出一段三角形相关的异常处理</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cmath&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">triangle</span><span class="hljs-params">(<span class="hljs-type">double</span> a,<span class="hljs-type">double</span> b,<span class="hljs-type">double</span> c)</span><span class="hljs-comment">//计算三角形面积的函数</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-keyword">if</span>(a+b&lt;=c||a+c&lt;=b||b+c&lt;=a)  <span class="hljs-comment">//无法构成三角形则丢出异常</span><br>	&#123;<br>		string s=<span class="hljs-string">&quot;that is not a triangle!&quot;</span>;<br>		<span class="hljs-keyword">throw</span> s;<br>	&#125;<br>    <span class="hljs-type">double</span> s=(a+b+c)/<span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">sqrt</span>(s*(s-a)*(s-b)*(s-c));<br><br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>       <span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">triangle</span><span class="hljs-params">(<span class="hljs-type">double</span>,<span class="hljs-type">double</span>,<span class="hljs-type">double</span>)</span></span>;<br>       <span class="hljs-type">double</span> a,b,c;<br>       cin&gt;&gt;a&gt;&gt;b&gt;&gt;c;<br>              <span class="hljs-keyword">if</span>(a&gt;<span class="hljs-number">0</span>&amp;&amp;b&gt;<span class="hljs-number">0</span>&amp;&amp;c&gt;<span class="hljs-number">0</span>)<br>              &#123;<br>                     <span class="hljs-keyword">try</span>&#123;     <br>                     	cout&lt;&lt;<span class="hljs-built_in">triangle</span>(a,b,c)&lt;&lt;endl;<br>					 &#125;<br>					 <span class="hljs-built_in">catch</span>(string&amp; s)&#123;<br>					 	cout&lt;&lt;<span class="hljs-string">&quot;a=&quot;</span>&lt;&lt;a&lt;&lt;<span class="hljs-string">&quot;,b=&quot;</span>&lt;&lt;b&lt;&lt;<span class="hljs-string">&quot;,c=&quot;</span>&lt;&lt;c&lt;&lt;<span class="hljs-string">&quot;,&quot;</span>&lt;&lt;s;<br>					 &#125;<br>					 <br>                     cin&gt;&gt;a&gt;&gt;b&gt;&gt;c;<br>              &#125;<br>       &#125;<br></code></pre></td></tr></table></figure>

<p>实现的核心就在于前面throw出异常，后面try并且catch的过程。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">try</span>&#123;<br>  <span class="hljs-comment">// 可能抛出异常的代码块</span><br>&#125; <span class="hljs-built_in">catch</span>(...) &#123;<br>  <span class="hljs-comment">// 处理异常1</span><br>&#125; <span class="hljs-built_in">catch</span>(···)&#123;<br>  <span class="hljs-comment">// 处理异常2</span><br>&#125;finally &#123;<br>  <span class="hljs-comment">// 无论有无异常都执行</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>需要注意的是，这个写法是简化的，并不标准（可以正常运行），规范的代码throw后面有给定的异常类。<br>给出一个除以0的例子    </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span>  </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdexcept&gt;</span> <span class="hljs-comment">// 包含标准异常库  </span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;  <br>  <br><span class="hljs-comment">/**  </span><br><span class="hljs-comment"> * 定义函数division  </span><br><span class="hljs-comment"> * 参数整型dividend、整型divisor  </span><br><span class="hljs-comment"> */</span>  <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">division</span><span class="hljs-params">(<span class="hljs-type">int</span> dividend, <span class="hljs-type">int</span> divisor)</span>  </span><br><span class="hljs-function"></span>&#123;  <br>    <span class="hljs-keyword">if</span> (divisor == <span class="hljs-number">0</span>)  <br>    &#123;  <br>        <span class="hljs-comment">// 抛出异常，因为除数为0  </span><br>        <span class="hljs-keyword">throw</span> <span class="hljs-built_in">invalid_argument</span>(<span class="hljs-string">&quot;除数不能为0&quot;</span>);  <br>    &#125;  <br>    <span class="hljs-keyword">else</span>  <br>    &#123;  <br>        <span class="hljs-keyword">return</span> dividend / divisor;  <br>    &#125;  <br>&#125;  <br>  <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>  </span><br><span class="hljs-function"></span>&#123;  <br>    <span class="hljs-type">int</span> d1 = <span class="hljs-number">0</span>, d2 = <span class="hljs-number">0</span>, r = <span class="hljs-number">0</span>;  <br>    cin &gt;&gt; d1;  <br>    cin &gt;&gt; d2;  <br>  <br>    <span class="hljs-comment">// 使用try...catch...捕获异常  </span><br>    <span class="hljs-keyword">try</span>  <br>    &#123;  <br>        r = <span class="hljs-built_in">division</span>(d1, d2);  <br>        cout &lt;&lt; <span class="hljs-string">&quot;结果是: &quot;</span> &lt;&lt; r &lt;&lt; endl;  <br>    &#125;  <br>    <span class="hljs-built_in">catch</span> (<span class="hljs-type">const</span> invalid_argument&amp; e)  <br>    &#123;  <br>        <span class="hljs-comment">// 显示异常信息  </span><br>        cout &lt;&lt; <span class="hljs-string">&quot;捕获到异常: &quot;</span> &lt;&lt; e.<span class="hljs-built_in">what</span>() &lt;&lt; endl;  <br>    &#125;  <br>  <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;  <br>&#125;<br><br><br></code></pre></td></tr></table></figure>
<p>以下是一些C++标准库中常见的异常类：     </p>
<p>std::logic_error：这是所有逻辑错误的基类。逻辑错误通常指的是程序员的错误，例如无效的参数。      </p>
<p><strong>std::logic_error的直接派生类包括：</strong><br>std::invalid_argument：表示函数接收到了无效的参数。<br>std::domain_error：表示参数的值域不正确，即参数的值不在预期的范围内。<br>std::length_error：试图创建一个超过其最大尺寸的容器时抛出。<br>std::out_of_range：试图访问容器的一个不存在的元素时抛出。  </p>
<p>std::runtime_error：这是所有运行时错误的基类。运行时错误指的是那些在运行时才能检测到的错误，如资源不足。     </p>
<p><strong>std::runtime_error的直接派生类包括：</strong><br>std::range_error：表示一个值不在其预期的范围之内时抛出。<br>std::overflow_error：表示算术运算的结果太大，无法用给定的类型表示时抛出。<br>std::underflow_error：表示算术运算的结果太小，无法用给定的类型表示时抛出。<br>std::bad_alloc：当内存分配失败时，如使用new关键字时内存不足，会抛出此异常。<br>std::bad_cast：当进行不安全的类型转换，如dynamic_cast到一个不合适的类型时，会抛出此异常。<br>std::bad_typeid：当typeid操作符被用于一个空指针时，会抛出此异常。<br>std::ios_base::failure：输入输出流错误时会抛出此异常，它是std::exception的派生类，但通常与IO操作关联。<br>除了上述的标准异常外，C++还允许程序员定义自己的异常类。当你需要表示特定的错误条件时，可以创建从std::exception派生的新类。                       </p>
<h1 id="6-c-文件操作"><a href="#6-c-文件操作" class="headerlink" title="6.c++文件操作"></a>6.c++文件操作</h1><h2 id="写入文件"><a href="#写入文件" class="headerlink" title="写入文件"></a>写入文件</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fstream&gt;</span>  </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span>  </span><br>  <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;  <br>    <span class="hljs-comment">// 创建一个ofstream对象，以写入模式打开文件  </span><br>    <span class="hljs-function">std::ofstream <span class="hljs-title">outfile</span><span class="hljs-params">(<span class="hljs-string">&quot;example.txt&quot;</span>)</span></span>;  <br>  <br>    <span class="hljs-comment">// 检查文件是否成功打开  </span><br>    <span class="hljs-keyword">if</span> (!outfile.<span class="hljs-built_in">is_open</span>()) &#123;  <br>        std::cerr &lt;&lt; <span class="hljs-string">&quot;无法打开文件&quot;</span> &lt;&lt; std::endl;  <br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;  <br>    &#125;  <br>  <br>    <span class="hljs-comment">// 向文件中写入内容  </span><br>    outfile &lt;&lt; <span class="hljs-string">&quot;Hello, World!&quot;</span> &lt;&lt; std::endl;  <br>    outfile &lt;&lt; <span class="hljs-string">&quot;这是一个文件写入示例。&quot;</span> &lt;&lt; std::endl;  <br>  <br>    <span class="hljs-comment">// 关闭文件  </span><br>    outfile.<span class="hljs-built_in">close</span>();  <br>  <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;  <br>&#125;<br><br></code></pre></td></tr></table></figure>

<h2 id="读取文件"><a href="#读取文件" class="headerlink" title="读取文件"></a>读取文件</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fstream&gt;</span>  </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span>  </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span>  </span><br>  <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;  <br>    <span class="hljs-comment">// 创建一个ifstream对象，以读取模式打开文件  </span><br>    <span class="hljs-function">std::ifstream <span class="hljs-title">infile</span><span class="hljs-params">(<span class="hljs-string">&quot;example.txt&quot;</span>)</span></span>;  <br>  <br>    <span class="hljs-comment">// 检查文件是否成功打开  </span><br>    <span class="hljs-keyword">if</span> (!infile.<span class="hljs-built_in">is_open</span>()) &#123;  <br>        std::cerr &lt;&lt; <span class="hljs-string">&quot;无法打开文件&quot;</span> &lt;&lt; std::endl;  <br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;  <br>    &#125;  <br>  <br>    <span class="hljs-comment">// 从文件中读取内容  </span><br>    std::string line;  <br>    <span class="hljs-keyword">while</span> (std::<span class="hljs-built_in">getline</span>(infile, line)) &#123;  <br>        std::cout &lt;&lt; line &lt;&lt; std::endl;  <br>    &#125;  <br>  <br>    <span class="hljs-comment">// 关闭文件  </span><br>    infile.<span class="hljs-built_in">close</span>();  <br>  <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;  <br>&#125;<br></code></pre></td></tr></table></figure>
                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/" class="category-chain-item">编程语言</a>
  
  
    <span>></span>
    
  <a href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/c/" class="category-chain-item">c++</a>
  
  

  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/c/" class="print-no-link">#c++</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>c++课堂笔记</div>
      <div>http://example.com/2025/03/21/编程语言/c++笔记/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>bradin</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2025年3月21日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2025/03/21/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/numpy%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0/" title="numpy框架探究">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">numpy框架探究</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2025/03/21/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/pytorch/" title="pytorch">
                        <span class="hidden-mobile">pytorch</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
    <div class="statistics">
  
  

  
    
      <span id="busuanzi_container_site_pv" style="display: none">
        总访问量 
        <span id="busuanzi_value_site_pv"></span>
         次
      </span>
    
    
      <span id="busuanzi_container_site_uv" style="display: none">
        总访客数 
        <span id="busuanzi_value_site_uv"></span>
         人
      </span>
    
    
  
</div>

  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>

  <script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
