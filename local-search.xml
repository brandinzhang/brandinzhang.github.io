<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>git协作开发指南</title>
    <link href="/2025/03/22/cs/git%E7%AC%94%E8%AE%B0/"/>
    <url>/2025/03/22/cs/git%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="创建并关联仓库"><a href="#创建并关联仓库" class="headerlink" title="创建并关联仓库"></a>创建并关联仓库</h1><p>以下是在 macOS 上配置 Git 并创建、关联 GitHub 仓库的详细教程，同时默认分支名为 <code>main</code>：</p><h3 id="1-安装-Git"><a href="#1-安装-Git" class="headerlink" title="1. 安装 Git"></a>1. 安装 Git</h3><p>如果你的 macOS 还未安装 Git，可通过 Homebrew 进行安装。若已安装，可跳过此步骤。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 安装 Homebrew</span><br>/bin/bash -c <span class="hljs-string">&quot;<span class="hljs-subst">$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)</span>&quot;</span><br><br><span class="hljs-comment"># 使用 Homebrew 安装 Git</span><br>brew install git<br></code></pre></td></tr></table></figure><p><strong>意义</strong>：Git 是版本控制系统，借助它你能对项目进行版本管理。Homebrew 是 macOS 上常用的包管理器，方便软件的安装与管理。</p><h3 id="2-配置-Git-用户名和邮箱"><a href="#2-配置-Git-用户名和邮箱" class="headerlink" title="2. 配置 Git 用户名和邮箱"></a>2. 配置 Git 用户名和邮箱</h3><p>你需要设置自己的 Git 用户名和邮箱，这些信息会关联到你提交的代码。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">git config --global user.name <span class="hljs-string">&quot;Your Name&quot;</span><br>git config --global user.email <span class="hljs-string">&quot;your.email@example.com&quot;</span><br></code></pre></td></tr></table></figure><p><strong>意义</strong>：Git 利用用户名和邮箱来识别代码提交者，这些信息会记录在每次提交的日志中。</p><h3 id="3-生成-SSH-密钥"><a href="#3-生成-SSH-密钥" class="headerlink" title="3. 生成 SSH 密钥"></a>3. 生成 SSH 密钥</h3><p>为了能安全地与 GitHub 进行通信，你需要生成 SSH 密钥并将公钥添加到 GitHub 账户。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 生成 SSH 密钥</span><br>ssh-keygen -t rsa -b 4096 -C <span class="hljs-string">&quot;your.email@example.com&quot;</span><br><br><span class="hljs-comment"># 按提示操作，通常直接按回车键接受默认设置即可</span><br><span class="hljs-comment"># 生成的密钥默认存储在 ~/.ssh/id_rsa 和 ~/.ssh/id_rsa.pub</span><br><br><span class="hljs-comment"># 启动 SSH 代理</span><br><span class="hljs-built_in">eval</span> <span class="hljs-string">&quot;<span class="hljs-subst">$(ssh-agent -s)</span>&quot;</span><br><br><span class="hljs-comment"># 将私钥添加到 SSH 代理</span><br>ssh-add ~/.ssh/id_rsa<br></code></pre></td></tr></table></figure><p><strong>意义</strong>：SSH 密钥提供了一种安全的方式让你与 GitHub 服务器进行通信，避免每次操作都输入用户名和密码。</p><h3 id="4-将-SSH-公钥添加到-GitHub-账户"><a href="#4-将-SSH-公钥添加到-GitHub-账户" class="headerlink" title="4. 将 SSH 公钥添加到 GitHub 账户"></a>4. 将 SSH 公钥添加到 GitHub 账户</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 复制公钥到剪贴板</span><br>pbcopy &lt; ~/.ssh/id_rsa.pub<br></code></pre></td></tr></table></figure><ul><li>打开 GitHub 网站，登录你的账户。</li><li>点击右上角的头像，选择 “Settings”。</li><li>在左侧菜单中选择 “SSH and GPG keys”。</li><li>点击 “New SSH key”，将剪贴板中的公钥粘贴到 “Key” 字段，输入一个标题（如 “MacBook Pro”），然后点击 “Add SSH key”。<br><strong>意义</strong>：GitHub 服务器借助公钥来验证你的身份，确认是你本人在操作。</li></ul><h3 id="5-创建本地-Git-仓库"><a href="#5-创建本地-Git-仓库" class="headerlink" title="5. 创建本地 Git 仓库"></a>5. 创建本地 Git 仓库</h3><p>在本地创建一个新的项目目录，并将其初始化为 Git 仓库。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 创建一个新的项目目录</span><br><span class="hljs-built_in">mkdir</span> my-project<br><span class="hljs-built_in">cd</span> my-project<br><br><span class="hljs-comment"># 初始化 Git 仓库，默认分支名为 main</span><br>git init -b main<br></code></pre></td></tr></table></figure><p><strong>意义</strong>：<code>git init</code> 命令会在当前目录下创建一个新的 Git 仓库，<code>-b main</code> 参数指定默认分支名为 <code>main</code>。</p><h3 id="6-添加文件并提交"><a href="#6-添加文件并提交" class="headerlink" title="6. 添加文件并提交"></a>6. 添加文件并提交</h3><p>在项目目录下创建一些文件，然后将它们添加到暂存区并提交。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 创建一个示例文件</span><br><span class="hljs-built_in">touch</span> README.md<br><br><span class="hljs-comment"># 将文件添加到暂存区</span><br>git add README.md<br><br><span class="hljs-comment"># 提交文件到本地仓库</span><br>git commit -m <span class="hljs-string">&quot;Initial commit&quot;</span><br></code></pre></td></tr></table></figure><p><strong>意义</strong>：<code>git add</code> 命令把文件添加到暂存区，<code>git commit</code> 命令将暂存区的文件提交到本地仓库，并添加一条提交信息。</p><h3 id="7-在-GitHub-上创建新仓库"><a href="#7-在-GitHub-上创建新仓库" class="headerlink" title="7. 在 GitHub 上创建新仓库"></a>7. 在 GitHub 上创建新仓库</h3><ul><li>登录 GitHub 网站，点击右上角的 “+” 按钮，选择 “New repository”。</li><li>输入仓库名称、描述等信息，然后点击 “Create repository”。</li></ul><h3 id="8-将本地仓库关联到-GitHub-仓库"><a href="#8-将本地仓库关联到-GitHub-仓库" class="headerlink" title="8. 将本地仓库关联到 GitHub 仓库"></a>8. 将本地仓库关联到 GitHub 仓库</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 获取 GitHub 仓库的 SSH 地址</span><br><span class="hljs-comment"># 在 GitHub 仓库页面中，点击 “Code” 按钮，复制 SSH 地址</span><br><br><span class="hljs-comment"># 将本地仓库与 GitHub 仓库关联</span><br>git remote add origin git@github.com:yourusername/my-project.git<br><br><span class="hljs-comment"># 将本地的 main 分支推送到 GitHub 仓库</span><br>git push -u origin main<br></code></pre></td></tr></table></figure><p><strong>意义</strong>：<code>git remote add</code> 命令将本地仓库与 GitHub 仓库关联起来，<code>git push</code> 命令把本地仓库的代码推送到 GitHub 仓库，<code>-u</code> 参数会将本地的 <code>main</code> 分支与远程的 <code>main</code> 分支关联起来，以后使用 <code>git push</code> 时就不需要再指定分支名了。</p><p>完成以上步骤后，你就成功在 macOS 上配置了 Git，并将本地仓库与 GitHub 仓库关联起来。之后你可以继续在本地进行开发，使用 <code>git add</code>、<code>git commit</code> 和 <code>git push</code> 命令来管理和同步代码。 </p><p>最后可能会出错，因为原始仓库里会有一个readme文件，需要</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 拉取远程仓库的更新并合并</span><br>git pull --rebase origin main<br><br><span class="hljs-comment"># 如果拉取和合并过程中没有冲突，再次推送本地分支</span><br>git push -u origin main<br></code></pre></td></tr></table></figure><h1 id="创建自己的分支，上传"><a href="#创建自己的分支，上传" class="headerlink" title="创建自己的分支，上传"></a>创建自己的分支，上传</h1><p>下面为你详细介绍创建新分支、在新分支开发、推送新分支以及将分支合并到 <code>main</code> 分支的具体步骤，同时说明合并操作的相关情况。</p><h3 id="1-创建新分支"><a href="#1-创建新分支" class="headerlink" title="1. 创建新分支"></a>1. 创建新分支</h3><p>在本地仓库中创建新分支有两种常用方式，具体如下：</p><h4 id="先创建分支，再切换到新分支"><a href="#先创建分支，再切换到新分支" class="headerlink" title="先创建分支，再切换到新分支"></a>先创建分支，再切换到新分支</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 创建新分支</span><br>git branch new-feature<br><span class="hljs-comment"># 切换到新分支</span><br>git checkout new-feature<br></code></pre></td></tr></table></figure><p>这里的 <code>new-feature</code> 是新分支的名称，可以根据实际开发的功能来命名。</p><h3 id="2-在新分支上进行开发创作"><a href="#2-在新分支上进行开发创作" class="headerlink" title="2. 在新分支上进行开发创作"></a>2. 在新分支上进行开发创作</h3><p>切换到新分支后，就可以像平常一样进行代码编写、修改等操作了。完成一些工作后，将修改的文件添加到暂存区并提交到本地仓库，示例如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 查看文件状态，确认修改的文件</span><br>git status<br><span class="hljs-comment"># 将修改的文件添加到暂存区</span><br>git add .  <span class="hljs-comment"># 添加当前目录下所有修改和新增的文件</span><br><span class="hljs-comment"># 或者添加指定文件</span><br>git add file1.txt file2.py<br><span class="hljs-comment"># 提交暂存区的文件到本地仓库，并添加提交信息</span><br>git commit -m <span class="hljs-string">&quot;完成新功能的部分开发&quot;</span><br></code></pre></td></tr></table></figure><h3 id="3-推送新分支到远程仓库"><a href="#3-推送新分支到远程仓库" class="headerlink" title="3. 推送新分支到远程仓库"></a>3. 推送新分支到远程仓库</h3><p>当你在本地新分支上完成一定的开发工作后，需要将新分支推送到远程仓库，以便团队成员可以查看和协作。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 第一次推送新分支，同时建立本地分支和远程分支的关联</span><br>git push -u origin new-feature<br><span class="hljs-comment"># 后续推送该分支的更新，只需执行</span><br>git push<br></code></pre></td></tr></table></figure><p><code>origin</code> 是远程仓库的默认别名，<code>new-feature</code> 是你要推送的本地分支名称。执行 <code>git push -u origin new-feature</code> 后，本地的 <code>new-feature</code> 分支就会和远程仓库的 <code>new-feature</code> 分支建立关联，之后再推送该分支的更新时，直接使用 <code>git push</code> 即可。</p><h3 id="4-合并分支到-main-分支"><a href="#4-合并分支到-main-分支" class="headerlink" title="4. 合并分支到 main 分支"></a>4. 合并分支到 <code>main</code> 分支</h3><p>在完成新功能的开发并测试通过后，需要将新分支合并到 <code>main</code> 分支。以下是具体步骤：</p><h4 id="步骤一：切换到-main-分支并拉取最新代码"><a href="#步骤一：切换到-main-分支并拉取最新代码" class="headerlink" title="步骤一：切换到 main 分支并拉取最新代码"></a>步骤一：切换到 <code>main</code> 分支并拉取最新代码</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 切换到 main 分支</span><br>git checkout main<br><span class="hljs-comment"># 拉取远程 main 分支的最新代码</span><br>git pull origin main<br></code></pre></td></tr></table></figure><p>这一步的目的是确保本地的 <code>main</code> 分支是最新的，避免在合并时出现冲突。</p><h4 id="步骤二：合并新分支到-main-分支"><a href="#步骤二：合并新分支到-main-分支" class="headerlink" title="步骤二：合并新分支到 main 分支"></a>步骤二：合并新分支到 <code>main</code> 分支</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 合并新分支到 main 分支</span><br>git merge new-feature<br></code></pre></td></tr></table></figure><p>执行该命令后，Git 会尝试将 <code>new-feature</code> 分支的修改合并到 <code>main</code> 分支。如果没有冲突，合并会自动完成；如果有冲突，需要手动解决冲突。</p><h4 id="步骤三：解决冲突（如果有）"><a href="#步骤三：解决冲突（如果有）" class="headerlink" title="步骤三：解决冲突（如果有）"></a>步骤三：解决冲突（如果有）</h4><p>当合并分支时出现冲突，Git 会在冲突的文件中标记出冲突的部分，你需要手动打开这些文件，根据实际情况修改冲突内容。例如，文件中可能会出现类似以下的标记：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD<br>// main 分支的代码<br>=======<br>// new-feature 分支的代码<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; new-feature<br></code></pre></td></tr></table></figure><p>你需要根据需求选择保留哪部分代码，或者将两部分代码进行整合，然后删除这些标记。修改完成后，将文件添加到暂存区并提交：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">git add conflict-file.txt<br>git commit -m <span class="hljs-string">&quot;解决合并冲突&quot;</span><br></code></pre></td></tr></table></figure><h4 id="步骤四：将合并后的-main-分支推送到远程仓库"><a href="#步骤四：将合并后的-main-分支推送到远程仓库" class="headerlink" title="步骤四：将合并后的 main 分支推送到远程仓库"></a>步骤四：将合并后的 <code>main</code> 分支推送到远程仓库</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git push origin main<br></code></pre></td></tr></table></figure><h1 id="成员协作"><a href="#成员协作" class="headerlink" title="成员协作"></a>成员协作</h1><p>在多人协作开发场景下，为避免冲突和代码混乱，管理同学分支的合并可以采用以下流程和方法：</p><h3 id="1-使用代码托管平台的合并请求（Pull-Request，简称-PR）功能"><a href="#1-使用代码托管平台的合并请求（Pull-Request，简称-PR）功能" class="headerlink" title="1. 使用代码托管平台的合并请求（Pull Request，简称 PR）功能"></a>1. 使用代码托管平台的合并请求（Pull Request，简称 PR）功能</h3><p>多数代码托管平台（如 GitHub、GitLab、Gitee 等）都提供了合并请求功能，这是管理分支合并的有效方式。</p><h4 id="同学端操作"><a href="#同学端操作" class="headerlink" title="同学端操作"></a>同学端操作</h4><ul><li><strong>完成开发并推送分支</strong>：同学在完成自己分支（如 <code>feature-branch</code>）的开发工作后，将该分支推送到远程仓库。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git push -u origin feature-branch<br></code></pre></td></tr></table></figure></li><li><strong>发起合并请求</strong>：同学登录代码托管平台，在仓库页面发起从 <code>feature-branch</code> 到 <code>main</code> 分支的合并请求。在发起合并请求时，通常需要填写合并请求的标题和描述，说明本次开发的功能和修改内容。</li></ul><h4 id="你端操作"><a href="#你端操作" class="headerlink" title="你端操作"></a>你端操作</h4><ul><li><strong>审核合并请求</strong>：当收到同学的合并请求通知后，你可以在代码托管平台上查看合并请求的详细信息，包括修改的文件、代码差异等。</li><li><strong>代码审查</strong>：仔细审查同学提交的代码，检查代码质量、功能实现、是否符合项目规范等。你可以在代码托管平台上对代码进行评论和反馈，提出修改建议。</li><li><strong>解决冲突（如果有）</strong>：如果合并请求中存在冲突，代码托管平台会提示你。你可以选择在平台上直接解决冲突，或者将代码拉取到本地进行解决。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 拉取远程分支</span><br>git fetch origin feature-branch<br><span class="hljs-comment"># 创建本地分支并切换到该分支</span><br>git switch -c feature-branch origin/feature-branch<br><span class="hljs-comment"># 切换到 main 分支</span><br>git switch main<br><span class="hljs-comment"># 尝试合并分支</span><br>git merge feature-branch<br></code></pre></td></tr></table></figure>解决冲突后，提交修改并推送到远程仓库。</li><li><strong>批准并合并</strong>：在审核通过且解决了所有冲突后，你可以在代码托管平台上批准并合并该分支到 <code>main</code> 分支。</li></ul><h3 id="2-定期沟通和同步"><a href="#2-定期沟通和同步" class="headerlink" title="2. 定期沟通和同步"></a>2. 定期沟通和同步</h3><p>除了使用合并请求功能，定期与同学进行沟通和同步也非常重要。</p><ul><li><strong>进度沟通</strong>：定期与同学交流各自的开发进度，了解他们是否完成了开发任务，是否准备好发起合并请求。</li><li><strong>问题讨论</strong>：在开发过程中，可能会遇到一些技术问题或设计问题。通过沟通和讨论，可以及时解决这些问题，避免在合并时出现更大的冲突。</li></ul><h3 id="3-制定合并规则和流程"><a href="#3-制定合并规则和流程" class="headerlink" title="3. 制定合并规则和流程"></a>3. 制定合并规则和流程</h3><p>为了确保合并过程的顺利进行，建议制定明确的合并规则和流程。</p><ul><li><strong>代码规范</strong>：制定统一的代码规范，要求团队成员在开发过程中遵循这些规范。这样可以减少代码风格不一致导致的冲突。</li><li><strong>测试要求</strong>：规定在发起合并请求之前，必须对代码进行充分的测试，确保代码的质量和稳定性。</li><li><strong>合并时间</strong>：确定合适的合并时间，避免在项目关键时期进行大规模的合并操作，以免影响项目进度。</li></ul><h1 id="总结-🚀-Git-快速指令手册（GitHub-协作）"><a href="#总结-🚀-Git-快速指令手册（GitHub-协作）" class="headerlink" title="总结:🚀 Git 快速指令手册（GitHub 协作）"></a>总结:🚀 <strong>Git 快速指令手册（GitHub 协作）</strong></h1><h4 id="一、初始化配置"><a href="#一、初始化配置" class="headerlink" title="一、初始化配置"></a><strong>一、初始化配置</strong></h4><ol><li><p><strong>安装 Git</strong>（已装跳过）  </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">brew install git<br></code></pre></td></tr></table></figure></li><li><p><strong>设置用户名&#x2F;邮箱</strong>（全局）  </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">git config --global user.name <span class="hljs-string">&quot;你的名字&quot;</span><br>git config --global user.email <span class="hljs-string">&quot;你的邮箱&quot;</span><br></code></pre></td></tr></table></figure></li><li><p><strong>生成 SSH 密钥</strong>（自定义路径示例）  </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">ssh-keygen -t rsa -b 4096 -C <span class="hljs-string">&quot;注释&quot;</span>  <span class="hljs-comment"># 如：-C &quot;macbook-work&quot;</span><br><span class="hljs-comment"># 保存路径：/Users/你/Desktop/gitkey/id_rsa（按提示回车）</span><br></code></pre></td></tr></table></figure></li><li><p><strong>加载密钥到代理</strong>  </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">eval</span> <span class="hljs-string">&quot;<span class="hljs-subst">$(ssh-agent -s)</span>&quot;</span><br>ssh-add /Users/你/Desktop/gitkey/id_rsa  <span class="hljs-comment"># 替换实际路径</span><br></code></pre></td></tr></table></figure></li><li><p><strong>复制公钥到 GitHub</strong>  </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">pbcopy &lt; /Users/你/Desktop/gitkey/id_rsa.pub  <span class="hljs-comment"># 粘贴到 GitHub 设置</span><br></code></pre></td></tr></table></figure></li></ol><h4 id="二、创建-关联仓库"><a href="#二、创建-关联仓库" class="headerlink" title="二、创建 &amp; 关联仓库"></a><strong>二、创建 &amp; 关联仓库</strong></h4><ol><li><p><strong>本地初始化仓库（默认 main 分支）</strong>  </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">mkdir</span> 项目名 &amp;&amp; <span class="hljs-built_in">cd</span> 项目名<br>git init -b main<br></code></pre></td></tr></table></figure></li><li><p><strong>关联远程仓库</strong>  </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git remote add origin git@github.com:你的用户名/仓库名.git<br></code></pre></td></tr></table></figure></li><li><p><strong>首次推送（解决远程已有文件冲突）</strong>  </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">git pull --rebase origin main  <span class="hljs-comment"># 拉取远程（如 README）</span><br>git push -u origin main       <span class="hljs-comment"># 推送本地 main</span><br></code></pre></td></tr></table></figure></li></ol><h4 id="三、分支开发（单人）"><a href="#三、分支开发（单人）" class="headerlink" title="三、分支开发（单人）"></a><strong>三、分支开发（单人）</strong></h4><ol><li><p><strong>创建并切换分支</strong>  </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git switch -c 分支名  <span class="hljs-comment"># 等价：git checkout -b 分支名</span><br></code></pre></td></tr></table></figure></li><li><p><strong>提交代码</strong>  </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">git add .           <span class="hljs-comment"># 添加所有改动</span><br>git commit -m <span class="hljs-string">&quot;描述提交&quot;</span><br></code></pre></td></tr></table></figure></li><li><p><strong>推送分支到远程</strong>  </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">git push -u origin 分支名  <span class="hljs-comment"># 首次推送</span><br>git push            <span class="hljs-comment"># 后续推送</span><br></code></pre></td></tr></table></figure></li></ol><h4 id="四、协作合并（负责人操作）"><a href="#四、协作合并（负责人操作）" class="headerlink" title="四、协作合并（负责人操作）"></a><strong>四、协作合并（负责人操作）</strong></h4><ol><li><p><strong>同学推送分支并提 PR</strong><br>同学：<code>git push -u origin 他的分支名</code> → 在 GitHub 发起合并请求。</p></li><li><p><strong>你审核并合并</strong>  </p><ul><li>解决冲突（本地）：  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">git fetch origin 他的分支名  <span class="hljs-comment"># 拉取远程分支</span><br>git switch main              <span class="hljs-comment"># 切回主分支</span><br>git merge origin/他的分支名  <span class="hljs-comment"># 合并，手动改冲突文件</span><br>git add 冲突文件 &amp;&amp; git commit -m <span class="hljs-string">&quot;合并说明&quot;</span><br>git push origin main         <span class="hljs-comment"># 推送到远程</span><br></code></pre></td></tr></table></figure></li><li>直接在 GitHub PR 界面点击 <strong>Merge</strong>（推荐）。</li></ul></li><li><p><strong>删除已合并分支</strong>（可选）  </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">git branch -d 他的分支名    <span class="hljs-comment"># 删除本地分支</span><br>git push origin --delete 他的分支名  <span class="hljs-comment"># 删除远程分支</span><br></code></pre></td></tr></table></figure></li></ol><h4 id="五、常见问题"><a href="#五、常见问题" class="headerlink" title="五、常见问题"></a><strong>五、常见问题</strong></h4><ol><li><p><strong>推送被拒（远程有更新）</strong>  </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git pull --rebase origin main  <span class="hljs-comment"># 先拉取合并，再推送</span><br></code></pre></td></tr></table></figure></li><li><p><strong>合并冲突解决</strong><br>手动修改文件中 <code>&lt;&lt;&lt;&lt;&lt;&lt;&lt;</code> 标记的冲突部分 → <code>git add 冲突文件</code> → <code>git commit</code>。</p></li></ol><h3 id="📌-极简流程图"><a href="#📌-极简流程图" class="headerlink" title="📌 极简流程图"></a>📌 <strong>极简流程图</strong></h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql">本地开发：<br>新建分支 → 写代码 → <span class="hljs-keyword">add</span> → <span class="hljs-keyword">commit</span> → push（分支）<br><br>协作合并：<br>同学提 PR → 你审查<span class="hljs-operator">/</span>解决冲突 → 点击 <span class="hljs-keyword">Merge</span>（GitHub）→ 删除废分支<br></code></pre></td></tr></table></figure><p><strong>记住：永远不要直接在 main 分支开发！</strong> 🔥<br>（全文完，按场景查指令即可）</p><p>有时候push操作出现失败的话，可能需要重新加载密钥</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash">有时候，SSH 代理可能没有正确加载私钥，这就会导致身份验证失败。<br>解决办法：<br>启动 SSH 代理：<br>bash<br><span class="hljs-built_in">eval</span> <span class="hljs-string">&quot;<span class="hljs-subst">$(ssh-agent -s)</span>&quot;</span><br><br>把私钥添加到 SSH 代理：<br>bash<br>ssh-add ~/.ssh/id_rsa<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>git</tag>
      
      <tag>ssh</tag>
      
      <tag>github</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ssh连接服务器（阿里云ECS）</title>
    <link href="/2025/03/22/cs/ssh%E8%BF%9E%E6%8E%A5%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    <url>/2025/03/22/cs/ssh%E8%BF%9E%E6%8E%A5%E6%9C%8D%E5%8A%A1%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<p>绑定密钥对后，可以按照以下步骤开始使用阿里云 ECS 实例，涵盖初始化配置、安全加固、代码部署及管理优化：</p><h3 id="连接服务器"><a href="#连接服务器" class="headerlink" title="连接服务器"></a>连接服务器</h3><h4 id="1-使用-SSH-密钥登录"><a href="#1-使用-SSH-密钥登录" class="headerlink" title="1. 使用 SSH 密钥登录"></a>1. <strong>使用 SSH 密钥登录</strong></h4>   <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">ssh -i /Users/asina6y6/Desktop/gitkey/aliyun_ecs_ed25519 root@你的ECS公网IP<br></code></pre></td></tr></table></figure><p>   • 若提示密钥权限问题，执行：<br>     <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">chmod</span> 600 /Users/asina6y6/Desktop/gitkey/aliyun_ecs_ed25519<br></code></pre></td></tr></table></figure></p><h4 id="2-验证登录"><a href="#2-验证登录" class="headerlink" title="2. 验证登录"></a>2. <strong>验证登录</strong></h4><p>   • 成功登录后终端会显示类似提示：<br>     <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">Welcome to Alibaba Cloud Elastic Compute Service !<br>[root@iZbp1~]#<br></code></pre></td></tr></table></figure></p><p>如果要退出登录，使用</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">exit</span><br></code></pre></td></tr></table></figure><h3 id="部署代码到服务器上"><a href="#部署代码到服务器上" class="headerlink" title="部署代码到服务器上"></a>部署代码到服务器上</h3><p>将整个项目目录上传到服务器的 <code>/home/multilabel-twin-svm</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">scp -r -i ~/Desktop/gitkey/aliyun_ecs_ed25519 \<br>    /Users/asina6y6/Desktop/multilabel-twin-svm \<br>    root@121.40.87.134:/home/<br></code></pre></td></tr></table></figure><p>安装Miniconda</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 下载安装包</span><br>wget https://repo.anaconda.com/miniconda/Miniconda3-latest-Linux-x86_64.sh<br><br><span class="hljs-comment"># 安装（默认路径为 /root/miniconda3）</span><br>bash Miniconda3-latest-Linux-x86_64.sh<br><br><span class="hljs-comment"># 激活 conda</span><br><span class="hljs-built_in">source</span> ~/miniconda3/bin/activate<br></code></pre></td></tr></table></figure><p>之后用conda的命令自行配置环境</p><h3 id="简化ssh连接流程"><a href="#简化ssh连接流程" class="headerlink" title="简化ssh连接流程"></a>简化ssh连接流程</h3><p>先在Mac上创立config文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">mkdir</span> -p ~/.ssh<br>vi ~/.ssh/config<br></code></pre></td></tr></table></figure><p>添加以下内容</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash">Host aliyun-ecs                      <span class="hljs-comment"># 自定义别名（可任意命名）</span><br>    HostName 121.40.87.134           <span class="hljs-comment"># 服务器公网IP</span><br>    User root                         <span class="hljs-comment"># 登录用户（默认root，Ubuntu系统用ubuntu）</span><br>    Port 22                           <span class="hljs-comment"># 默认SSH端口</span><br>    IdentityFile ~/Desktop/gitkey/aliyun_ecs_ed25519  <span class="hljs-comment"># 私钥绝对路径</span><br>    IdentitiesOnly <span class="hljs-built_in">yes</span>                <span class="hljs-comment"># 强制使用指定密钥</span><br>    ServerAliveInterval 30            <span class="hljs-comment"># 每30秒发送保活信号</span><br>    ServerAliveCountMax 5             <span class="hljs-comment"># 最多重试5次</span><br></code></pre></td></tr></table></figure><p>设置文件权限</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">chmod</span> 600 ~/.ssh/config<br></code></pre></td></tr></table></figure><p>后面就可以用别名直接连接了</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">ssh aliyun-ecs  <span class="hljs-comment"># 使用别名直接连接</span><br></code></pre></td></tr></table></figure><p>此时Mac中相关的文件结构如下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">~/Desktop/gitkey/<br>├── aliyun_ecs_ed25519      <span class="hljs-comment"># 私钥（权限必须600）</span><br>└── aliyun_ecs_ed25519.pub  <span class="hljs-comment"># 公钥（已绑定到ECS）</span><br><br>~/.ssh/<br>└── config                  <span class="hljs-comment"># 配置文件（权限600）</span><br></code></pre></td></tr></table></figure><h3 id="tmux简单使用"><a href="#tmux简单使用" class="headerlink" title="tmux简单使用"></a>tmux简单使用</h3><p>SSH 登录远程计算机，打开一个远程窗口执行命令。这时，网络突然断线，再次登录的时候，是找不回上一次执行的命令的。因为上一次 SSH 会话已经终止了，里面的进程也随之消失了。</p><p> 为了解决这个问题，我们使用终端复用器tmux。会话与窗口可以”解绑”：窗口关闭时，会话并不终止，而是继续运行，等到以后需要的时候，再让会话”绑定”其他窗口。</p><p> 首先在服务器上安装tmux，一般而言阿里云的服务器已经安装好了</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># Ubuntu/Debian</span><br><span class="hljs-built_in">sudo</span> apt install tmux<br><br><span class="hljs-comment"># CentOS</span><br><span class="hljs-built_in">sudo</span> yum install tmux<br></code></pre></td></tr></table></figure><p>创建新会话</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">tmux new -s svm_task<br></code></pre></td></tr></table></figure><ul><li><code>-s svm_task</code>：会话名称（可自定义）</li></ul><p>一旦创建则默认进入此回话，在会话中运行代码</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 进入项目目录</span><br><span class="hljs-built_in">cd</span> /home/multilabel-twin-svm<br><br><span class="hljs-comment"># 激活 Conda 环境</span><br>conda activate myenv<br><br><span class="hljs-comment"># 运行代码</span><br>python main.py <br></code></pre></td></tr></table></figure><p>退出回话</p><ul><li>Ctrl+B → 松开 → 按 D</li></ul><p>查看当前已有会话</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">tmux <span class="hljs-built_in">ls</span><br></code></pre></td></tr></table></figure><p>连接到某一个回话上</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">tmux attach -t svm_task<br></code></pre></td></tr></table></figure><h3 id="附录：Linux-常用命令与-Vim-常用命令速查表"><a href="#附录：Linux-常用命令与-Vim-常用命令速查表" class="headerlink" title="附录：Linux 常用命令与 Vim 常用命令速查表"></a>附录：Linux 常用命令与 Vim 常用命令速查表</h3><hr><h4 id="一、Linux-常用命令"><a href="#一、Linux-常用命令" class="headerlink" title="一、Linux 常用命令"></a><strong>一、Linux 常用命令</strong></h4><table><thead><tr><th><strong>命令</strong></th><th><strong>功能</strong></th><th><strong>示例</strong></th></tr></thead><tbody><tr><td><code>ls</code></td><td>列出目录内容</td><td><code>ls -l</code>（详细信息）</td></tr><tr><td><code>cd</code></td><td>切换目录</td><td><code>cd /home</code>（进入 <code>/home</code> 目录）</td></tr><tr><td><code>pwd</code></td><td>显示当前目录路径</td><td><code>pwd</code></td></tr><tr><td><code>mkdir</code></td><td>创建目录</td><td><code>mkdir new_folder</code></td></tr><tr><td><code>rm</code></td><td>删除文件或目录</td><td><code>rm file.txt</code>（删除文件）</td></tr><tr><td><code>rmdir</code></td><td>删除空目录</td><td><code>rmdir empty_folder</code></td></tr><tr><td><code>cp</code></td><td>复制文件或目录</td><td><code>cp file.txt backup/</code></td></tr><tr><td><code>mv</code></td><td>移动或重命名文件&#x2F;目录</td><td><code>mv file.txt new_name.txt</code></td></tr><tr><td><code>cat</code></td><td>查看文件内容</td><td><code>cat file.txt</code></td></tr><tr><td><code>less</code></td><td>分页查看文件内容</td><td><code>less large_file.log</code></td></tr><tr><td><code>head</code></td><td>查看文件开头部分</td><td><code>head -n 10 file.txt</code>（前10行）</td></tr><tr><td><code>tail</code></td><td>查看文件末尾部分</td><td><code>tail -f log_file.log</code>（实时监控）</td></tr><tr><td><code>grep</code></td><td>搜索文本</td><td><code>grep &quot;error&quot; log_file.log</code></td></tr><tr><td><code>find</code></td><td>查找文件</td><td><code>find /home -name &quot;*.txt&quot;</code></td></tr><tr><td><code>chmod</code></td><td>修改文件权限</td><td><code>chmod 755 script.sh</code></td></tr><tr><td><code>chown</code></td><td>修改文件所有者</td><td><code>chown user:group file.txt</code></td></tr><tr><td><code>ps</code></td><td>查看进程状态</td><td><code>ps aux</code></td></tr><tr><td><code>top</code></td><td>实时查看系统资源占用</td><td><code>top</code></td></tr><tr><td><code>kill</code></td><td>终止进程</td><td><code>kill -9 1234</code>（强制终止PID为1234的进程）</td></tr><tr><td><code>tar</code></td><td>打包&#x2F;解压文件</td><td><code>tar -czvf archive.tar.gz folder/</code></td></tr><tr><td><code>wget</code></td><td>下载文件</td><td><code>wget https://example.com/file.zip</code></td></tr><tr><td><code>curl</code></td><td>传输数据</td><td><code>curl -O https://example.com/file.zip</code></td></tr><tr><td><code>ssh</code></td><td>远程登录</td><td><code>ssh user@hostname</code></td></tr><tr><td><code>scp</code></td><td>远程复制文件</td><td><code>scp file.txt user@hostname:/path/</code></td></tr><tr><td><code>rsync</code></td><td>同步文件</td><td><code>rsync -avz src/ user@hostname:dest/</code></td></tr></tbody></table><hr><h4 id="二、Vim-常用命令"><a href="#二、Vim-常用命令" class="headerlink" title="二、Vim 常用命令"></a><strong>二、Vim 常用命令</strong></h4><table><thead><tr><th><strong>模式</strong></th><th><strong>命令</strong></th><th><strong>功能</strong></th></tr></thead><tbody><tr><td><strong>普通模式</strong></td><td><code>i</code></td><td>进入插入模式（光标前）</td></tr><tr><td></td><td><code>a</code></td><td>进入插入模式（光标后）</td></tr><tr><td></td><td><code>o</code></td><td>在当前行下方插入新行</td></tr><tr><td></td><td><code>O</code></td><td>在当前行上方插入新行</td></tr><tr><td></td><td><code>dd</code></td><td>删除当前行</td></tr><tr><td></td><td><code>yy</code></td><td>复制当前行</td></tr><tr><td></td><td><code>p</code></td><td>粘贴</td></tr><tr><td></td><td><code>u</code></td><td>撤销</td></tr><tr><td></td><td><code>Ctrl+R</code></td><td>重做</td></tr><tr><td></td><td><code>:w</code></td><td>保存文件</td></tr><tr><td></td><td><code>:q</code></td><td>退出</td></tr><tr><td></td><td><code>:wq</code> 或 <code>ZZ</code></td><td>保存并退出</td></tr><tr><td></td><td><code>:q!</code></td><td>强制退出（不保存）</td></tr><tr><td></td><td><code>/keyword</code></td><td>搜索 <code>keyword</code></td></tr><tr><td></td><td><code>n</code></td><td>查找下一个匹配项</td></tr><tr><td></td><td><code>N</code></td><td>查找上一个匹配项</td></tr><tr><td></td><td><code>:%s/old/new/g</code></td><td>全局替换 <code>old</code> 为 <code>new</code></td></tr><tr><td><strong>插入模式</strong></td><td><code>ESC</code></td><td>返回普通模式</td></tr><tr><td><strong>可视模式</strong></td><td><code>v</code></td><td>进入字符选择模式</td></tr><tr><td></td><td><code>V</code></td><td>进入行选择模式</td></tr><tr><td></td><td><code>Ctrl+V</code></td><td>进入块选择模式</td></tr><tr><td></td><td><code>y</code></td><td>复制选中内容</td></tr><tr><td></td><td><code>d</code></td><td>删除选中内容</td></tr></tbody></table><hr><h4 id="三、常用快捷键组合"><a href="#三、常用快捷键组合" class="headerlink" title="三、常用快捷键组合"></a><strong>三、常用快捷键组合</strong></h4><table><thead><tr><th><strong>场景</strong></th><th><strong>操作</strong></th><th><strong>效果</strong></th></tr></thead><tbody><tr><td><strong>快速保存退出</strong></td><td><code>ESC</code> → <code>:wq</code></td><td>保存并退出</td></tr><tr><td><strong>强制退出</strong></td><td><code>ESC</code> → <code>:q!</code></td><td>放弃更改并退出</td></tr><tr><td><strong>复制粘贴</strong></td><td><code>yy</code> → <code>p</code></td><td>复制一行并粘贴</td></tr><tr><td><strong>查找替换</strong></td><td><code>ESC</code> → <code>:%s/old/new/g</code></td><td>全局替换 <code>old</code> 为 <code>new</code></td></tr><tr><td><strong>分屏操作</strong></td><td><code>:split</code> 或 <code>:vsplit</code></td><td>水平或垂直分屏</td></tr><tr><td><strong>切换窗口</strong></td><td><code>Ctrl+W</code> → 方向键</td><td>在分屏窗口间切换</td></tr></tbody></table><hr><h4 id="四、Vim-模式说明"><a href="#四、Vim-模式说明" class="headerlink" title="四、Vim 模式说明"></a><strong>四、Vim 模式说明</strong></h4><ol><li><strong>普通模式</strong>：默认模式，用于导航和操作文本  </li><li><strong>插入模式</strong>：编辑文本内容（按 <code>i</code> 进入）  </li><li><strong>可视模式</strong>：选择文本（按 <code>v</code> 进入）  </li><li><strong>命令模式</strong>：执行命令（按 <code>:</code> 进入）</li></ol><hr><h4 id="五、Vim-配置文件（-vimrc）示例"><a href="#五、Vim-配置文件（-vimrc）示例" class="headerlink" title="五、Vim 配置文件（~&#x2F;.vimrc）示例"></a><strong>五、Vim 配置文件（~&#x2F;.vimrc）示例</strong></h4><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs vim"><span class="hljs-keyword">set</span> <span class="hljs-keyword">number</span>            <span class="hljs-comment">&quot; 显示行号</span><br><span class="hljs-keyword">set</span> tabstop=<span class="hljs-number">4</span>         <span class="hljs-comment">&quot; 设置 Tab 宽度为 4</span><br><span class="hljs-keyword">set</span> <span class="hljs-built_in">shiftwidth</span>=<span class="hljs-number">4</span>      <span class="hljs-comment">&quot; 设置缩进宽度为 4</span><br><span class="hljs-keyword">set</span> expandtab         <span class="hljs-comment">&quot; 将 Tab 转换为空格</span><br><span class="hljs-keyword">syntax</span> <span class="hljs-keyword">on</span>             <span class="hljs-comment">&quot; 启用语法高亮</span><br><span class="hljs-keyword">set</span> hlsearch          <span class="hljs-comment">&quot; 高亮搜索结果</span><br><span class="hljs-keyword">set</span> incsearch         <span class="hljs-comment">&quot; 实时搜索</span><br><span class="hljs-keyword">set</span> ignorecase        <span class="hljs-comment">&quot; 忽略大小写</span><br><span class="hljs-keyword">set</span> smartcase         <span class="hljs-comment">&quot; 智能大小写匹配</span><br></code></pre></td></tr></table></figure><hr><p>通过此附录，你可以快速掌握 Linux 和 Vim 的常用操作。建议将常用命令打印或保存为速查表，方便随时查阅！</p>]]></content>
    
    
    
    <tags>
      
      <tag>git</tag>
      
      <tag>ssh</tag>
      
      <tag>github</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>模糊综合评价模版</title>
    <link href="/2025/03/21/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1/%E6%A8%A1%E7%B3%8A%E7%BB%BC%E5%90%88%E8%AF%84%E4%BB%B7/"/>
    <url>/2025/03/21/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1/%E6%A8%A1%E7%B3%8A%E7%BB%BC%E5%90%88%E8%AF%84%E4%BB%B7/</url>
    
    <content type="html"><![CDATA[<h1 id="一级模糊判断"><a href="#一级模糊判断" class="headerlink" title="一级模糊判断"></a>一级模糊判断</h1><h2 id="评语集有评价色彩"><a href="#评语集有评价色彩" class="headerlink" title="评语集有评价色彩"></a>评语集有评价色彩</h2><h3 id="step1，确立指标"><a href="#step1，确立指标" class="headerlink" title="step1，确立指标"></a>step1，确立指标</h3><p>评价指标集(因素集$),U&#x3D;{u_1,u_2,…u_n}$</p><p>评价等级(评语集$),V&#x3D;{v_1,v_2,…v_m}$</p><p>指标的权重(权重集$),A&#x3D;{a_1,a_2,…a_n}$</p><p>例如，评价一件衣服的受市场欢迎程度，可以从$U&#x3D;{$花色、样式、价格、耐用度、舒适度$}$方面考虑，以此来判断这件衣服是$V&#x3D;{$很欢迎、欢迎、一般、不欢迎$}$,其中我们给$U$中的因素赋予权重$A&#x3D;{0.1<del>0.2</del>0.1<del>0.4</del>0.2}.$</p><h3 id="step2-，对每个评价指标-u-i-文字评价解释"><a href="#step2-，对每个评价指标-u-i-文字评价解释" class="headerlink" title="step2 ，对每个评价指标$u_{i}$文字评价解释"></a>step2 ，对每个评价指标$u_{i}$文字评价解释</h3><p>$\textcircled{1}u_1$由群众评议打分确定：$R_1&#x3D;[0.1,0.5,0.4,0,0]$,这个式子表示，有10%的人认为政治表现优秀，<br>$50%$的人认为政治表现良好，$40%$的人认为政治表现一般，认为政治表现较差或差的人数为0<br>$\textcircled{2}u_2$和$u_3$由部门领导打分确定：$R_2&#x3D;[0.2,0.5,0.2,0.1,0],R_3&#x3D;[0.2,0.5,0.3,0,0].$<br>$\textcircled{3}u_4$由单位考核组成员打分确定：$R_4&#x3D;[0.2,0.6,0.2,0,0]$           </p><h3 id="step3-写出模糊矩阵，进行模糊判断"><a href="#step3-写出模糊矩阵，进行模糊判断" class="headerlink" title="step3 写出模糊矩阵，进行模糊判断"></a>step3 写出模糊矩阵，进行模糊判断</h3><p>$$R&#x3D;\begin{bmatrix}r_{11}&amp;r_{12}&amp;\cdots&amp;r_{1m}\r_{21}&amp;r_{22}&amp;\cdots&amp;r_{2m}\\vdots&amp;\vdots&amp;\ddots&amp;\vdots\r_{n1}&amp;r_{n2}&amp;\cdots&amp;r_{nm}\end{bmatrix}&#x3D;\begin{bmatrix}R_1\R_2\…\R_n\end{bmatrix}$$</p><p>$$B&#x3D;A\cdot R&#x3D;[0.25,0.2,0.25,0.3]\cdot\begin{bmatrix}0.1&amp;0.5&amp;0.4&amp;0&amp;0\0.2&amp;0.5&amp;0.2&amp;0.1&amp;0\0.2&amp;0.5&amp;0.3&amp;0&amp;0\0.2&amp;0.6&amp;0.2&amp;0&amp;0\end{bmatrix}&#x3D;[0.175,0.53,0.275,0.02,0].$$<br>取数值最大的评语作为最后综合评判结果，所以评判结果为“良好”.</p><h2 id="评语集无评价色彩"><a href="#评语集无评价色彩" class="headerlink" title="评语集无评价色彩"></a>评语集无评价色彩</h2><p>通过隶属函数化为有评价色彩即可</p><p>例3.某露天煤矿有五个边坡设计方案，其各项参数根据分析计算结果得到边坡设计方案的参数如下：</p><table>    <tbody>        <tr>            <th>项目</th>            <th>方案1</th>            <th>方案2</th>            <th>方案3</th>            <th>方案4</th>            <th>方案5</th>        </tr>        <tr>            <td>可采矿量/万吨</td>            <td>4700</td>            <td>6700</td>            <td>5900</td>            <td>8800</td>            <td>7600</td>        </tr>        <tr>            <td>基建投资/万元</td>            <td>5000</td>            <td>5500</td>            <td>5300</td>            <td>6800</td>            <td>6000</td>        </tr>        <tr>            <td>采矿成本</td>            <td>4.0</td>            <td>6.1</td>            <td>5.5</td>            <td>7.0</td>            <td>6.8</td>        </tr>        <tr>            <td>不稳定费用</td>            <td>30</td>            <td>50</td>            <td>40</td>            <td>200</td>            <td>160</td>        </tr>    </tbody></table><p>据勘探，该矿探明储量8800吨，开采投资不超过8000万元，试做出各方案的优劣排序，选出最佳方案</p><h3 id="step1确定隶属函数"><a href="#step1确定隶属函数" class="headerlink" title="step1确定隶属函数"></a>step1确定隶属函数</h3><p>因为表中勘探的地质储量最大为8800吨，故可采矿量的隶属函数$u_A(x)&#x3D;\frac x{8800}$</p><p>$\begin{aligned}&amp;\text{投资约束是8000万元，所以}u_{B}(x)&#x3D;1-\frac{x}{8000}\&amp;\text{根据专家意见，采矿成本}a_{1}\leqslant5.5\text{元&#x2F;吨为低成本，}a_{2}&#x3D;8.0\text{元&#x2F;吨为高成本，故}u_{c}(x)&#x3D;\begin{cases}1,&amp;0\leqslant x\leqslant5.5\\frac{8.0-x}{8.0-5.5},&amp;5.5\leqslant x\leqslant8.0\0.&amp;8.0\leqslant x&amp;&amp;\end{cases}\end{aligned}$</p><p>不稳定费用的隶属函数$u_D(x)&#x3D;1-\frac x{200}$</p><h3 id="step2得出模糊矩阵"><a href="#step2得出模糊矩阵" class="headerlink" title="step2得出模糊矩阵"></a>step2得出模糊矩阵</h3><table>    <tbody>        <tr>            <th>项目</th>            <th>方案1</th>            <th>方案2</th>            <th>方案3</th>            <th>方案4</th>            <th>方案5</th>        </tr>        <tr>            <td>可采矿量</td>            <td>0.5341</td>            <td>0.7614</td>            <td>0.6405</td>            <td>1</td>            <td>0.8636</td>        </tr>        <tr>            <td>基建投资</td>            <td>0.3750</td>            <td>0.3125</td>            <td>0.3375</td>            <td>0.15</td>            <td>0.25</td>        </tr>        <tr>            <td>采矿成本</td>            <td>1</td>            <td>0.76</td>            <td>1</td>            <td>0.4</td>            <td>0.48</td>        </tr>        <tr>            <td>不稳定费用</td>            <td>1</td>            <td>0.4480</td>            <td>0.6552</td>            <td>0</td>            <td>0.0345</td>        </tr>    </tbody></table><h1 id="多级模糊评价"><a href="#多级模糊评价" class="headerlink" title="多级模糊评价"></a>多级模糊评价</h1><p><img src="https://www.freeimg.cn/i/2024/07/26/66a36717755ee.png" alt="1721984789553.png"></p><p>矩阵得到的模糊向量套成新的矩阵</p><p><img src="https://www.freeimg.cn/i/2024/07/26/66a36741adec3.png" alt="1721984831557.png"></p>]]></content>
    
    
    <categories>
      
      <category>数学建模</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>线性规划</title>
    <link href="/2025/03/21/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1/%E8%A7%84%E5%88%92%E7%B1%BB%E9%97%AE%E9%A2%98/"/>
    <url>/2025/03/21/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1/%E8%A7%84%E5%88%92%E7%B1%BB%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h2 id="规划基本概念"><a href="#规划基本概念" class="headerlink" title="规划基本概念"></a>规划基本概念</h2><ul><li>定义：在给定的约束条件(constraint)下，找出一个决策变量(decision variable)的值，使得被称为目标函数(objective function)的表达愿望尺度的函数值达到最小或最大。</li><li>在解决实际问题时，把问题归结成一个最优化模型是很重要的一步，也是很困难的一步，模型建立得是否恰当，直接影响到求解。建立模型的关键之一是选择适当的决策变量。<br> $$\begin{array}{ll}\min&amp;f(\mathbf{x})\\mathrm{s.t.}&amp;\mathbf{x}\in S\subset\mathbb{R}^n.\end{array}$$<br>在此，目标函数$f$是定义在包含$S$的适当集合上的实值函数。<br>进一步，$S$是该问题变量x的可取值之集合，称为问题的可行域(feasible region)。<br>满足约束条件$\mathbf{x}\in S$的$\mathbf{x}$称为问题的可行解(feasible solution)。<br>在所有可行解中包含局部最优解和全局最优解，我们的目的就是找到全局最优解。</li><li>带约束最优化问题通常可写为：<br>$$\begin{array}{ll}\min&amp;f(\mathbf{x})\\mathrm{s.t.}&amp;c_i(\mathbf{x})&#x3D;0,\quad i\in E,\&amp;c_i(\mathbf{x})\geqslant0,\quad i\in I.\end{array}$$</li></ul><p>在matlab中常用的对应工具包</p><ul><li>1.非线性规划 fmincon</li><li>2.无约束极值 fminunc, fminsearch</li><li>3.二次规划问题(目标函数是二次函数，约束条件全部是线性的) quadprog ,</li><li>4.其它 fseminf (半无穷约束条件), </li><li>5 fminimax        $\operatorname*{min}_x\max_iF_i(x)$</li></ul><h2 id="线性规划"><a href="#线性规划" class="headerlink" title="线性规划"></a>线性规划</h2><p>把所有的方程约束中系数做成系数矩阵$A_{\text{eq}}$，等号右边的常数作为列向量$b_\text{eq}$；不等式约束中的系数矩阵$A$和不等号右边的常数$b$，为了方便起见通常将不等式统一为小于等于；变量$x$在向量$l_b$到$u_b$之间取值；目标函数的系数向量为$c$，那么线性规划的标准形式(也是matlab标准形式)就如下所示：<br>$$\min_x{f^Tx}\s.t.\begin{cases}A\cdot x\leq b\A_{eq}\cdot x&#x3D;b_{eq}\l_b\leq x\leq u_b\end{cases}$$</p><h3 id="matlab求解"><a href="#matlab求解" class="headerlink" title="matlab求解"></a>matlab求解</h3><p><img src="https://t.tutu.to/img/B88zH"></p><ul><li>含有绝对值的将问题转化为线性规划<br>$$\begin{array}{l}\min{z&#x3D;|x_1|+|x_2|+\cdots+|x_n|}\s.t.Ax\leq b\end{array}$$</li></ul><p>其中$x&#x3D;(x_1,x_2,\cdots,x_n)^T$。</p><p>取：<br>$$u_i&#x3D;\dfrac{x_i+|x_i|}{2},v_i&#x3D;\dfrac{|x_i|-x_i}{2}$$<br>则：<br>$$u_i\geq0,v_i\geq0,x_i&#x3D;u_i-v_i,|x_i|&#x3D;u_i+v_i$$<br>原始优化问题化为：<br>$$\operatorname*{min}{z&#x3D;\sum_{i&#x3D;1}^n(u_i+v_i)}\s.t.\begin{cases}A(u-v)\leq b\u,v\geq0\end{cases}$$<br>其中$u&#x3D;(u_1,u_{2},\cdots,u_{n})^{T},v&#x3D;(v_{1},v_{2},\cdots,v_{n})^{T}.$<br>进一步可以写成<br>$$\min{z&#x3D;\sum_{i&#x3D;1}^n(u_i+v_i)}\s.t.\begin{cases}(A,-A)\begin{pmatrix}u\v\end{pmatrix}\le b\[2ex]u,v\ge0\end{cases}$$</p><ul><li>例2.市场上有$n$ 种资产$s_i(i&#x3D;1,2,\cdotp\cdotp\cdotp,n)$可以选择，现用数额为$M$的相当大的资金作一个时期的投资。这$n$ 种资产在这一时期内购买$s_i$的平均收益率为$r_i$,风险损失率为$q_i$,投资越分散，总的风险越少，总体风险可用投资的$s_i$中最大的一个风险来度量.购买$s_i$时要付交易费，费率为$p_i$。另外，假定同期银行存款利率是$r_0$,既无交易费又无风险$(r_0&#x3D;5%)$ 已知$n&#x3D;4$时相关数据如表1.1所列.请你为该公司设计一种投资方案，使净收益尽可能大，总体风险尽可能小.</li></ul><p>$$\text{目标函数}\begin{cases}\max\sum_{i&#x3D;0}^n(r_i-p_i)x_i\\\min\left{\max_{1\leqslant i\leqslant n}\left{q_ix_i\right}\right}\end{cases},\text{ 约束条件为}\begin{cases}\sum_{i&#x3D;0}^n(1+p_i)x_i&#x3D;M,\\x_i\geqslant0,i&#x3D;0,1,\cdots,n_\circ&amp;\end{cases}$$</p><p>但是两个目标函数求解不了，为此我们考虑把一个目标函数转化为约束条件即可</p><p>$$\begin{cases}\sum_{i&#x3D;0}^n(1+p_i)x_i&#x3D;M,\x_i\geqslant0,i&#x3D;0,1,\cdots,n\\frac{q_ix_i}M\leqslant a\end{cases}$$</p><h3 id="运输问题-产销平衡-指派问题"><a href="#运输问题-产销平衡-指派问题" class="headerlink" title="运输问题 (产销平衡)  &amp; 指派问题"></a>运输问题 (产销平衡)  &amp; 指派问题</h3><ul><li><p>运输问题<br> 某商品有$m$个产地、$n$个销地，各产地的产量分别为$a_1,\cdots,a_m$,各销地的需求量分别为$b_1,\cdotp\cdotp\cdotp,b_n$。若该商品由$i$产地运到 $j$ 销地的单位运价为$c_ij$ ,问应该如何调运才能使总运费最省？<br>解：引入变量$x_i$,其取值为由$i$产地运往 $j$ 销地的该商品数量，数学模型为<br>$$\begin{aligned}&amp;\text{min}\quad\sum_{i&#x3D;1}^m\sum_{j&#x3D;1}^nc_{ij}x_{ij}\&amp;\text{s.t.}\quad\begin{cases}\sum_{j&#x3D;1}^nx_{ij}&#x3D;a_i,&amp;i&#x3D;1,\cdots,m\\\sum_{i&#x3D;1}^mx_{ij}&#x3D;b_j,&amp;j&#x3D;1,2,\cdots,n\\x_{ij}\geq0\end{cases}\end{aligned}$$</p></li><li><p>指派问题<br>例 7 拟分配$n$ 人去干$n$ 项工作，每人干且仅干一项工作，若分配第$i$ 人去干第 $j$<br>项工作，需花费$c_{ij}$单位时间，问应如何分配工作才能使工人花费的总时间最少？<br>容易看出，要给出一个指派问题的实例，只需给出矩阵$C&#x3D;(c_{ij}),C$被称为指派<br>问题的系数矩阵。<br>引入变量$x_{ij}$,若分配$i$干$j$ 工作，则取$x_{ij}&#x3D;1$,否则取$x_{ij}&#x3D;0$。上述指派问题的<br>数学模型为<br>$$\begin{aligned}<br>&amp;\mathrm{min}\quad\sum_{i&#x3D;1}^{n}\sum_{j&#x3D;1}^{n}c_{ij}x_{ij} \<br>\text{s.t.}&amp; \sum_{j&#x3D;1}^{n}x_{ij}&#x3D;1 \<br>&amp;\sum_{i&#x3D;1}^{n}x_{ij}&#x3D;1 \<br>&amp;x_{ij}&#x3D;0 \text{或} 1<br>\end{aligned}$$</p></li></ul><p>对 于指派问题等 0−1整数规划问题，可以直接利用 Matlab 的函数 bintprog 进行求解。 </p><ul><li>匈牙利算法：</li></ul>]]></content>
    
    
    <categories>
      
      <category>数学建模</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>优化算法</title>
    <link href="/2025/03/21/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E4%BC%98%E5%8C%96%E7%AE%97%E6%B3%95/"/>
    <url>/2025/03/21/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E4%BC%98%E5%8C%96%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="优化算法概论"><a href="#优化算法概论" class="headerlink" title="优化算法概论"></a>优化算法概论</h1><p>理想的优化算法有以下几个特点</p><ul><li>数值解 ${x_k}_{k&#x3D;0}^{\infty}$的迭代，实际中操作使用有限次，满足一定条件停止迭代即可</li><li>单调性，满足$f(x_{k+1})&lt;f(x_{k-m})$就很好，但是往往碰到螺旋下降的情况</li><li>策略 ：$x_k$如何到$x_{k+1}$?</li></ul><h3 id="线搜索方法"><a href="#线搜索方法" class="headerlink" title="线搜索方法"></a>线搜索方法</h3><p>$$x_{k+1}&#x3D;x_k+\alpha_kp_k$$</p><p>这里$\alpha_k$是一个很小的正量表示步长，$p_k$表示方向，线搜索方法就是先定方向，再定步长</p><h3 id="信赖域方法"><a href="#信赖域方法" class="headerlink" title="信赖域方法"></a>信赖域方法</h3><p>$$x_{k+1}&#x3D;x_k+p_k$$</p><p>方向和步长合二为一</p><h1 id="线搜索方法理论"><a href="#线搜索方法理论" class="headerlink" title="线搜索方法理论"></a>线搜索方法理论</h1><h2 id="确定方向"><a href="#确定方向" class="headerlink" title="确定方向"></a>确定方向</h2><p>假定</p><ul><li>${ f(x_k)}_{k&#x3D;0}^{\infty}$是单调下降的          </li><li>$\alpha_k$足够小              </li><li>$||p_k||&#x3D;1$</li></ul><p>则有<br>$$<br>\begin{align*}<br>f(x_{k+1}) &amp;&#x3D; f(x_k + \alpha_k p_k) \<br>           &amp;&#x3D; f(x_k) + \nabla f(x_k)^T \cdot \alpha_k p_k + o(|\alpha_k p_k|) \<br>f(x_{k+1}) - f(x_k) &amp;\approx \nabla f(x_k)^T \cdot \alpha_k p_k &lt; 0 \<br>\text{由于 } \alpha_k &amp;&gt; 0 \quad \text{因此} \<br>\nabla f(x_k)^T \cdot p_k &amp;&lt; 0<br>\end{align*}<br>$$<br>所以下降方向就是负梯度方向</p><h2 id="关于步长的三个约束条件"><a href="#关于步长的三个约束条件" class="headerlink" title="关于步长的三个约束条件"></a>关于步长的三个约束条件</h2><h3 id="Armijo-Condition"><a href="#Armijo-Condition" class="headerlink" title="Armijo Condition"></a>Armijo Condition</h3><p>假定$p_k$是下降方向，我们令<br>$$\phi(\alpha)&#x3D;f(x_{k+1})&#x3D;f(x_k+\alpha p_k)  $$</p><p>于是</p><p>$$\phi^{‘}(\alpha)&#x3D;\nabla f(x_k+\alpha p_k)^T p_k $$</p><p>$$\phi(0)&#x3D;f(x_k) $$</p><p>$$\phi^{‘}(0)&#x3D;\nabla f_k^{T}p_k $$</p><p>我们想让a取到一个良好的位置，应当满足</p><ul><li><p>必要条件(f序列单调减)<br>$$\phi(\alpha)&lt;\phi(0) $$</p></li><li><p>充分条件</p></li></ul><p>$$\phi(\alpha) \le f(x_k)+c_1\nabla f_k^Tp_k \alpha \<br>c_1 \in (0,1)<br>$$ </p><p><img src="https://www.freeimg.cn/i/2024/08/10/66b772193deed.png" alt="1723298326252.png"></p><p>如图所示，用下方绿线去割出来一两个区间，考虑到凸函数的局部性质，Armijo认为这样的策略可以筛选出较好的a所在的区间</p><h3 id="Glodstein-Condition"><a href="#Glodstein-Condition" class="headerlink" title="Glodstein Condition"></a>Glodstein Condition</h3><p>Glodstein发现Armijo条件总会导致筛选出特别小的a，但是这在数值计算中没有意义，为此他提出了新的筛选方法</p><p><img src="https://www.freeimg.cn/i/2024/08/10/66b775bd70850.png" alt="1723299258745.png"></p><p>$$f(x_k)+(1-c)\nabla f_k^Tp_k\alpha \le \phi(\alpha) \le f(x_k)+c\nabla f_k^Tp_k \alpha<br>\<br>c \in (0,\frac12)<br>$$</p><h3 id="wolfe-condition"><a href="#wolfe-condition" class="headerlink" title="wolfe condition"></a>wolfe condition</h3><p>wolfe综合了上述思想，又考虑到Glodstein的约束条件过于狭窄，在c趋于0.5的时候几乎不留区间，于是最终演化出我们现在通用的筛选标准</p><p>$$\phi(\alpha)\leq f(x_{k})+C_{1}\nabla f_{k}^T p_{k}\alpha  $$</p><p>$$\nabla f_{k+1}^{T}\cdot p_{k}\geq C_{2}\nabla f_{k}^{T}P_{k}$$</p><p>$$C_{1}\in(0,1)\C_{2}\in(C_{1},1)$$</p><p>第二个式子中$\nabla f_{k+1}^{T}$就是函数图像中$\phi(a)$在a处的斜率，这样就不冒进的排除掉了$\alpha$靠近0的一小段区间</p><p><img src="https://www.freeimg.cn/i/2024/08/10/66b7766e6267a.png" alt="1723299435754.png"></p><h2 id="收敛性证明"><a href="#收敛性证明" class="headerlink" title="收敛性证明"></a>收敛性证明</h2><p>记 $x_{k+1}&#x3D;x_k+\alpha_kp_k$ ,我们有以下几点要求，</p><ul><li><p>$\nabla f(x)$满足Lipschitz连续，即$|\nabla f(x)-\nabla f(\hat{x})|\leq L|x-\hat{x}|,\quad\forall x,\hat{x}$    (1)</p></li><li><p>$p_k$是下降方向，即$\nabla f_k^Tp_k&lt; 0$    (2)</p></li><li><p>$\alpha_k$满足wolfe条件，即：<br>$$f_{k+1}&lt;f_k+c_1\alpha_k\nabla f_k^Tp_k  \quad (3)$$<br>$$\nabla f_{k+1}^Tp_k\geq c_2\nabla f_k^Tp_k  \quad (4)$$</p></li></ul><p>这几点要求对大多数优化问题来说都是比较容易满足的。在这样的已知条件下，我们可以推导出一个重要的结论:Zoutendijk条件</p><p><strong>Proof</strong>       </p><p>由(4)<br>$$(\nabla f_{k+1}-\nabla f_k)^Tp_k\geq(c_2-1)(\nabla f_k^Tp_k)  \quad (5)$$<br>又由李普希兹连续条件可得<br>$$|\nabla f_{k+1}-\nabla f_k|\leq\alpha_kL|p_k|$$<br>$$|\nabla f_{k+1}-\nabla f_k||p_k|\leq\alpha_kL|p_k|^2$$<br>$$(\nabla f_{k+1}-\nabla f_k)^Tp_k\leq\alpha_kL|p_k|^2   \quad (6)$$</p><p>联立（5）,（6）可得<br>$$\alpha_k\geq\frac{c_2-1}{L}\frac{\nabla f_k^Tp_k}{\left|p_k\right|^2}$$<br>代入（3）（注意到$\alpha_k\nabla f_k^Tp_k&lt;0$）<br>$$f_{k+1}\leq f_k+c_1\frac{c_2-1}{L}\frac{\left(\nabla f_k^Tp_k\right)^2}{\left|p_k\right|^2}$$<br>$$f_k-f_{k+1}\geq c\cos^2\theta_k|\nabla f_k|^2 \quad  c&#x3D;c_1\frac{1-c_2}{L}&gt;0$$<br>两边累加可得<br>$$f_0-f_{k+1}\geq c\Sigma_{j&#x3D;0}^k\cos^2\theta_j|\nabla f_j|^2$$<br>因为f有下界，因此左边收敛，那么由数列和的收敛判断，必然有<br>$$\lim_{k\to\infty}\cos^2\theta_k|\nabla f_k|^2&#x3D;0$$</p><p>上面我们已经证明了在一定条件下，可以推导出Zoutendijk条件：<br>$$\lim_{k\to\infty}\cos^2\theta_k|\nabla f_k|^2&#x3D;0$$<br> 更进一步，如果能够证明<br>$$\cos\theta_k\geq\delta&gt;0,\forall k$$</p><p>那么显然要想仍然满足Zoutendijk条件，则只能要求$\lim_{k\to\infty}|\nabla f_k|&#x3D;0$ ,从而证明了收敛性。对于最速下降方向$p_k&#x3D;-\nabla f_k$,天然的$\cos\theta_k&#x3D;1$,则自然满足收敛性。</p><h2 id="收敛速度"><a href="#收敛速度" class="headerlink" title="收敛速度"></a>收敛速度</h2><p>记$x^{*}$为局部的最优解</p><h3 id="Q收敛速度"><a href="#Q收敛速度" class="headerlink" title="Q收敛速度"></a>Q收敛速度</h3><h4 id="次线性收敛"><a href="#次线性收敛" class="headerlink" title="次线性收敛"></a>次线性收敛</h4><p>$$\lim_{k\to\infty}\frac{\left|x_{k+1}-x^{<em>}\right|}{\left|x_{k}-x^{</em>}\right|}&#x3D;1$$</p><h4 id="线性收敛"><a href="#线性收敛" class="headerlink" title="线性收敛"></a>线性收敛</h4><p>$$\frac{\parallel x_{k+1}-x^{<em>}\parallel}{\parallel x_{k}-x^{</em>}\parallel}\leq a\in(0,1)$$</p><h4 id="超线性收敛"><a href="#超线性收敛" class="headerlink" title="超线性收敛"></a>超线性收敛</h4><p>$$\lim_{k\to\infty}\frac{\parallel x_{k+1}-x^{<em>}\parallel}{\parallel x_{k}-x^{</em>}\parallel}&#x3D;0$$</p><h4 id="二次收敛"><a href="#二次收敛" class="headerlink" title="二次收敛"></a>二次收敛</h4><p>$$\frac{|x_{k+1}-x^{<em>}|}{|x_{k}-x^{</em>}|^{2}}\leq a\in(0,+\infty)$$</p><h3 id="R收敛速度（类似于比较收敛）"><a href="#R收敛速度（类似于比较收敛）" class="headerlink" title="R收敛速度（类似于比较收敛）"></a>R收敛速度（类似于比较收敛）</h3><ul><li>$k$充分大</li></ul><p><img src="https://www.freeimg.cn/i/2024/08/10/66b77bd888f03.png" alt="1723300821783.png"></p><p>例子<br>${ \frac 1 k}$ 是Q次线性<br>$2^{-k}$是Q线性<br>$2^{2^{-k}}$是二次线性</p><h1 id="梯度下降法"><a href="#梯度下降法" class="headerlink" title="梯度下降法"></a>梯度下降法</h1><h2 id="关于凸函数性质的理解"><a href="#关于凸函数性质的理解" class="headerlink" title="关于凸函数性质的理解"></a>关于凸函数性质的理解</h2><p>先把所有的结论展示出来</p><p><img src="https://www.freeimg.cn/i/2024/08/11/66b884fe477a6.png" alt="1723368698997.png"></p><p>在数学上，我们应当有这样的直觉:     </p><ul><li>李普希兹连续保证了我们的研究函数有二次上界</li><li>强凸这一性质保证了研究函数大于了一个二次下界</li></ul><p><img src="https://www.freeimg.cn/i/2024/08/11/66b8861948a39.png" alt="1723368982316.png"></p><h3 id="proof-李普希兹连续-二次上界"><a href="#proof-李普希兹连续-二次上界" class="headerlink" title="proof:李普希兹连续-&gt;二次上界"></a>proof:李普希兹连续-&gt;二次上界</h3><p>命题:若$f$可微，$\nabla f$Lipschitz连续，则f有二次上界：</p><p>$$ f(y) \le f(x)+\nabla f(x)^T(y-x)+\frac L2||y-x||^2 $$</p><p>证明: 记 $g(\theta)&#x3D;f(x+\theta (y-x))$<br>原命题变为证明</p><p>$$g(1)-g(0)-\nabla f(x)^T(y-x) \le \frac L2||y-x||^2 $$<br>左边等于<br>$$&#x3D;\int_{0}^{1}g^{\prime}(\theta)d\theta-\int_{0}^{1}\nabla f(x)^{T}(y-x)d\theta $$</p><p>$$&#x3D;\int_{0}^{1}\left(\nabla f(x+\theta(y-x))^{T}\cdot(y-x)-\nabla f(x)^{T}(y-x))d\theta\right.$$</p><p>$$&#x3D;\int_{0}^{1}\left(\nabla f\left(x+\theta\left(y-x\right)\right)-\nabla f\left(x\right)\right)^{T}\cdot\left(y-x\right)d\theta .\\leq\int_{0}^{1}|\nabla f\left(x+\theta\left(y-x\right)\right)-\nabla f\left(x\right)|\cdot|y-x|d\theta .$$</p><p>$$\leq\int_{0}^{1}L||\theta(y-x)||\cdot||y-x||d\theta$$</p><p>$$&#x3D; \frac L2||y-x||^2 $$</p><p>证毕</p><h2 id="凸函数-梯度下降法收敛性分析"><a href="#凸函数-梯度下降法收敛性分析" class="headerlink" title="凸函数:梯度下降法收敛性分析"></a>凸函数:梯度下降法收敛性分析</h2><p>先引入一种求解$\alpha$最小上界的思路<br><img src="https://www.freeimg.cn/i/2024/08/11/66b8b77e3c439.png" alt="1723381624816.png"></p><p>回到算法本身</p><p>x的更新公式为<br>$$x_{k+1}&#x3D;x_k-\alpha_k\nabla f(x_k)$$<br>根据二次上界不等式可得<br>$$\begin{aligned}<br>f_{k+1}&amp; &#x3D;f\left(x_k-\alpha\nabla f(x_k)\right) \<br>&amp;\leq f(x_k)-\alpha|\nabla f(x_k)|^2+\frac{L\alpha^2}2|\nabla f(x_k)|^2 \<br>&amp;&#x3D;f(x_k)-\alpha\left(1-\frac{\alpha L}2\right)|\nabla f(x_k)|^2<br>\end{aligned}$$</p><p>由凸函数的性质可知:$f^*&gt;f(x_k)-\nabla f(x_k)^\top\left(x_k-x^*\right)$</p><p><img src="https://www.freeimg.cn/i/2024/08/11/66b8ad09e8239.png" alt="1723378950582.png"></p><p>由于$\alpha\in\left(0,\frac1L\right)$,则</p><p>$$\begin{aligned}</p><p>f_{k+1}&amp; \leq f(x_k)-\frac\alpha2|\nabla f(x_k)|^2 \<br>&amp;\leq f^*+\nabla f(x_k)^\top\left(x_k-x^<em>\right)-\frac\alpha2|\nabla f(x_k)|^2 \<br>&amp;&#x3D;f^</em>+\frac1{2\alpha}(2\alpha \nabla f(x_k)^\top\left(x_k-x^<em>\right)-\alpha^2|\nabla f(x_k)|^2-|x_k-x^</em>|^2+|x_k-x^<em>|^2)              \<br>&amp;&#x3D;f^</em>+\frac1{2\alpha}\left(|x_k-x^<em>|^2-|x_k-x^</em>-\alpha\nabla f(x_k)|^2\right) \<br>&amp;&#x3D;f^*+\frac1{2\alpha}{\left(|x_k-x^<em>|^2-|x_{k+1}-x^</em>|^2\right)}<br>\end{aligned}$$</p><p>进一步有<br>$$f_{k+1}-f^*&#x3D;\frac1{2\alpha}\left(|x_k-x^<em>|^2-|x_{k+1}-x^</em>|^2\right)$$<br>$$\begin{gathered}<br>\sum_{k&#x3D;0}^n(f_{k+1}-f^*) \leq\frac1{2\alpha}\big(|x_0-x^<em>|^2-|x_{k+1}-x^</em>|^2\big) \<br>&#x3D;\frac1{2\alpha}|x_0-x^*|^2<br>\end{gathered}$$</p><p>由于$f_k$单调下降，因此<br>$$f_{n+1}-f^<em>\leq\frac1{n+1}\sum_{k&#x3D;0}^n(f_{k+1}-f^</em>)\leq\frac1{2(n+1)\alpha}|x_0-x^<em>|^2$$<br>算法使得以$O(\frac 1k)$收敛到$f^</em>$</p><h2 id="重要的引理-白老爹定理"><a href="#重要的引理-白老爹定理" class="headerlink" title="重要的引理:白老爹定理"></a>重要的引理:白老爹定理</h2><p><img src="https://www.freeimg.cn/i/2024/08/11/66b8b6f2532d5.png" alt="1723381485370.png"></p><h2 id="强凸函数应用梯度下降法的收敛性分析"><a href="#强凸函数应用梯度下降法的收敛性分析" class="headerlink" title="强凸函数应用梯度下降法的收敛性分析"></a>强凸函数应用梯度下降法的收敛性分析</h2><ul><li>$f$有下界，m-强凸，可微</li><li>$\nabla f$李普希兹连续</li><li>$\alpha \in (0,\frac{2}{L+m})$</li></ul><p>则$x_k$Q线性收敛到$x^*$</p><p>$$||x_{k+1}-x^{<em>}||^{2}&#x3D;||x_{k}-\alpha \nabla f(x_{k})-x^{</em>}||^{2}$$<br>$$&#x3D;|x_{k}-x^{<em>}|^{2}-2\alpha\nabla f(x_{k})^{T}(x_{k}-x^{</em>})+\alpha^{2}|\nabla f(x_{k})|^{2}$$<br>$$&#x3D;||x_{k}-x^{<em>}||^{2}-2\alpha(\nabla f(x_{k})-\nabla f(x^{</em>}))^{T}(x_{k}-x^{<em>})+\alpha^{2}||\nabla f(x_{k})||^{2}$$<br>现在的任务就是为$(\nabla f(x_{k})-\nabla f(x^{</em>}))^{T}(x_{k}-x^{*})$寻找一个合适的下界</p><p><img src="https://www.freeimg.cn/i/2024/08/11/66b8c815adc19.png" alt="1723385873427.png"></p><p>带入原始的式子</p><p><img src="https://www.freeimg.cn/i/2024/08/11/66b8c85ca3b8d.png" alt="1723385944849.png"></p><h2 id="梯度下降法的缺点-在病态条件下收敛过慢"><a href="#梯度下降法的缺点-在病态条件下收敛过慢" class="headerlink" title="梯度下降法的缺点:在病态条件下收敛过慢"></a>梯度下降法的缺点:在病态条件下收敛过慢</h2><p><img src="https://www.freeimg.cn/i/2024/08/11/66b8cb1d6c8b1.png" alt="1723386647669.png"></p>]]></content>
    
    
    <categories>
      
      <category>机器学习</category>
      
      <category>白板推导</category>
      
    </categories>
    
    
    <tags>
      
      <tag>机器学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ng-梯度下降</title>
    <link href="/2025/03/21/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/ng%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0week1/"/>
    <url>/2025/03/21/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/ng%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0week1/</url>
    
    <content type="html"><![CDATA[<h1 id="ng-机器学习week1"><a href="#ng-机器学习week1" class="headerlink" title="ng-机器学习week1"></a>ng-机器学习week1</h1><h2 id="监督学习"><a href="#监督学习" class="headerlink" title="监督学习"></a>监督学习</h2><p>通过展示数据和正确输出来训练的学习方法，<br>监督学习算法：回归，分类（预测结果0&#x2F;1）  </p><h2 id="无监督学习"><a href="#无监督学习" class="headerlink" title="无监督学习"></a>无监督学习</h2><p>聚类算法：坐标图上数据并不知道类别，但是明显有分类–寻找集群<br>数据集中第i对数据记作<br>$$(x^{(i)},y^{(i)}) $$<br>用线性函数$f(x)$拟合y x关系<br>$$f(x)&#x3D;wx+b $$</p><h2 id="代价函数"><a href="#代价函数" class="headerlink" title="代价函数"></a>代价函数</h2><p>引入这样一个函数<br>$$J(w,b)&#x3D;\frac{1}{2m} \sum_{i&#x3D;1}^{m} (\hat{y^{(i)} }-y^{(i)}  )^{2 }  $$<br>其中1&#x2F;2是为了计算方便引入的，该式又可以写为<br>$$ J(w,b)&#x3D;\frac{1}{2m} \sum_{i&#x3D;1}^{m} (f_{w,x}(x^{(i)} )-y^{(i)}  )^{2 }$$<br>线性回归的目的就是寻找合适的w b使得J最小     </p><h2 id="梯度下降"><a href="#梯度下降" class="headerlink" title="梯度下降"></a>梯度下降</h2><p>我们希望通过不停地更新$w,b$找到$J$的局部最小值，方法是让J沿着梯度方向按照一定速度下降，也即<br>$$w &#x3D;w -\alpha \frac{\partial }{\partial w}J(w,b) $$<br>$$  b &#x3D;b -\alpha \frac{\partial }{\partial b}J(w,b) $$<br>其中$\alpha$称作学习率，一般是0到1之间的一个数，用于控制学习的速度。总之，我们希望在不停地更新和迭代中达到算法收敛，需要注意的是，$w,b$必须同时更新，算法语言中体现为这样<br>$$ tempw &#x3D;w -\alpha \frac{\partial }{\partial w}J(w,b)$$<br>$$ tempb &#x3D;b -\alpha \frac{\partial }{\partial b}J(w,b)$$<br>$$w&#x3D;tempw   ,   b&#x3D;tempb $$<br>事实上，越是接近最小值点，偏导数越小，w b每次更新幅度也越小，直到收敛。       </p><h2 id="线性回归下的梯度下降"><a href="#线性回归下的梯度下降" class="headerlink" title="线性回归下的梯度下降"></a>线性回归下的梯度下降</h2><p>对线性回归下的平方残差和函数$J(w,b)$求偏导数，容易得到<br>$$\frac{\partial }{\partial w} J(w,b)&#x3D;\frac{1}{m} \sum_{i&#x3D;1}^{m} (f_{w,b}(x^{(i)} )-y^{(i)} )x^{(i)} $$<br>$$\frac{\partial }{\partial w} J(w,b)&#x3D;\frac{1}{m} \sum_{i&#x3D;1}^{m} (f_{w,b}(x^{(i)} )-y^{(i)} ) $$         </p><h2 id="作业实现"><a href="#作业实现" class="headerlink" title="作业实现"></a>作业实现</h2><p>给定一个txt文档，里面存有训练用数据集，现在用Python程序线性回归。<br> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">import</span> pandas <span class="hljs-keyword">as</span> pd<br><span class="hljs-keyword">from</span> sklearn.linear_model <span class="hljs-keyword">import</span> LinearRegression<br><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br><br><span class="hljs-comment"># 读取txt文件中的数据 需要把txt文件放到py脚本同一目录下</span><br>data_path = <span class="hljs-string">&#x27;data/ex1data1.txt&#x27;</span><br>data = pd.read_csv(data_path, header=<span class="hljs-literal">None</span>)<br>X = data.iloc[:, <span class="hljs-number">0</span>].values.reshape(-<span class="hljs-number">1</span>, <span class="hljs-number">1</span>)  <span class="hljs-comment"># 特征值</span><br>y = data.iloc[:, <span class="hljs-number">1</span>].values.reshape(-<span class="hljs-number">1</span>, <span class="hljs-number">1</span>)  <span class="hljs-comment"># 目标值</span><br><br><span class="hljs-comment"># 为了简单起见，我们使用scikit-learn的LinearRegression类，</span><br><span class="hljs-comment"># 它内部实现了最小二乘法，而不是手动实现梯度下降。</span><br><br><span class="hljs-comment"># 使用scikit-learn的LinearRegression</span><br>reg = LinearRegression()<br>reg.fit(X, y)<br><br><span class="hljs-comment"># 输出模型的系数</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Coefficients: \n&#x27;</span>, reg.coef_)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Intercept: \n&#x27;</span>, reg.intercept_)<br><br><span class="hljs-comment"># 绘制拟合的直线和原始数据点</span><br>plt.scatter(X, y, color=<span class="hljs-string">&#x27;blue&#x27;</span>)<br>plt.plot(X, reg.predict(X), color=<span class="hljs-string">&#x27;red&#x27;</span>, linewidth=<span class="hljs-number">2</span>)<br>plt.xlabel(<span class="hljs-string">&#x27;Feature&#x27;</span>)<br>plt.ylabel(<span class="hljs-string">&#x27;Target&#x27;</span>)<br>plt.show()                           <br></code></pre></td></tr></table></figure><br>现在我们并不希望止步于此，我们企望自己手写随机梯度下降法。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">import</span> pandas <span class="hljs-keyword">as</span> pd<br><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br><br><span class="hljs-comment"># 读取txt文件中的数据 需要把txt文件放到py脚本同一目录下</span><br>data_path = <span class="hljs-string">&#x27;data/ex1data1.txt&#x27;</span><br>data = pd.read_csv(data_path, header=<span class="hljs-literal">None</span>)<br>x = data.iloc[:, <span class="hljs-number">0</span>].values.reshape(-<span class="hljs-number">1</span>, <span class="hljs-number">1</span>)  <span class="hljs-comment"># 特征值</span><br>y = data.iloc[:, <span class="hljs-number">1</span>].values.reshape(-<span class="hljs-number">1</span>, <span class="hljs-number">1</span>)  <span class="hljs-comment"># 目标值</span><br><br><span class="hljs-comment"># 为了简单起见，我们使用scikit-learn的LinearRegression类，</span><br><span class="hljs-comment"># 它内部实现了最小二乘法，而不是手动实现梯度下降。</span><br><span class="hljs-comment"># 手动实现随机梯度下降法</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">grad_down</span>(<span class="hljs-params">x,y,w,b,num,alpha</span>):<br>    cost_history = []<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(num):<br>        predict_x = w * x + b<br>        error = predict_x - y<br>        dw = <span class="hljs-number">1</span> / <span class="hljs-built_in">len</span>(x) * np.<span class="hljs-built_in">sum</span>(error*x)<br>        db = <span class="hljs-number">1</span> / <span class="hljs-built_in">len</span>(x) * np.<span class="hljs-built_in">sum</span>(error)<br>        w = w - dw * alpha<br>        b = b - db * alpha<br>        cost = (<span class="hljs-number">1</span> / <span class="hljs-number">2</span> * <span class="hljs-built_in">len</span>(x)) * np.<span class="hljs-built_in">sum</span>(error ** <span class="hljs-number">2</span>)<br>        cost_history.append(cost)<br>    <span class="hljs-keyword">return</span> w,b,cost_history<br>init_b=<span class="hljs-number">0</span><br>init_w=<span class="hljs-number">0</span>;<br>final_w,final_b,cost_history=grad_down(x,y,init_w,init_b,<span class="hljs-number">10000</span>,<span class="hljs-number">0.01</span>)<br>predict_x=final_w*x+final_b<br><span class="hljs-comment"># 输出模型的系数</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Coefficients: \n&#x27;</span>, final_w)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Intercept: \n&#x27;</span>, final_b)<br><br><span class="hljs-comment"># 绘制拟合的直线和原始数据点</span><br>plt.scatter(x, y, color=<span class="hljs-string">&#x27;blue&#x27;</span>)<br>plt.plot(x, predict_x, color=<span class="hljs-string">&#x27;red&#x27;</span>, linewidth=<span class="hljs-number">2</span>)<br>plt.xlabel(<span class="hljs-string">&#x27;Feature&#x27;</span>)<br>plt.ylabel(<span class="hljs-string">&#x27;Target&#x27;</span>)<br>plt.show()<br><span class="hljs-comment">## 绘制收敛情况</span><br>plt.plot(cost_history)<br>plt.xlabel(<span class="hljs-string">&#x27;training_num&#x27;</span>)<br>plt.ylabel(<span class="hljs-string">&#x27;cost&#x27;</span>)<br>plt.title(<span class="hljs-string">&#x27;cost-training_times&#x27;</span>)<br>plt.show()<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>机器学习</category>
      
      <category>ng机器学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>机器学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ng-逻辑回归</title>
    <link href="/2025/03/21/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/ng%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0week3/"/>
    <url>/2025/03/21/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/ng%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0week3/</url>
    
    <content type="html"><![CDATA[<p><strong>声明：取机器学习中约定俗成的写法，下文中的 $log$即$ln$</strong></p><h2 id="逻辑回归"><a href="#逻辑回归" class="headerlink" title="逻辑回归"></a>逻辑回归</h2><p>y值仅有两种结果0&#x2F;1，我们要做的是分类数据。(二元分类问题)<br>引入sigmoid函数<br>$$g(z)&#x3D;\frac1{1+e^{-z}}\quad{0&lt;g(z)&lt;1} $$<br>考虑到矢量性，我们引入这样一个逻辑回归函数<br>$$f_{\overrightarrow{\mathrm{w}},b}(\vec{\mathrm{x}})&#x3D;g(\underbrace{\mathrm{w}\cdot\vec{\mathrm{x}}+b}_{\mathbb{z}})&#x3D;\frac1{1+e^{-(\vec{\mathrm{w}}\cdot\vec{\mathrm{x}}+b)}} $$<br>我们可以将这个函数理解为分类的概率，也就是<br>$$f_{\overrightarrow{\mathrm{w}},b}(\vec)&#x3D;P({y&#x3D;1|\vec;\vec,b}) $$<br>自然地我们要考虑决策边界的问题，也就说我们认为P大于多少时，事件为1，小于多少时事件为0。一个自然地想法是以0.5为边界，由于恰好z&#x3D;0为sigmoid&#x3D;0.5的点，因此我们认为这样的关系式成立。<br>$$\begin{aligned}\vec{\mathrm{w}}\cdot\vec{\mathrm{x}}+b&amp;\geq0\\widehat{y}&amp;&#x3D;1\end{aligned} $$<br>而曲线（直线）<br>$$z&#x3D;\overrightarrow{\mathrm{w}}\cdot{\mathrm{\vec{x}}}+b&#x3D;0 $$<br>称为决策边界（线性决策边界）<br>自然，并非所有决策边界都是线性的，通过将x1,x2等坐标非线性化，可以拟合出非线性决策边界。</p><h2 id="代价函数"><a href="#代价函数" class="headerlink" title="代价函数"></a>代价函数</h2><p>我们如果还使用之前的残差平方和代价函数，会失望的发现这个函数歪歪扭扭，很容易陷入某个局部最优解，为此，考虑到sigmoid函数的性质，我们引入这样一个新的代价函数<br>$$L\big(f_{\vec{w},b}\big(\vec{x}^{(i)}\big),y^{(i)}\big)&#x3D;\begin{cases}\quad-\log\big(f_{\vec{w},b}\big(\vec{x}^{(i)}\big)\big)&amp;y^{(i)}&#x3D;1\-\log\big(1-f_{\vec{w},b}\big(\vec{x}^{(i)}\big)\big)&amp;y^{(i)}&#x3D;0\end{cases} $$<br>这个函数在数学上的感觉是很正确，很合理的。<br>我们还可以采用一种更巧妙的写法来避免分类讨论<br>$$L\big({f_{\vec{w},b}\big(\vec{x}^{(i)}\big)},y^{(i)}\big)&#x3D;-y^{(i)}\mathrm{log}\bigg({f_{\vec{w},b}\big(\vec{x}^{(i)}\big)}\bigg)-(1-y^{(i)})\mathrm{log}\bigg(1-{f_{\vec{w},b}\big(\vec{x}^{(i)}\big)}\bigg) $$<br>求和<br>$$J&#x3D;\frac1m\sum_{i&#x3D;1}^m[L({f_{\vec{w},b}(\vec{x}^{(i)}),y^{(i)}})] $$<br>$$&#x3D;-\frac{1}{m}\sum_{i&#x3D;1}^{m}\left[y^{(i)}\mathrm{log}\left({f_{\vec{v},b}(\vec{x}^{(i)})}\right)+(1-y^{(i)})\mathrm{log}\left(1-{f_{\vec{v},b}(\vec{x}^{(i)})}\right)\right] $$<br>(最大似然估计)</p><h2 id="实现梯度下降"><a href="#实现梯度下降" class="headerlink" title="实现梯度下降"></a>实现梯度下降</h2><p>我们依然通过迭代这两步来实现w b的更新<br>$$\begin{aligned}<br>&amp;w_{j}&#x3D;w_{j}-\alpha\frac{\partial}{\partial w_{j}}J({\vec{w}},b) \<br>&amp;b&#x3D;b-\alpha\frac{\partial}{\partial b}J({\overrightarrow{w}},b)<br>\end{aligned} $$<br>最终得出<br>$$ w_{j} &#x3D;w_{j} -\alpha \frac{1}{m} \sum_{i&#x3D;1}^{m}(f_{w,x}( \overrightarrow{x^{(i)}})-\overrightarrow{y}^{(i)}  )x_{j} ^{(i)}$$<br>同理可得<br>$$ b &#x3D;b -\alpha \frac{1}{m} \sum_{i&#x3D;1}^{m}(f_{w,x}( \overrightarrow{x^{(i)}})-\overrightarrow{y}^{(i)}  ) $$<br>有趣的是，这与week1的形式一致，只不过f已经不是原来的线性函数了。</p><h2 id="过拟合问题与解决"><a href="#过拟合问题与解决" class="headerlink" title="过拟合问题与解决"></a>过拟合问题与解决</h2><p>如果预测函数拟合出了不该有的特征（仅仅几个数据局部特征），则称之为过拟合，为了惩罚导致过拟合的wi(通常是因为他们过大)，我们尝试引入惩罚项，这就是正则化方法。<br>将代价函数改写为<br>$$\begin{aligned}J(\vec{\mathbf{w}},b)&amp;&#x3D;\quad\frac1{2m}\sum_{i&#x3D;1}^m(f_{\vec{\mathbf{w}},b}(\vec{\mathbf{x}}^{(i)})-y^{(i)})^2+\frac\lambda{2m}\sum_{j&#x3D;1}^nw_j^2\end{aligned} $$<br>原有部分决定了拟合程度有多高，而增加的项旨在keep wj small，通过调整lamda的值来确保二者微妙的平衡。</p><h4 id="线性回归的梯度下降更新为"><a href="#线性回归的梯度下降更新为" class="headerlink" title="线性回归的梯度下降更新为"></a>线性回归的梯度下降更新为</h4><p>$$\begin{gathered}<br>\begin{aligned}\&amp;w_j&#x3D;w_j-\alpha\left[\frac1m\sum_{i&#x3D;1}^m\left[(f_{\overline{w},b}(\vec{x}^{(i)})-y^{(i)})x_j^{(i)}\right]+\frac\lambda mw_j\right]\end{aligned} \<br>b&#x3D;b-\alpha\frac{1}{m}{\sum_{i&#x3D;1}^{m}(f_{\vec{w},b}\big(\vec{x}^{(i)}\big)-y^{(i)}\big)}<br>\end{gathered} $$</p><h4 id="逻辑回归-1"><a href="#逻辑回归-1" class="headerlink" title="逻辑回归"></a>逻辑回归</h4><p>$$J(\vec{w},b)&#x3D;-\frac{1}{m}\sum_{i&#x3D;1}^{m}\left[y^{(i)}\mathrm{log}\Big(f_{\vec{w},b}\big(\vec{x}^{(i)}\big)\Big)+\big(1-y^{(i)}\big)\mathrm{log}\Big(1-f_{\vec{w},b}\big(\vec{x}^{(i)}\big)\Big)\right]+\frac{\lambda}{2m}\sum_{j&#x3D;1}^{n}w_{j}^{2} $$</p><h2 id="作业（逻辑回归）"><a href="#作业（逻辑回归）" class="headerlink" title="作业（逻辑回归）"></a>作业（逻辑回归）</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">from</span> sklearn.model_selection <span class="hljs-keyword">import</span> train_test_split<br><span class="hljs-keyword">from</span> sklearn.preprocessing <span class="hljs-keyword">import</span> StandardScaler<br><span class="hljs-keyword">from</span> sklearn.linear_model <span class="hljs-keyword">import</span> LogisticRegression<br><span class="hljs-keyword">import</span> pandas <span class="hljs-keyword">as</span> pd<br><br>data_path=<span class="hljs-string">&#x27;data/week3ex1data.txt&#x27;</span><br>data=pd.read_csv(data_path,header=<span class="hljs-literal">None</span>)<br>X=data.iloc[:,:<span class="hljs-number">2</span>].values<br>y=data.iloc[:,<span class="hljs-number">2</span>].values<br><br><span class="hljs-comment"># 划分数据集为训练集和测试集</span><br>X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=<span class="hljs-number">0.1</span>, random_state=<span class="hljs-number">4</span>)<br><br><span class="hljs-comment"># 数据标准化（对于逻辑回归通常是好的做法，但不是必须的）</span><br>scaler = StandardScaler()<br>X_train = scaler.fit_transform(X_train)<br>X_test = scaler.transform(X_test)<br><br><span class="hljs-comment"># 创建逻辑回归模型并训练</span><br>model = LogisticRegression(solver=<span class="hljs-string">&#x27;lbfgs&#x27;</span>, max_iter=<span class="hljs-number">1000</span>)  <span class="hljs-comment"># 使用&#x27;lbfgs&#x27;求解器，并增加最大迭代次数以确保收敛</span><br>model.fit(X_train, y_train)<br><br><span class="hljs-comment"># 在测试集上进行预测</span><br>y_pred = model.predict(X_test)<br><br><span class="hljs-comment"># 打印预测结果和实际结果进行对比（可选）</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Predic:&quot;</span>, y_pred)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Actual:&quot;</span>, y_test)<br><br><span class="hljs-comment"># 对于新的数据点进行预测（你需要先对其进行相同的标准化处理）</span><br>new_data = [[<span class="hljs-number">1.5</span>, <span class="hljs-number">2.5</span>]]  <span class="hljs-comment"># 示例新数据点，你需要替换为实际的值</span><br>new_data_scaled = scaler.transform(new_data)<br>new_prediction = model.predict(new_data_scaled)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Prediction for new data:&quot;</span>, new_prediction)<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>机器学习</category>
      
      <category>ng机器学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>机器学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>支持向量机</title>
    <link href="/2025/03/21/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E6%9C%BA/"/>
    <url>/2025/03/21/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E6%9C%BA/</url>
    
    <content type="html"><![CDATA[<h1 id="基本思想"><a href="#基本思想" class="headerlink" title="基本思想"></a>基本思想</h1><p>支持向量机的基本思想就是用一个超平面来划分一群点，达到二分类效果。寻找超平面过程中。我们使用最小化间隔的思想，使得svm具有鲁棒性。</p><h1 id="硬间隔SVM"><a href="#硬间隔SVM" class="headerlink" title="硬间隔SVM"></a>硬间隔SVM</h1><p>欲分类点记为${(x_i,y_i)}_{i&#x3D;1}^N$共N个，预测结果$y_i$取值为0，1 我们的判别模型可以表示为<br>$$f(w)&#x3D;sign(w^Tx+b) $$<br>其中$w^Tx+b&#x3D;0$就是1划分所用的超平面，因此约束条件可以表示为<br>$$y_i(w^Tx+b)&gt;0 $$</p><p><img src="https://www.freeimg.cn/i/2024/08/08/66b4b7cbc40f9.jpg" alt="最小距离"></p><p>由上图可以看到，对称地，总能找到连两个点距离超平面最近，我们的目的就是最大化这个”最小距离”，优化任务记为<br>$$\begin{cases}\max_{w,b}\min\frac{1}{||w||}|w^{T}x_{i}+b|\\s.t.\quad y_{i}(w^{T}x_{i}+b)&gt;0\end{cases}$$<br>化简为<br>$$\begin{cases}\max_{w,b}\min\frac{1}{||w||}y_i(w^{T}x_{i}+b)\\s.t.\quad y_{i}(w^{T}x_{i}+b)&gt;0\end{cases}$$<br>超平面方程为$w^Tx+b&#x3D;0$,可以任意缩放倍数，因此不妨规定$min \ y_i(w^Tx+b)&#x3D;1$<br>原问题化为<br>$$\begin{cases}min, \frac{1}{2}w^Tw\\s.t.\quad y_{i}(w^{T}x_{i}+b)\geq1\end{cases}$$</p><p>由于其约束都是仿射的，因此符合放松的slater条件，问题变为一个纯粹的N个约束的凸优化问题。</p><h1 id="对偶问题"><a href="#对偶问题" class="headerlink" title="对偶问题"></a>对偶问题</h1><p>但是，如果样本数量或维度非常高，直接求解困难甚至不可解，于是需要对这个问题进一步处理。引入 Lagrange 函数：</p><p>$$L(w,b,\lambda)&#x3D;\frac12w^Tw+\sum_{i&#x3D;1}^N\lambda_i(1-y_i(w^Tx_i+b))$$</p><p>原问题为</p><p>$$\begin{cases}min, \frac12 w^Tw\\s.t.\quad 1-y_{i}(w^{T}x_{i}+b)\leq0\end{cases}$$</p><p>可以证明，原问题的等价问题为</p><p>$$\begin{cases}min_{w,b}\max_{\lambda}L(w,b,\lambda_i)\mathrm{<del>}\\\mathrm{</del>}\lambda_i\geq0\end{cases}$$</p><p>交换最小和最大值的符号得到对偶问题：</p><p>$$\max_{\lambda_i}\min_{w,b}L(w,b,\lambda_i)\mathrm{<del>}s.t.\mathrm{</del>}\lambda_i\geq0$$</p><p>由于不等式约束是仿射函数，对偶问题和原问题等价      </p><blockquote><p>引入:原问题和对偶问题满足强对偶关系的充要条件为其满足 KKT 条件：<br>$$\begin{aligned}<br> &amp;\frac{\partial L}{\partial w}&#x3D;0,\frac{\partial L}{\partial b}&#x3D;0 \<br> &amp;\large\lambda_k(1-y_k(w^Tx_k+b))&#x3D;0(slackness complementary) \<br> &amp;\lambda_{i}\geq0 \<br> &amp;1-y_i(w^Tx_i+b)\leq0<br> \end{aligned}$$</p></blockquote><p>利用KKT条件将上述优化问题变为只和$\lambda$有关的优化问题</p><p>$$\frac\partial{\partial b}L&#x3D;0\Rightarrow\sum_{i&#x3D;1}^N\lambda_iy_i&#x3D;0$$</p><p>$$\frac\partial{\partial w}L&#x3D;0\Rightarrow w&#x3D;\sum_{i&#x3D;1}^N\lambda_iy_ix_i$$</p><p>带入原始拉格朗日函数得到</p><p>$$L(w,b,\lambda_i)&#x3D;-\frac12\sum_{i&#x3D;1}^N\sum_{j&#x3D;1}^N\lambda_i\lambda_jy_iy_jx_i^Tx_j+\sum_{i&#x3D;1}^N\lambda_i$$</p><p>问题转化为了对$\lambda$的优化问题</p><p>$$\max_\lambda\boldsymbol{-}\frac12\sum_{i&#x3D;1}^N\sum_{j&#x3D;1}^N\lambda_i\lambda_jy_iy_jx_i^Tx_j+\sum_{i&#x3D;1}^N\lambda_i,\mathrm{<del>}s.t.\mathrm{</del>}\lambda_i\geq0$$</p><p>使用优化手段求解得到$\lambda_i$，进而求解$w$, $b$ ,</p><p>$$\hat{w}&#x3D;\sum_{i&#x3D;1}^N\lambda_iy_ix_i\\hat{b}&#x3D;y_k-w^Tx_k&#x3D;y_k-\sum_{i&#x3D;1}^N\lambda_iy_ix_i^Tx_k,\exists k,1-y_k(w^Tx_k+b)&#x3D;0$$</p><p>容易看出上面的$x_k$就是距离超平面最近的点(向量)，我们把它称之为支持向量，这也是支持向量机名字的由来。而这里也可以看出，互补松弛条件就是说只有支持向量对应的$\lambda_i$为0.</p><h1 id="软间隔SVM"><a href="#软间隔SVM" class="headerlink" title="软间隔SVM"></a>软间隔SVM</h1><p>Hard-margin 的 SVM 只对可分数据可解，如果不可分的情况，我们的基本想法是在损失函数中加入错误分类的可能性。为此我们考虑修正想要min的函数</p><p>$$\begin{cases}min, \frac12 w^Tw+loss \\s.t.\quad 1-y_{i}(w^{T}x_{i}+b)\leq0\end{cases}$$</p><p>loss应当允许错误分类同时使得错误分类最小，为了尽量保持loss可导，直观地想法是</p><p>当$y_i(w^Tx_i+b)&gt;&#x3D;1$,此时为正确分类的情况，那么$loss&#x3D;0$<br>当$y_i(w^Tx_i+b)&lt;1$,此时为错误分类的情况，不妨直接取距离作为loss，也即取$loss&#x3D;1-y_i(w^Tx_i+b)$</p><p>因此loss表示为</p><p>$$loss&#x3D;\sum_{i&#x3D;1}^N\max{0,1-y_i(w^Tx_i+b)}$$</p><p>求和符号中的式子又叫做 Hinge Function。</p><p>优化问题进一步修正为</p><p>$$\begin{cases}min,<br>\frac12w^Tw+C\sum_{i&#x3D;1}^N\max{0,1-y_i(w^Tx_i+b)} \\s.t.\quad 1-y_{i}(w^{T}x_{i}+b)\leq0\end{cases}$$</p><p>这个式子中，常数$C$可以看作允许的错误水平，同时上式为了进一步消除<br>$\max$符号，对数据集中的每一个观测，我们可以认为其大部分满足约束，但是其<br>中部分违反约束，因此这部分约束变成$y_i(w^Tx+b)\geq1-\xi_i$ ,其中<br>$\xi_i&#x3D;1-y_i(w^Tx_i+b)$ ,进一步的修正为：</p><p>$$\begin{cases}min_{w,b}\frac12w^Tw+C\sum_{i&#x3D;1}^N\xi_i \\ s.t.\quad y_i(w^Tx_i+b)\geq1-loss_i,loss_i\geq0\end{cases}$$</p><p>对于正确分类的点，$loss_i&#x3D;0$,约束变为$y_i(w^Tx_i+b)\geq1-0$<br>对于错误分类的点，$loss_i&#x3D;1-y_i(w^Tx_i+b)$，约束恒成立，相当于没有约束。</p><h1 id="一些凸分析杂谈与核方法"><a href="#一些凸分析杂谈与核方法" class="headerlink" title="一些凸分析杂谈与核方法"></a>一些凸分析杂谈与核方法</h1><p>latex有空再敲，太多了太多了</p><p>主要就是在讲一些十分凸分析的内容，比如</p><ul><li>凸优化+slater条件是强对偶关系的充要条件</li><li>slater条件有放松版本，就是对于仿射形式的约束条件的放松</li><li>从几何上可以直观感受到强弱对偶关系之间对的联系</li><li>从几何上可以简单的感受到KKT条件</li></ul>]]></content>
    
    
    <categories>
      
      <category>机器学习</category>
      
      <category>白板推导</category>
      
    </categories>
    
    
    <tags>
      
      <tag>机器学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>线性分类</title>
    <link href="/2025/03/21/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E7%BA%BF%E6%80%A7%E5%88%86%E7%B1%BB/"/>
    <url>/2025/03/21/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E7%BA%BF%E6%80%A7%E5%88%86%E7%B1%BB/</url>
    
    <content type="html"><![CDATA[<h1 id="综述：线性分类包括什么？"><a href="#综述：线性分类包括什么？" class="headerlink" title="综述：线性分类包括什么？"></a>综述：线性分类包括什么？</h1><p>对于分类任务，线性回归模型就无能为力了，但是我们可以在线性模型的函数进行后再加入一层激活函数，下面总结了常见的线性分类模型</p><p><img src="https://www.freeimg.cn/i/2024/08/05/66b0aba23af5e.png" alt="1722854281733.png"></p><p><img src="https://www.freeimg.cn/i/2024/08/05/66b0aba1dbb3c.png" alt="1722854303847.png"></p><p>下面我们依次介绍几种线性分类模型</p><h1 id="硬输出：感知机"><a href="#硬输出：感知机" class="headerlink" title="硬输出：感知机"></a>硬输出：感知机</h1><p>我们要解决的问题是：二分类$N$个样本点$(x_{i},y_{i})$，其中$x_{i}\in R^p$<br>引入：<br>$$sign(a)&#x3D;\left{\begin{matrix}+1,a\geq0\-1,a&lt;0\end{matrix}\right.$$</p><p>感知机的思路是把线性回归的结果填充到激活函数中：<br>$$f(x)&#x3D;sign(w^Tx)$$</p><p>这样$f(x)$即为预测结果。<br>此时，问题变为如何求解$w$。我们使用梯度下降的策略，那么自然的需要引入loss函数。为了引入合适的loss函数，做一些必要的讨论   </p><p>我们考虑一个被正确分类的点$(x_i,y_i)$，若 $w^Tx_i&gt;0$，则 $y_i&#x3D;+1$,若$w^Tx_i&lt;0$，则 $y_i&#x3D;-1$,因此对于正确分类的点$(x_i,y_i)$，总有$y_iw^Tx_i&gt;0$      </p><p><img src="https://www.freeimg.cn/i/2024/08/05/66b0ac3260027.png" alt="1722854448587.png"></p><p>综上所述，我们引入形如下式的loss函数<br>$$ L(w)&#x3D;\sum_{x_i\in\mathcal{D}_{wrong}}-y_iw^Tx_i $$</p><p>应用梯度下降法可得</p><p>$$\frac\partial{\partial w}L(w)&#x3D;\sum_{x_i\in\mathcal{D}_{wrong}}-y_ix_i$$</p><p>$$w^{t+1}\leftarrow w^t+\lambda y_ix_i$$</p><h1 id="硬输出：线性判别"><a href="#硬输出：线性判别" class="headerlink" title="硬输出：线性判别"></a>硬输出：线性判别</h1><p>在 LDA 中，我们的基本想法是选定一个方向，将试验样本顺着这个方向投影，投影后的数据需要满足两个条件，从而可以更好地分类：</p><ol><li>相同类内部的试验样本距离接近。</li><li>不同类别之间的距离较大。<br><img src="https://www.freeimg.cn/i/2024/08/05/66b0c31f97bac.png" alt="1722860317231.png"></li></ol><p>引入x顺着w方向的投影(有正有负的标量)</p><p>$$z&#x3D;w^T\cdot x(&#x3D;|w|\cdot|x|\cos\theta)$$</p><p>假设属于两类$C_1,C_2$的样本点数量是$N_1,N_2$,我们采用方差矩阵来表征两个类内的总体分布</p><p>$$\begin{aligned}<br>&amp;C_1:Var_z[C_1] &#x3D;\frac1{N_1}\sum_{i&#x3D;1}^{N_1}(z_i-\overline{z_{c1}})(z_i-\overline{z_{c1}})^T \<br>&amp;&#x3D;\frac1{N_1}\sum_{i&#x3D;1}^{N_1}(w^Tx_i-\frac1{N_1}\sum_{j&#x3D;1}^{N_1}w^Tx_j)(w^Tx_i-\frac1{N_1}\sum_{j&#x3D;1}^{N_1}w^Tx_j)^T \<br>&amp;&#x3D;w^T\frac1{N_1}\sum_{i&#x3D;1}^{N_1}(x_i-\overline{x_{c1}})(x_i-\overline{x_{c1}})^Tw \<br>&amp;&#x3D;w^TS_1w \<br>&amp;C_2:Var_z[C_2] &#x3D;\frac1{N_2}\sum_{i&#x3D;1}^{N_2}(z_i-\overline{z_{c2}})(z_i-\overline{z_{c2}})^T \<br>&amp;&#x3D;w^TS_2w<br>\end{aligned}$$</p><p>其中$S_1,S_2$就定义为两个类的方差矩阵，我们想让类内距离小，必然希望两个类的类内距离都是小的，为此定义类内距离函数为<br>$$Var_z[C_1]+Var_z[C_2]&#x3D;w^T(S_1+S_2)w$$</p><p>同时定义类间距离为        </p><p>$$\begin{aligned}<br>(\overline{z_{c1}}-\overline{z_{c2}})^2&amp; &#x3D;(\frac1{N_1}\sum_{i&#x3D;1}^{N_1}w^Tx_i-\frac1{N_2}\sum_{i&#x3D;1}^{N_2}w^Tx_i)^2 \<br>&amp;&#x3D;(w^T(\overline{x_{c1}}-\overline{x_{c2}}))^2 \<br>&amp;&#x3D;w^T(\overline{x_{c1}}-\overline{x_{c2}})(\overline{x_{c1}}-\overline{x_{c2}})^Tw<br>\end{aligned}$$</p><p>用两个值相除作为损失函数，我们要求的$w$就是</p><p>$$\begin{aligned}<br>\hat{w}&#x3D;argmax J(w)&amp; &#x3D;argmax\frac{(\overline{z_{c1}}-\overline{z_{c2}})^2}{Var_z[C_1]+Var_z[C_2]} \<br>&amp;&#x3D;argmax\frac{w^T(\overline{x_{c1}}-\overline{x_{c2}})(\overline{x_{c1}}-\overline{x_{c2}})^Tw}{w^T(S_1+S_2)w} \<br>&amp;&#x3D;\underset{w}{\operatorname*{argmax}}\frac{w^TS_bw}{w^TS_ww}<br>\end{aligned}$$</p><p>显然，我们并不需要知道$w$的具体大小，我们只需要知道$w$的方向即可，对损失函数求导</p><p>$$\frac\partial{\partial w}J(w)&#x3D;0$$</p><p>$$\begin{aligned}&amp;\Longrightarrow S_bw(w^TS_ww)&#x3D;(w^TS_bw)S_ww\&amp;\Longrightarrow w\propto S_w^{-1}S_bw&#x3D;S_w^{-1}(\overline{x_{c1}}-\overline{x_{c2}})(\overline{x_{c1}}-\overline{x_{c2}})^Tw\propto S_w^{-1}(\overline{x_{c1}}-\overline{x_{c2}})\end{aligned}$$</p><p>$S_w^{-1}(\overline{x_{c1}}-\overline{x_{c2}})$就是$w$的方向，再进行归一化即可。<br>$w^Tx&#x3D;0$就是我们的决策边界</p><h1 id="软输出：逻辑回归"><a href="#软输出：逻辑回归" class="headerlink" title="软输出：逻辑回归"></a>软输出：逻辑回归</h1><p>对于一次观测，获得分类$y$的概率为(假定$C_1&#x3D;1,C_2&#x3D;0$ ):<br>$$p(y|x)&#x3D;p_1^yp_0^{1-y}$$<br>那么对于$N$次独立全同的观测 MLE为：<br>$$\hat{w}&#x3D;argmax_wJ(w)&#x3D;argmax_w\sum_{i&#x3D;1}^N(y_i\log p_1+(1-y_i)\log p_0)$$</p><p>接着使用梯度下降推导即可，我们相当于在这里直接导出了交叉熵函数</p><h1 id="软输出：高斯判别-关注数据本身特征"><a href="#软输出：高斯判别-关注数据本身特征" class="headerlink" title="软输出：高斯判别:关注数据本身特征"></a>软输出：高斯判别:关注数据本身特征</h1><p>假设数据分布满足这样的形式</p><p>$\begin{aligned}&amp;1.\quad y\sim Bernoulli(\phi)\&amp;2.\quad x|y&#x3D;1\sim\mathcal{N}(\mu_1,\Sigma)\&amp;3.\quad x|y&#x3D;0\sim\mathcal{N}(\mu_0,\Sigma)\end{aligned}$</p><p>$$argmax_{\phi,\mu_0,\mu_1,\Sigma}\log p(X|Y)p(Y)&#x3D;argmax_{\phi,\mu_0,\mu_1,\Sigma}\sum_{i&#x3D;1}^N(\log p(x_i|y_i)+\log p(y_i))$$</p><p>利用交叉熵形式技巧把上面的概率式子展开</p><p>$$&#x3D;argmax_{\phi,\mu_0,\mu_1,\Sigma}\sum_{i&#x3D;1}^N((1-y_i)\log\mathcal{N}(\mu_0,\Sigma)+y_i\log\mathcal{N}(\mu_1,\Sigma)+y_i\log\phi+(1-y_i)\log(1-\phi))$$</p><p>求解$\phi$,对$\phi$求偏导数令其等于零即可<br>$$\begin{aligned}\sum_{i&#x3D;1}^N\frac{y_i}\phi+\frac{y_i-1}{1-\phi}&#x3D;0\\sum_{i&#x3D;1}^Ny_i\\Longrightarrow\phi&#x3D;\frac{\sum_{i&#x3D;1}^Ny_i}N&#x3D;\frac{N_1}N\end{aligned}$$</p><p>求解$\mu_1$,对$\mu_1$求偏导</p><p>$$\begin{aligned}<br>\hat{\mu}<em>{1}&amp; &#x3D;argmax</em>{\mu_1}\sum_{i&#x3D;1}^Ny_i\log\mathcal{N}(\mu_1,\Sigma) \<br>&amp;&#x3D;argmin_{\mu_1}\sum_{i&#x3D;1}^Ny_i(x_i-\mu_1)^T\Sigma^{-1}(x_i-\mu_1)<br>\end{aligned}$$</p><p>$$\mu_1&#x3D;\frac{\sum_{i&#x3D;1}^Ny_ix_i}{\sum_{i&#x3D;1}^Ny_i}&#x3D;\frac{\sum_{i&#x3D;1}^Ny_ix_i}{N_1}$$</p><p>根据对称性，<br>$$\mu_0&#x3D;\frac{\sum_{i&#x3D;1}^N(1-y_i)x_i}{N_0}$$</p><p>求解方差，需要一些技巧，这里直接给出结果</p><p>$$\Sigma&#x3D;\frac{N_1S_1+N_2S_2}N$$</p><h1 id="软输出-朴素贝叶斯分类器"><a href="#软输出-朴素贝叶斯分类器" class="headerlink" title="软输出:朴素贝叶斯分类器"></a>软输出:朴素贝叶斯分类器</h1><p><a href="https://www.bilibili.com/video/BV1eT411V7jM/?spm_id_from=333.337.search-card.all.click&vd_source=84b977d2834d5eca6c0ca78bd619156f">链接</a></p><p><img src="https://www.freeimg.cn/i/2024/08/06/66b1f16b6c8b2.png" alt="1722937704805.png"></p><p>$$\begin{aligned}<br>&amp;T&#x3D;{(x_{1},y_{1}),(x_{2},y_{2}),\ldots,(x_{N},y_{N})} \<br>&amp;x_i&#x3D;(x^1,\ldots,x^n) \<br>&amp;y_{i}&#x3D;c_{k}, \text{其中}k&#x3D;1\ldots K \<br>&amp;&amp;y\neq argmax_{c_k}P(y&#x3D;c_k)\prod_jP(x^j|y&#x3D;c_k)<br>\end{aligned}$$</p><p>我们选择概率最大的作为分类结果</p>]]></content>
    
    
    <categories>
      
      <category>机器学习</category>
      
      <category>统计机器学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>机器学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>线性回归</title>
    <link href="/2025/03/21/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92/"/>
    <url>/2025/03/21/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92/</url>
    
    <content type="html"><![CDATA[<h1 id="最小二乘法"><a href="#最小二乘法" class="headerlink" title="最小二乘法"></a>最小二乘法</h1><p> 假设数据集为：<br>$$\mathcal{D}&#x3D;{(x_1,y_1),(x_2,y_2),\cdots,(x_N,y_N)}$$<br>后面我们记：<br>$$X&#x3D;(x_1,x_2,\cdots,x_N)^T,Y&#x3D;(y_1,y_2,\cdots,y_N)^T$$<br>线性回归假设：<br>$$f(w)&#x3D;w^Tx$$</p><p>我们的任务是寻找到最合适的一个$w$，这必然需要定义合适的损失函数，如何定义？</p><p>合理的假设：噪声是高斯分布的，那么有$y&#x3D;w^Tx+\epsilon,\epsilon\sim\mathcal{N}(0,\sigma^2)$，也就是$y\sim\mathcal{N}(w^Tx,\sigma^2)$</p><p>我们使用使用最大似然估计求解$w$,也就是<br>$$w&#x3D;   argmax\log p(Y|X,w) $$</p><p><strong>这个式子表示表示在模型参数$w$ 固定且已知输入数据 $X$ 的条件下，输出数据 $Y$ 出现的概率。我们要求的就是:给定怎样的$w$可以使得这个概率最大</strong><br>$$\begin{aligned}&amp;&#x3D;argmax\log\prod_{i&#x3D;1}^Np(y_i|x_i,w)\&amp;&#x3D;argmax\sum_{i&#x3D;1}^N\log(\frac1{\sqrt{2\pi\sigma}}e^{-\frac{(y_i-w^Tx_i)^2}{2\sigma^2}})\end{aligned} $$<br>$$&#x3D;argmin\sum_{i&#x3D;1}^N(y_i-w^Tx_i)^2$$</p><p>因此使用二范数定义损失函数</p><p>$$L(w)&#x3D;\sum_{i&#x3D;1}^N||w^Tx_i-y_i||_2^2$$</p><p>$$&#x3D;(w^TX^T-Y^T)\cdot(Xw-Y)$$</p><p>$$\begin{aligned}<br>\hat{w}&#x3D;argmin L(w)&amp; \longrightarrow\frac\partial{\partial w}L(w)&#x3D;0 \<br>&amp;\longrightarrow2X^TX\hat{w}-2X^TY&#x3D;0 \<br>&amp;\longrightarrow\hat{w}&#x3D;(X^TX)^{-1}X^TY&#x3D;X^+Y<br>\end{aligned}$$</p><p>这个式子中$(X^TX)^{-1}X^T$又被称为伪逆。对于行满秩或者列满秩的$X$ ,可以直接求解，但是对于非满秩的样本集合，需要使用奇异值分解 (SVD)的方法，对$X$求奇异值分解，得到<br>$$X&#x3D;U\Sigma V^T$$<br>于是：<br>$$X^+&#x3D;V\Sigma^{-1}U^T$$</p><h1 id="正则化"><a href="#正则化" class="headerlink" title="正则化"></a>正则化</h1><p>正则化是防止过拟合的关键手段，从代数上朴素的看，就是在原有loss函数的基础上加上一项有关于$w$的惩罚项，防止$w$过大，$L_1$正则化和$L_2$正则化可以写为下式</p><p>$$L1:argmin L(w)+\lambda||w||_1,\lambda&gt;0\L2:argmin L(w)+\lambda||w||_2^2,\lambda&gt;0$$</p><p>然而正则化的引入依然有其概率意义，关于惩罚项的引入实际上出自于我们对最大似然估计的修正，最大似然估计看似合乎直觉，实际上并没有考虑到先验概率对于某一条件概率的影响，事实上最大后验估计往往比最大似然估计更准确!<br>假设权重先验分布满足高斯分布，则<br>$$\begin{aligned}<br> w\sim\mathcal{N}(0,\sigma_0^2) \<br>\hat{w}&#x3D;argmax \log p(w|Y)&amp; &#x3D;\underset{w}{\operatorname*{argmax}}p(Y|w)p(w) \<br>&amp;&#x3D;argmax\log p(Y|w)p(w) \<br>&amp;&#x3D;argmax(\log p(Y|w)+\log p(w)) \<br>&amp;&#x3D;argmin[(y-w^Tx)^2+\frac{\sigma^2}{\sigma_0^2}w^Tw]<br>\end{aligned}$$</p><p>这就是$L_2$正则化的由来,本质上是考虑了$p(w)$带来的修正项</p>]]></content>
    
    
    <categories>
      
      <category>机器学习</category>
      
      <category>统计机器学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>机器学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>降维</title>
    <link href="/2025/03/21/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E9%99%8D%E7%BB%B4/"/>
    <url>/2025/03/21/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E9%99%8D%E7%BB%B4/</url>
    
    <content type="html"><![CDATA[<h1 id="协方差矩阵"><a href="#协方差矩阵" class="headerlink" title="协方差矩阵"></a>协方差矩阵</h1><h2 id="方差：单个向量-变量序列"><a href="#方差：单个向量-变量序列" class="headerlink" title="方差：单个向量&#x2F;变量序列"></a>方差：单个向量&#x2F;变量序列</h2><p>$$\mathrm{Var(a)&#x3D;\frac{1}{m}.\sum_{i&#x3D;1}^{m}<del>(a_{i}-\mu)^{2}}$$<br>对于质心系的坐标，可以直接写为<br>$$\mathrm{Var(a)&#x3D;\frac{1}{m}.\sum_{i&#x3D;1}^{m}</del>a_{i}^{2}}$$</p><h2 id="协方差-covariance-：两个向量"><a href="#协方差-covariance-：两个向量" class="headerlink" title="协方差(covariance)：两个向量"></a>协方差(covariance)：两个向量</h2><p>协方差用来描述两个向量之间的相关性，在PCA中我们希望降维后的变量可以保存更多的原始信息，所以尽可能的减少变量之间的相关性，因为相关性越大，则就代表着两个变量不是完全独立的，也即必然有重复的信息。<br>$$\mathrm{Cov(a,b)&#x3D;\frac1{m-1}.\sum_{i&#x3D;1}^m~(a_i-\mu_a)(b_i-\mu_b)}$$<br>对于已经归中的数据，可以写为(较大维度情况下m与m-1差别不大)<br>$$\mathrm{Cov(a,b)&#x3D;\frac{1}{m}.\sum_{i&#x3D;1}^{m}a_{i}b_{i}}$$</p><p>协方差可以衡量两个向量(变量)同时变化的程度，若协方差cov(a,b)&gt;0，则表示a若增大，b也增大；小于0时，a增大，b减小。<br>后话：当协方差为0的时候，也即表示两个变量之间不相关。在PCA降维时，就是选择几个基，使得原始数据变换到该组基上时，各变量之间的协方差为零，而变量的方差却很大。<br>而为了让协方差为0，选择第二个基的时候，与第一个基正交，第三个与第二个正交，这样两两正交的基，最后的相关性就是0。</p><h2 id="协方差矩阵-：多个向量"><a href="#协方差矩阵-：多个向量" class="headerlink" title="协方差矩阵 ：多个向量"></a>协方差矩阵 ：多个向量</h2><p>上述只是单个向量的方差和两个向量之间的协方差，若有多个向量，则可以用矩阵来表示两两的相关性。如有向量a,b,c，用矩阵X表示这三个向量，则其两两之间的协方差可以用矩阵来表示。</p><p>$$\mathrm{X&#x3D;\begin{pmatrix}a\b\c\end{pmatrix}&#x3D;\begin{pmatrix}a_1&amp;a_2&amp;a_3&amp;…\b_1&amp;b_2&amp;b_3&amp;…\c_1&amp;c_2&amp;c_3&amp;…\end{pmatrix}}\\\\mathrm{cov(X)&#x3D;\begin{pmatrix}cov(a,a)&amp;cov(a,b)&amp;cov(a,c)\cov(b,a)&amp;cov(b,b)&amp;cov(b,c)\cov(c,a)&amp;cov(c,b)&amp;cov(c,c)\end{pmatrix}}$$</p><p>去了均值后的协方差就是向量的内积求平均</p><p><img src="https://img.picui.cn/free/2024/08/29/66cf4ebeacd16.png" alt="1724862185379.png"></p><h1 id="背景引入：维度灾难"><a href="#背景引入：维度灾难" class="headerlink" title="背景引入：维度灾难"></a>背景引入：维度灾难</h1><p>边长为R的球与其外接立方体在n维空间中的体积比为<br>$$\lim_{n\to0}\frac{CR^n}{2^nR^n}&#x3D;0$$<br>这意味着高维空间中数据往往分布在边缘，因此，对于高维数据的降维处理是很有必要的</p><h1 id="主成分分析"><a href="#主成分分析" class="headerlink" title="主成分分析"></a>主成分分析</h1><p>必要的，先对协方差矩阵做一些变形</p><p>$$\begin{aligned}<br>\text{S}&amp; &#x3D;\frac1N\sum_{i&#x3D;1}^N(x_i-\overline{x})(x_i-\overline{x})^T \<br>&amp;&#x3D;\frac1N(x_1-\overline{x},x_2-\overline{x},\cdots,x_N-\overline{x})(x_1-\overline{x},x_2-\overline{x},\cdots,x_N-\overline{x})^T \<br>&amp;&#x3D;\frac1N(X^T-\frac1NX^T\mathbb{I}<em>{N1}\mathbb{I}</em>{N1}^T)(X^T-\frac1NX^T\mathbb{I}<em>{N1}\mathbb{I}</em>{N1}^T)^T \<br>&amp;&#x3D;\frac1NX^T(E_N-\frac1N\mathbb{I}<em>{N1}\mathbb{I}</em>{1N})(E_N-\frac1N\mathbb{I}<em>{N1}\mathbb{I}</em>{1N})^TX \<br>&amp;&#x3D;\frac1NX^TH_NH_N^TX \<br>&amp;&#x3D;\frac1NX^TH_NH_NX&#x3D;\frac1NX^THX<br>\end{aligned}$$</p><p>其中$H$称为中心矩阵，它的作用就是去中心化。容易验证$H$具有以下的良好性质</p><p>$$H^T&#x3D;H $$<br>$$H^n&#x3D;H  $$</p><p>主成分分析中，我们的基本想法是将所有数据投影到一个子空间中，从而达到降维的目标，为了寻找这个子空间，我们基本想法是：</p><ol><li>所有数据在子空间中更为分散</li><li>损失的信息最小，即：在补空间的分量少</li></ol><p>原来的数据很有可能各个维度之间是相关的，于是我们希望找到一组$p$个新的线性无关的单位基$u_i$ ,降<br>维就是取其中最重要的的$q$个基。于是对于一个样本$x_i$ ,经过这个坐标变换后(方便说明先不减去平均值)：<br>$$\hat{x_i}&#x3D;\sum_{i&#x3D;1}^p(u_i^Tx_i)u_i&#x3D;\sum_{i&#x3D;1}^q(u_i^Tx_i)u_i+\sum_{i&#x3D;q+1}^p(u_i^Tx_i)u_i$$</p><p>我们选取方差最大的方向为我们的保留方向，不妨如下设定$J$</p><p>$$\begin{gathered}<br>\text{J} &#x3D;\frac1N\sum_{i&#x3D;1}^N\sum_{j&#x3D;1}^q((x_i-\overline{x})^Tu_j)^2 \<br>&#x3D;\sum_{j&#x3D;1}^qu_j^TSu_j , s.t. u_j^Tu_j&#x3D;1<br>\end{gathered}$$</p><p>由于每一个基都是线性无关的，我们可以分别求解每一个基，因此原问题变为一个优化问题</p><p>$$argmax_{u_j}L(u_j,\lambda)&#x3D;argmax_{u_j}u_j^TSu_j+\lambda(1-u_j^Tu_j)\\\Su_j&#x3D;\lambda u_j$$</p><p>不难发现，我们需要的基就是协方差矩阵的本征矢(特征向量)，我们选取特征值最大的前q项即可。</p><h1 id="等价方法：奇异值分解"><a href="#等价方法：奇异值分解" class="headerlink" title="等价方法：奇异值分解"></a>等价方法：奇异值分解</h1><p>对中心化后的数据集进行奇异值分解：<br>$$HX&#x3D;U\Sigma V^T,U^TU&#x3D;E_N,V^TV&#x3D;E_p,\Sigma:N\times p$$<br>于是：<br>$$S&#x3D;\frac1NX^THX&#x3D;\frac1NX^TH^THX&#x3D;\frac1NV\Sigma^T\Sigma V^T$$<br>因此，我们直接对中心化后的数据集进行 SVD,就可以得到特征值和特征向量$V$ ,在新坐标系中的坐标就是：</p><p>$$HX\cdot V$$</p>]]></content>
    
    
    <categories>
      
      <category>机器学习</category>
      
      <category>统计机器学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>机器学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>机器学习全局调查</title>
    <link href="/2025/03/21/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E8%A5%BF%E7%93%9C%E4%B9%A6/"/>
    <url>/2025/03/21/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E8%A5%BF%E7%93%9C%E4%B9%A6/</url>
    
    <content type="html"><![CDATA[<p>这一系列源自西瓜书，目的是对机器学习全局有大概的把握，重点不在于数学推导的细节，而在于了解各个经典模型的核心思想与insight，形成一张自己的地图，企望日后按图索骥。</p><h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>机器学习是什么？从数据中学习，基于数据产生模型去预测未知数据</p><h1 id="基本术语-假设"><a href="#基本术语-假设" class="headerlink" title="基本术语&#x2F;假设"></a>基本术语&#x2F;假设</h1><p>独立同分布：我们认为样本空间全体样本服从一个未知分布，我们获得的每一个样本都满足独立同分布，细细一想这一结果未必总是成立，样本之间高度共线性的情况</p><h1 id="假设空间"><a href="#假设空间" class="headerlink" title="假设空间"></a>假设空间</h1><h1 id="归纳偏好"><a href="#归纳偏好" class="headerlink" title="归纳偏好"></a>归纳偏好</h1><p>归纳偏好是算法本身的特征，当预测时遇到无法断言的情况，模型本身的偏好起到了重要结果。不同算法的偏好是好是坏很难界定，一个经典的原则是<strong>奥卡姆剃刀原则</strong>：如无必要，勿增实体。</p><ul><li>在机器学习中理解，有点拟合和过拟合的滋味，比如用多项式函数拟合某一个线性函数，数据量有限的情况下，多项式函数次数越高越容易过拟合</li><li>在自然科学中理解，这是一种朴素的科研品味，费曼说过，你能一眼认出真理，因为她既美又简单。</li></ul><p>NFL定理告诉我们，脱离具体问题，空泛的谈论什么算法更好毫无意义。算法的优劣总是针对于具体的问题而言</p><h1 id="发展历程"><a href="#发展历程" class="headerlink" title="发展历程"></a>发展历程</h1><p>上世纪五十年代到七十年代，人工智能处于推理期，著名的逻辑理论家程序证明了数学原理中的38条定理</p><p>随后，人们认识到仅仅有逻辑推理能力远远实现不了人工智能，要使机器具有智能，就要让他拥有知识，这一时期大量专家系统问世</p><p>再后来，人们意识到把知识总结出来教给计算机没有前途，能否让机器自己学习知识？机器学习在这一时期红极一时，持续至今</p><p>机器学习包括哪些思想？基于神经网络的连接主义，基于逻辑表示的符号主义，以决策论为基础的机器学习&#x2F;强化学习，统计机器学习（svm）等等</p><h1 id="对序言的摘要"><a href="#对序言的摘要" class="headerlink" title="对序言的摘要"></a>对序言的摘要</h1><p>三十年河东，三十年河西，如今神经网络</p><p>这一轮的大语言模型（Large Language Model, LLM）浪潮，即依托大量的数据和算法资源获得的进步。但是”连接主义”方法最大的局限性是其”试错性”，简单的说，其学习过程涉及大量参数，而参数的设置缺乏理论指导（可解释性差），主要依靠手动调参，夸张一点来说，参数调节上失之千里，学习结果可能谬以千里。</p><p>相比之下”符号主义”的逻辑性更强，通过逻辑表达式描述领域知识。然而，成也萧何，败也萧何，然而，由于表示能力太强，直接导致面临的假设空间太大、复杂度极高，因此，问题规模稍大就难以进行有效学习。</p><p>对于机器学习的发展前途，中科院数学与系统科学研究院陆汝铃老师在为南京大学周志华老师的《机器学习》一书作序时提出了六大问题。第一个问题就是”符号主义”与”连接主义”之争。在此我摘录总结陆老师的观点：</p><p>Q1：从二十世纪九十年代开始，”连接主义”迅速压倒并取代了”符号主义”的地位。人们可能会问，符号学习是否被彻底忽略了？他还能成为机器学习的研究对象吗？它是否能继续在统计学习的阴影里苟延残喘？</p><p>A：这个问题有三种可能：</p><ol><li>退出历史舞台——目前还没有人抱有这种想法。</li><li>单纯的统计学习到了尽头之后，再想往前走就要和符号主义学习结合起来——王珏教授认为，现在机器学习已经到了一个转折点，统计学习要想进入一个更高级的形式，就应该和认知相结合，这是一种”螺旋式上升，进入更高级的形式”，否则就会停留于现状而止步不前。</li><li>三十年河东三十年河西，符号学习还有翻身之日——Chandrasekaran 教授认为最近几年，人工智能在很大程度上集中于统计学和大数据，并取得一些成果。但总有一天会转向基于更基本的认知科学研究。有必要把统计技术和认知结构，连接主义和符合主义结合起来。<br> 两位老师的观点基本一致，但不仅限于机器学习，而是涉及整个人工智能领域，知识王珏老师强调知识，而Chandrasekaran 教授强调更基本的”认知”。</li></ol><p>Q2：为什么统计机器学习不会一帆风顺？</p><p>A：统计机器学习的算法都是基于样本数据独立同分布的假设，但自然界现象千变万化，哪里有那么多独立同分布？那么“独立同分布”条件对于机器学习来说是必须的吗？独立同分布的不存在一定是不可逾越的障碍吗？无独立同分布条件下的机器学习也许只是一个难题，而不是不可解决的。</p><p>Q4：机器学习研究出现以来，我们看到的主要是从符号方法到统计方法的演变，用到的数学主要是概率统计。但是今天数学之大，就像大海，难道只有统计方法适合于在机器学习方面的应用？</p><p>A：目前流形学习已经“有点意思了”，但数学理论的介入程度远远不够，有待更多数学家参与，开辟新的模式、理论和方法。</p><h1 id="2-1经验误差和过拟合"><a href="#2-1经验误差和过拟合" class="headerlink" title="2.1经验误差和过拟合"></a>2.1经验误差和过拟合</h1><p>误差error：实际预测输出与真是输出之间的差异，在训练集上的误差成为训练误差training error或经验误差empirical error，在新样本上的误差成为泛化误差generalization error，<br>训练的最终目标是获得较小的泛化误差<br>机器学习算法的难点在于克服过拟合</p><h1 id="2-2评估方法"><a href="#2-2评估方法" class="headerlink" title="2.2评估方法"></a>2.2评估方法</h1><h2 id="2-2-1留出法"><a href="#2-2-1留出法" class="headerlink" title="2.2.1留出法"></a>2.2.1留出法</h2><p>直接将数据集D划分为两个互斥的集合，其中一个集合作为训练集S,另一个作为测试集T。</p><p>从釆样(sampling)的角度来看数据集的划分过程，一般进行保留类别比例的釆样方式，也就是“分层采样” (stratified sampling)。</p><p>单次使用留出法得到的估计结果往往不够稳定可靠，在使用留出法时，一般要采用若干次随机划分、重复进行实验评估后取平均值作为留出法的评估结果。</p><p>测试集较小时，评估结果的方差较大；训练集小时，评估结果的偏差较大，常见做法 2&#x2F;3 ~ 4&#x2F;5 的样本作为训练集，剩余样本用于测试。事实上不咋用这个方法。</p><h2 id="2-2-2交叉验证法"><a href="#2-2-2交叉验证法" class="headerlink" title="2.2.2交叉验证法"></a>2.2.2交叉验证法</h2><ul><li><p>思路：将数据集划分为k个大小相似的互斥子集，每次用k-1个子集的并集作为训练集，余下的那个子集作为测试集，如此进行k次测试，最终用上全部的数据。</p></li><li><p>p 次 k 折交叉验证：:与留出法相似，将数据集D划分为k个子集同样存在多种划分方式。为减小因样本划分不同而引入的差别，k折交叉验证通常要随机使用不同的划分重复p次，最终的评估结果是这p次k折交叉验证结果的均值，例如常见的有“10次10折交叉验证</p></li><li><p>特例:当k和数据集数量一致时，称之为留一法（Leave One Out）简称：LOO</p></li></ul><h2 id="2-2-3自助法"><a href="#2-2-3自助法" class="headerlink" title="2.2.3自助法"></a>2.2.3自助法</h2><p>留出法和交叉验证法中，由于保留了一部分样本用于测试，因此实际评估的模型所使用的训练集在大小上比D小，而留一法的计算复杂度又太高。若希望评估用训练集全集D训练出的模型，可以使用自助法(bootstrapping)，其在数据集较小、难以有效划分训练&#x2F;测试集时很有用。</p><p>给定包含 m 个样本的数据集D ,我们对它进行采样产生数据集D’：每次随机从D中挑选一个样本,将其拷贝放入D’,然后再将该样本放回初始数据集D中,使得该样本在下次釆样时仍有可能被釆到；这个过程重复执行m次后，我们就得到了包含m 个样本的数据集D,这就是自助釆样的结果。很有可能的，D中有一部分样本会在D中多次出现，而另一部分样本不出现。从数学期望的角度可以做一个简单的估计，样本在m次采样中始终不被釆到的概率是$(1 -\frac1m)^m$,取m趋于正无穷极限的得到<br>$$\lim_{m\mapsto\infty}\left(1-\frac1m\right)^m\mapsto\frac1e\approx0.368$$</p><p>通过自助釆样，从数学期望的角度来看，初始数据集D中约有36.8%的样本未出现在釆样数据集D中。于是可将D用作训练集,D\D’用作测试集。这样，实际评估的模型与期望评估的模型都使用m个训练样本，而我们仍有数据总量约1&#x2F;3的、没在训练集中出现的样本用于测试。</p><h2 id="2-2-4调参与最终模型"><a href="#2-2-4调参与最终模型" class="headerlink" title="2.2.4调参与最终模型"></a>2.2.4调参与最终模型</h2><ul><li><p>小数据集，数据不好划分的时候，用自助法</p></li><li><p>大部分时候，用k折</p></li><li><p>如何调参？:网格搜索参数</p></li><li><p>以上只是为了对比模型好坏，选出来最好模型后，最后提交给客户的模型参数应该是用训练集全集D训练出来的</p></li></ul><h1 id="2-3性能度量"><a href="#2-3性能度量" class="headerlink" title="2.3性能度量"></a>2.3性能度量</h1><p>对学习器的泛化性能进行评估，不仅需要有效可行的实验估计方法，还需要有衡量模型泛化能力的评价标准，这就是性能度量（performance measure）</p><p>回归问题常用均方误差做，下面着重讲一下分类问题的效果评估</p><h2 id="2-3-2-查准率-查全率-F1"><a href="#2-3-2-查准率-查全率-F1" class="headerlink" title="2.3.2 查准率&#x2F;查全率&#x2F;F1"></a>2.3.2 查准率&#x2F;查全率&#x2F;F1</h2><p><img src="https://www.freeimg.cn/i/2024/11/06/672a4378dabf8.webp"></p><p>分类问题目的是什么？从一堆瓜中找出来所有的好瓜，你用自己的模型找出来了一堆瓜，不过其中有好有坏<br>你找出来的瓜有多少是好瓜？由此定义了<strong>查准率 P（precision）</strong><br>$$P&#x3D;\frac{TP}{TP+FP}$$<br>所有好瓜里面你挑出来了多少？由此定义了<strong>查全率 R（recall）&amp; 召回率</strong><br>$$R&#x3D;\frac{TP}{TP+FN}$$<br>查准率和查全率是一对矛盾的度量. 一般来说，查准率高时，查全率往往偏低；而查全率高时，查准率往往偏低.例如，若希望将好瓜尽可能多地选出来， 则可通过增加选瓜的数量来实现，如果将所有西瓜都选上，那么所有的好瓜也必然都被选上了，但这样查准率就会较低；若希望选出的瓜中好瓜比例尽可能高，则可只挑选最有把握的瓜，但这样就难免会漏掉不少好瓜，使得查全率较低.通常只有在一些简单任务中，才可能使查全率和查准率都很高.</p><p>我们可以画个图（其实就是收益曲线）<br><img src="https://www.freeimg.cn/i/2024/11/06/672a438ab2168.webp"><br>怎么判断模型好坏？图中BC好判断，AB如何判断？<br>引入一个综合考虑查准率、查全率的性能度量：平衡点(Break-Event Point,简称BEP)，是查准率&#x3D;查全率时的取值。这个值越大性能越好。          </p><p>但BEP还是过于简化了些，更常用的是F1度量，一个基于查准率与查全率的调和平均</p><p>$$F1&#x3D;\frac{2\times P\times R}{P+R}&#x3D;\frac{2\times TP}{\text{样例总数}+TP-TN}$$</p><p>若任务场景是对查重率或查准率某一个有更高要求，可以对二者加以不同的权重，即F1度量的一般形式——Fβ<br>$$F_{\beta}&#x3D;\frac{(1+\beta^{2})\times P\times R}{(\beta^{2}\times P)+R}$$<br>其中β&gt; 0度量了查全率对查准率的相对重要性[VanRijsbergen, 1979]。β&#x3D; 1时退化为标准的F1; β&gt; 1时查全率有更大影响；β&lt; 1时查准率有更大影响。</p><h2 id="2-3-3-ROC-与-AUC"><a href="#2-3-3-ROC-与-AUC" class="headerlink" title="2.3.3 ROC 与 AUC"></a>2.3.3 ROC 与 AUC</h2><p>换了个说法让人一懵，细细一想只不过是另一种作图方式，定义            </p><ul><li>纵轴是好瓜的查全率（真正例率），即好瓜里面有多大比例被挑了出来        </li><li>横轴是坏瓜的查全率（假正例率），即坏瓜里面有多大比例被不小心挑出来了。</li></ul><p>画个图是这样的</p><p><img src="https://www.helloimg.com/i/2024/11/05/672a3580d8581.png" alt="1730819590980.png"></p><p>最理想的情况肯定是坐标(0,1),好瓜全都挑出来了，坏瓜没有粗心选出来一个。同理最差情况是坐标(1,0).对角线实际上就是随机抽样。ROC围成的面积成为AUC，一般认为AUC越大模型效果越好</p><h2 id="2-3-4-代价敏感错误率与代价曲线"><a href="#2-3-4-代价敏感错误率与代价曲线" class="headerlink" title="2.3.4 代价敏感错误率与代价曲线"></a>2.3.4 代价敏感错误率与代价曲线</h2><p>分类问题中的错误可以分为两种，不小心选了坏瓜，漏选了好瓜，有时候这两种错误我们更重视某一种，因此自然地为二者引入不同的cost权重<br><img src="https://www.helloimg.com/i/2024/11/05/672a374d524a3.png" alt="1730820050659.png"><br>如此一来，上面的ROC曲线就不管用了，考虑引入权重作图。<br>这一块不太好理解，我写一下个人的阐述<br>横轴为正例概率代价，其实是假设我们的模型就是随机取样，对总代价的归一化度量<br>$$P(+)cost&#x3D;\frac{p\times cost_{01}}{p\times cost_{01}+(1-p)\times cost_{10}}$$<br>纵轴为运用了我们提出的模型之后，代价的归一化度量<br>$$cost_{norm}&#x3D;\frac{\mathrm{FNR}\times p\times cost_{01}+\mathrm{FPR}\times(1-p)\times cost_{10}}{p\times cost_{01}+(1-p)\times cost_{10}}$$<br>自然可以理解，某一点的坐标纵坐标小于横坐标才能说明模型是有效的，纵坐标越比横坐标小就越有效，为此取无穷条曲线的下包络，围城面积越小则认为模型效果越好。个人感觉此处应该是有严格的数学证明推导这些统计意义。</p><h1 id="2-4比较检验"><a href="#2-4比较检验" class="headerlink" title="2.4比较检验"></a>2.4比较检验</h1><p>我挺不喜欢这一部分的内容，这也是统计学总是被机器学习大佬诟病的一点–花了太多精力在各种推断与检验上，不过作为学生基本知识该有还是得有。再此我只做简单的了解，写论文最后需要用的时候再学。</p><p>统计假设检验(hypothesis test)为我们进行学习器性能比较提供了重要依据。          </p><p>为什么这么说？我们上面提出了很多度量模型效果的标准，倘若在某种标准下模型A的泛化效果比B好，我们就可以断言A这个模型一定在此任务中优于B吗？显然不是。在这个测试集上A优于B，换个测试集就说不定了。大千世界无奇不有。</p><p>比较检验解决的就是这样的问题，我们用统计学方法探讨A的泛化性能是否在统计意义上优于B？以及这个结论的把握有多大。</p><h2 id="2-4-1假设检验"><a href="#2-4-1假设检验" class="headerlink" title="2.4.1假设检验"></a>2.4.1假设检验</h2><p>及其不常用，而且周的阐述疑似有误，这里贴一个讨论博客<br><a href="https://www.zhihu.com/question/287895170">周志华《机器学习》38页关于二项检验的公式(2.27)是否有误？7 个回答<br>默认排序<br>politer<br>politer<br>教师<br>49 人赞同了该回答</a></p><h2 id="2-4-4-Friedman检验与Nemenyi后续检验"><a href="#2-4-4-Friedman检验与Nemenyi后续检验" class="headerlink" title="2.4.4 Friedman检验与Nemenyi后续检验"></a>2.4.4 Friedman检验与Nemenyi后续检验</h2><p>交叉验证t检验和McNemar检验都是在一个数据集上比较两个算法的性能，而在很多时候，我们会在一组数据集上对多个算法进行比较.当有多个算法参与比较时，这时候可以使用基于算法排序的 Friedman 检验。</p><h1 id="2-5方差与偏差"><a href="#2-5方差与偏差" class="headerlink" title="2.5方差与偏差"></a>2.5方差与偏差</h1><p>泛化误差可分解为偏差、方差与噪声之和：<br>$$E(f;D)&#x3D;bias^2\left(\boldsymbol{x}\right)+var\left(\boldsymbol{x}\right)+\varepsilon^2$$</p><h4 id="偏差（Bias）"><a href="#偏差（Bias）" class="headerlink" title="偏差（Bias）"></a>偏差（Bias）</h4><ul><li><p><strong>含义</strong>：偏差衡量的是你的模型预测的平均值与真实房价之间的偏离程度。它反映了模型对数据的拟合能力。</p></li><li><p><strong>例子</strong>：以房价预测为例子，如果你使用的模型非常简单（比如线性回归），它可能无法捕捉到房价与特征之间的复杂关系，导致预测结果普遍偏低或偏高。这就是高偏差的情况，意味着模型欠拟合，没有充分利用数据中的信息。</p></li><li><p><strong>影响</strong>：高偏差会导致模型在训练集和测试集上的表现都不好，因为模型没有学习到数据的真实分布。</p></li></ul><h4 id="方差（Variance）"><a href="#方差（Variance）" class="headerlink" title="方差（Variance）"></a>方差（Variance）</h4><ul><li><p><strong>含义</strong>：方差衡量的是当你使用不同的训练集（但大小相同）来训练模型时，模型性能（如预测准确度）的变化程度。它反映了数据扰动对模型性能的影响。</p></li><li><p><strong>例子</strong>：如果你使用的模型非常复杂（比如深度神经网络），它可能会过度拟合训练集，即记住训练集中的每一个细节，而不是学习到一般的规律。这样，当模型遇到新的测试数据时，它的预测结果可能会因为训练集的微小变化而大幅波动。这就是高方差的情况。</p></li><li><p><strong>影响</strong>：高方差会导致模型在训练集上表现很好，但在测试集上表现很差，因为模型过于依赖训练集的具体细节，而不是数据的真实分布。</p></li></ul><h4 id="噪声（Noise）"><a href="#噪声（Noise）" class="headerlink" title="噪声（Noise）"></a>噪声（Noise）</h4><ul><li><p><strong>含义</strong>：噪声是数据本身固有的、无法通过学习算法来减少的误差。它表示了在当前任务上，任何学习算法所能达到的期望泛化误差的下界。</p></li><li><p><strong>例子</strong>：在房价预测中，噪声可能来自于房屋价格的随机波动、数据收集过程中的误差、或者某些无法量化的特征（如房屋的“风水”好坏）。这些因素都会导致房价的不确定性，使得即使是最优的模型也无法完全准确地预测房价。</p></li><li><p><strong>影响</strong>：噪声限制了模型性能的上限。无论模型多么复杂或精细，它都无法超越噪声所设定的泛化误差下界。</p></li></ul><p><img src="https://www.helloimg.com/i/2024/11/05/672a3f51379fe.png" alt="1730822103884.png"></p><h1 id="3-1基本形式"><a href="#3-1基本形式" class="headerlink" title="3.1基本形式"></a>3.1基本形式</h1><p>$$f(\boldsymbol{x})&#x3D;\boldsymbol{w}^\mathrm{T}\boldsymbol{x}+b$$</p><p>线性模型形式简单，易于建模，蕴含着机器学习中重要的思想，而且可解释性强，</p><h1 id="3-2线性回归"><a href="#3-2线性回归" class="headerlink" title="3.2线性回归"></a>3.2线性回归</h1><p>$$\begin{aligned}<br>(w^*,b^*)&amp; &#x3D;\arg\min_{(w,b)}\sum_{i&#x3D;1}^m\left(f\left(x_i\right)-y_i\right)^2 \<br>&amp;&#x3D;\arg\min_{(w,b)}\sum_{i&#x3D;1}^m(y_i-wx_i-b)^2 .<br>\end{aligned}$$</p><p>求导之后可以得到简单的封闭解，拓展到矩阵形式也是一样的。</p><p>任何函数内套上一层线性回归，称之为广义线性模型<br>$$y&#x3D;g^{-1}(\boldsymbol{w}^\mathrm{T}\boldsymbol{x}+b)$$</p><h1 id="3-3对数几率回归"><a href="#3-3对数几率回归" class="headerlink" title="3.3对数几率回归"></a>3.3对数几率回归</h1><p>$$y&#x3D;\frac1{1+e^{-(\boldsymbol{w}^\mathrm{T}\boldsymbol{x}+b)}} .$$</p><p>这是sigmod函数，一般取y&#x3D;0.5位分界判断点，上一个式子可以改写成<br>$$\ln\frac y{1-y}&#x3D;\boldsymbol{w}^\mathrm{T}\boldsymbol{x}+b .$$<br>也就是说我们在用线性回归去学习对数几率，显然有<br>$$p(y&#x3D;1\mid\boldsymbol{x})&#x3D;\frac{e^{\boldsymbol{w}^\mathrm{T}\boldsymbol{x}+b}}{1+e^{\boldsymbol{w}^\mathrm{T}\boldsymbol{x}+b}} ,\p(y&#x3D;0\mid\boldsymbol{x})&#x3D;\frac{1}{1+e^{\boldsymbol{w}^\mathrm{T}\boldsymbol{x}+b}} .$$<br>用极大似然法、或者对偶理论，可以得到需要去最优化的函数<br>$$\ell(\boldsymbol{\beta})&#x3D;\sum_{i&#x3D;1}^m\left(-y_i\boldsymbol{\beta}^\mathrm{T}\hat{\boldsymbol{x} }_i+\ln\left(1+e^{\boldsymbol{\beta}^\mathrm{T}\hat{\boldsymbol{x} }_i}\right)\right)$$</p><h1 id="3-4线性判别"><a href="#3-4线性判别" class="headerlink" title="3.4线性判别"></a>3.4线性判别</h1><p>LDA 的思想非常朴素：给定训练样例集，设法将样例投影到一条直线上， 使得同类样例的投影点尽可能接近、异类样例的投影点尽可能远离；在对新样本进行分类时，将其投影到同样的这条直线上，再根据投影点的位置来确定新样本的类别.图 3.3 给出了一个二维示意图.</p><p><img src="https://www.freeimg.cn/i/2024/11/06/672b878797fb2.webp" alt="1730905988970.png"><br>具体的推导可以参见暑期的统计机器学习笔记</p><h1 id="3-5多分类学习"><a href="#3-5多分类学习" class="headerlink" title="3.5多分类学习"></a>3.5多分类学习</h1><ul><li>一对一（OvO）：将N个类别两两配对，产生$N*(N-1)&#x2F;2$个二分类任务，最终的结果通过每个二分类器投票产生</li><li>一对其余（OvR）：将一个类别作为正例，将其他类别作为反例来训练N个分类器，最终结果由置信度最大的一个分类器决定</li><li>多对多（MvM）：常用纠错输出码方法（ECOC），训练时编码，对N个类别进行M次划分，训练M个二分类器。测试时解码，使用M个分类器对其预测，将生成的编码与每个类别的编码比较，距离最小的即为预测结果</li></ul><p><img src="https://www.freeimg.cn/i/2024/11/06/672b8bcb6690b.webp" alt="1730907077041.png"></p><h1 id="3-6类别不平衡问题"><a href="#3-6类别不平衡问题" class="headerlink" title="3.6类别不平衡问题"></a>3.6类别不平衡问题</h1><p>常用三种解决方法</p><ul><li>欠采样 (undersampling):也称下采样，去除一些比例高的数据</li><li>过采样 (oversampling):也称上采样，通过插值增加一些比例少的数据</li><li>阈值移动 (threshold-moving):用原始训练集训练，但在预测时令$\frac{y^{\prime}}{1-y^{\prime}}&#x3D;\frac{y}{1-y}\times\frac{\text{反例数量}}{\text{正例数量}}$</li></ul><p>第三条的意义在于，我们往往假设训练集是真实样本的无偏采样，因此判断阈值应当是大于观测几率的。</p><h1 id="4-1基本流程"><a href="#4-1基本流程" class="headerlink" title="4.1基本流程"></a>4.1基本流程</h1><p>决策树模仿人类的决策处理机制，利用树结构进行预测</p><h1 id="4-2划分选择"><a href="#4-2划分选择" class="headerlink" title="4.2划分选择"></a>4.2划分选择</h1><p>决策树的关键在于划分选择，也就是选择合适的划分标准，使得树的节点包含类别的纯度越来越高</p><p>下面给出几种常用的划分依据</p><h2 id="4-2-1-信息增益"><a href="#4-2-1-信息增益" class="headerlink" title="4.2.1 信息增益"></a>4.2.1 信息增益</h2><p>引入信息熵来度量样本集合的纯度，假设当前样本集合$D$中第$k$类样本所占的比例为$p_k$,则定义此集合的信息熵为<br>$$\operatorname{Ent}(D)&#x3D;-\sum_{k&#x3D;1}^{|\mathcal{Y}|}p_k\log_2p_k .$$<br>利用属性$a$对样本进行划分之后的信息增益定义为<br>$$\mathrm{Gain}(D,a)&#x3D;\mathrm{Ent}(D)-\sum_{v&#x3D;1}^V\frac{|D^v|}{|D|}\mathrm{Ent}(D^v)$$</p><h2 id="4-2-2-增益率"><a href="#4-2-2-增益率" class="headerlink" title="4.2.2 增益率"></a>4.2.2 增益率</h2><p>有了信息增益还不够，如果我们将类似于编号之类的东西也作为划分依据，他的信息增益可以很大，但是不具有泛化能力，也就是说信息增益对可以取值的数目较多的属性有偏好，为了解决这个问题，引入信息增益率<br>$$\text{Gain ratio}(D,a)&#x3D;\frac{\mathrm{Gain}(D,a)}{\mathrm{IV}(a)} ,\\text{其中}\\mathrm{IV}(a)&#x3D;-\sum_{v&#x3D;1}^{V}\frac{|D^{v}|}{|D|}\log_{2}\frac{|D^{v}|}{|D|}$$<br>称为属性a的固有值，a的可取值越多，固有值越大，增益率对分类效果好同时可取值数目少的特征有所偏好</p><h2 id="4-2-3基尼系数"><a href="#4-2-3基尼系数" class="headerlink" title="4.2.3基尼系数"></a>4.2.3基尼系数</h2><p>定义基尼值为随机抽取两个值，类别标记不一致的概率<br>$$\begin{aligned}\operatorname{Gini}(D)&amp;&#x3D;\sum_{k&#x3D;1}^{|\mathcal{Y}|}\sum_{k^{\prime}\neq k}p_{k}p_{k^{\prime}}\&amp;&#x3D;1-\sum_{k&#x3D;1}^{|\mathcal{Y}|}p_{k}^{2} .\end{aligned}$$<br>相应的，定义划分之后的基尼系数<br>$$\mathrm{Gini_index}(D,a)&#x3D;\sum_{v&#x3D;1}^V\frac{|D^v|}{|D|_.}\mathrm{Gini}(D^v)$$<br>我们选取使得基尼系数最小的特征作为划分依据</p><h1 id="4-3剪枝"><a href="#4-3剪枝" class="headerlink" title="4.3剪枝"></a>4.3剪枝</h1><p>剪枝的思路大致分为两种，预剪枝，后剪枝，剪枝是决策树防止过拟合的主要方法</p><h1 id="4-4-连续与缺失值"><a href="#4-4-连续与缺失值" class="headerlink" title="4.4 连续与缺失值"></a>4.4 连续与缺失值</h1><h2 id="4-4-1-如何处理连续值？"><a href="#4-4-1-如何处理连续值？" class="headerlink" title="4.4.1 如何处理连续值？"></a>4.4.1 如何处理连续值？</h2><p>连续值的可取值数目不再有限，我们一般把出现的属性数值排序，然后利用二分或者什么其他方法搜索使得信息增益最大的分界点。<br>$$\begin{aligned}<br>\mathrm{Gain}(D,a)&amp; &#x3D;\max_{t\in T_{a}} \mathrm{Gain}(D,a,t) \<br>&amp;&#x3D;\max_{t\in T_a} \mathrm{Ent}(D)-\sum_{\lambda\in{-,+}}\frac{|D_t^\lambda|}{|D|}\mathrm{Ent}(D_t^\lambda)<br>\end{aligned}$$</p><h2 id="4-4-2-如何处理缺失值？"><a href="#4-4-2-如何处理缺失值？" class="headerlink" title="4.4.2 如何处理缺失值？"></a>4.4.2 如何处理缺失值？</h2><p>如何在属性值缺失的情况下进行数据划分？</p><p>核心的处理思路就是用无缺样本代替总体来进行计算</p><h1 id="4-5多变量决策树"><a href="#4-5多变量决策树" class="headerlink" title="4.5多变量决策树"></a>4.5多变量决策树</h1><p>多变量决策树 (multivariate decision tree) 的非叶结点是形如$\sum_{i&#x3D;1}^dw_ia_i&#x3D;t$的线性分类器，不<br>再仅对某个属性，而是对所有属性的线性组合进行测试，其中$w_i,t$都可以通过样本学习得到</p><h1 id="5-1神经元模型"><a href="#5-1神经元模型" class="headerlink" title="5.1神经元模型"></a>5.1神经元模型</h1><p>$$y&#x3D;f\left(\sum_{i&#x3D;1}^nw_ix_i-\theta\right)$$<br>激活函数常用<br><img src="https://www.freeimg.cn/i/2024/11/08/672dcdef9b6c9.webp" alt="1731055085849.png"><br>以及RELU</p><h1 id="5-2感知机"><a href="#5-2感知机" class="headerlink" title="5.2感知机"></a>5.2感知机</h1><p><img src="https://www.freeimg.cn/i/2024/11/08/672dd0954afe1.webp" alt="1731055763592.png"></p><p>举个例子</p><p>我们要解决的问题是：二分类$N$个样本点$(x_{i},y_{i})$，其中$x_{i}\in R^p$<br>引入：<br>$$sign(a)&#x3D;\left{\begin{matrix}+1,a\geq0\-1,a&lt;0\end{matrix}\right.$$</p><p>感知机的思路是把线性回归的结果填充到激活函数中：<br>$$f(x)&#x3D;sign(w^Tx)$$</p><p>这样$f(x)$即为预测结果。<br>此时，问题变为如何求解$w$。我们使用梯度下降的策略，那么自然的需要引入loss函数。为了引入合适的loss函数，做一些必要的讨论   </p><p>我们考虑一个被正确分类的点$(x_i,y_i)$，若 $w^Tx_i&gt;0$，则 $y_i&#x3D;+1$,若$w^Tx_i&lt;0$，则 $y_i&#x3D;-1$,因此对于正确分类的点$(x_i,y_i)$，总有$y_iw^Tx_i&gt;0$      </p><p><img src="https://www.freeimg.cn/i/2024/08/05/66b0ac3260027.png" alt="1722854448587.png"></p><p>综上所述，我们引入形如下式的loss函数<br>$$ L(w)&#x3D;\sum_{x_i\in\mathcal{D}_{wrong}}-y_iw^Tx_i $$</p><p>应用梯度下降法可得</p><p>$$\frac\partial{\partial w}L(w)&#x3D;\sum_{x_i\in\mathcal{D}_{wrong}}-y_ix_i$$</p><p>$$w^{t+1}\leftarrow w^t+\lambda y_ix_i$$</p><p>感知机由两层神经元组成，只有输入层神经元进行激活函数处理，学习能力十分有限。他只能在现行线性可分问题上收敛，甚至不能解决疑惑异或问题这样的简单非线性可分问题。</p><p>要解决非线性可分问题需要考虑使用多层神经元</p><h1 id="5-3误差逆传播算法-BP算法"><a href="#5-3误差逆传播算法-BP算法" class="headerlink" title="5.3误差逆传播算法&#x2F;BP算法"></a>5.3误差逆传播算法&#x2F;BP算法</h1><p>BP算法是训练多层神经网络的有效方式，具体可参见<a href="https://brandinzhang.github.io/2024/07/08/%E6%95%B0%E5%AD%A6/%E7%9F%A9%E9%98%B5%E6%B1%82%E5%AF%BC/">矩阵求导技术</a></p><p>数学上可以证明，只需要一个包含足够多神经元的隐藏层，多层前馈网络就可以以任意精度逼近任意复杂度的连续函数。不过如何设计神经网络结构是一个未知问题。</p><p>因为强大的学习能力和表示能力，神经网络容易过拟合，解决过拟合的方法有两种</p><ul><li>早停：训练集误差减小但是测试集误差上升的时候停止训练</li><li>正则化，在loss函数中加一个用于描述网络复杂度的部分</li></ul><p>比如，令$E_k$表示第$k$个样例上的误差，$w_i$表示连接权重，误差函数改变为<br>$$E&#x3D;\lambda\frac1m\sum_{k&#x3D;1}^mE_k+(1-\lambda)\sum_iw_i^2$$<br>超参数$\lambda$使用交叉验证来估计</p><h1 id="5-4全局最小与局部最小"><a href="#5-4全局最小与局部最小" class="headerlink" title="5.4全局最小与局部最小"></a>5.4全局最小与局部最小</h1><p>神经网络的训练应当避免陷入局部最优解，利用梯度搜索方法找到某个最小值之后，人们会采用一些策略跳出可能存在的局部最小，进一步接近全局最小</p><ul><li>不同参数值初始化多个神经网络，训练后取误差最小的解作为最终解</li><li>模拟退火，在每一步都已一定概率接受比当前更差的结果，迭代过程中接受次优解的概率应该逐渐降低</li><li>使用随机梯度下降法</li><li>遗传算法</li></ul><h1 id="5-5其他神经网络"><a href="#5-5其他神经网络" class="headerlink" title="5.5其他神经网络"></a>5.5其他神经网络</h1><h1 id="6-1-间隔与支持向量"><a href="#6-1-间隔与支持向量" class="headerlink" title="6.1 间隔与支持向量"></a>6.1 间隔与支持向量</h1><p>支持向量机用于解决二分类问题，希望找到一个超平面对平面中的点进行合理划分<br>$$\left.\left{\begin{array}{ll}\boldsymbol{w}^\mathrm{T}\boldsymbol{x}<em>i+b\geqslant+1,&amp;y_i&#x3D;+1 ;\\boldsymbol{w}^\mathrm{T}\boldsymbol{x}<em>i+b\leqslant-1,&amp;y_i&#x3D;-1 .\end{array}\right.\right.$$<br>离超平面最近的几个样本点被称为支持向量<br><img src="https://www.freeimg.cn/i/2024/11/09/672f2b47ebbb4.webp" alt="1731144518117.png"><br>并定义间隔为：<br>$$\gamma&#x3D;\frac2{||\boldsymbol{w}||}$$<br>目标是找到最大间隔的超平面<br>$$\begin{aligned}&amp;\max</em>{\boldsymbol{w},b} \frac{2}{||\boldsymbol{w}||}\&amp;\mathrm{s.t.} y_i(\boldsymbol{w}^\mathrm{T}\boldsymbol{x}<em>i+b)\geqslant1,\quad i&#x3D;1,2,\ldots,m.\end{aligned}$$<br>这等价于<br>$$\begin{aligned}&amp;\min</em>{\boldsymbol{w},b} \frac{1}{2} |\boldsymbol{w}|^{2}\&amp;\mathrm{s.t.} y</em>{i}(\boldsymbol{w}^{\mathrm{T} }\boldsymbol{x}_{i}+b)\geqslant1,\quad i&#x3D;1,2,\ldots,m.\end{aligned}$$</p><h1 id="6-2对偶化简"><a href="#6-2对偶化简" class="headerlink" title="6.2对偶化简"></a>6.2对偶化简</h1><p>拉格朗日函数为<br>$$L(\boldsymbol{w},b,\boldsymbol{\alpha})&#x3D;\frac12 |\boldsymbol{w}|^2+\sum_{i&#x3D;1}^m\alpha_i\left(1-y_i(\boldsymbol{w}^\mathrm{T}\boldsymbol{x}_i+b)\right)$$</p><p>令$L(\boldsymbol{w},b,\boldsymbol{\alpha})$对$\boldsymbol{w}$和$b$的偏导为零可得</p><p>$$\boldsymbol{w}&#x3D;\sum_{i&#x3D;1}^m\alpha_iy_i\boldsymbol{x}_i:,$$</p><p>$$0&#x3D;\sum_{i&#x3D;1}^m\alpha_iy_i:.$$</p><p>转为对偶问题<br>$$\max_{\boldsymbol{\alpha} }\quad\sum_{i&#x3D;1}^m\alpha_i-\frac12\sum_{i&#x3D;1}^m\sum_{j&#x3D;1}^m\alpha_i\alpha_jy_iy_j\boldsymbol{x}<em>i^\mathrm{T}\boldsymbol{x}<em>j$$<br>$$\begin{aligned}\mathrm{s.t.}&amp;\sum</em>{i&#x3D;1}^m\alpha_iy_i&#x3D;0 ,\&amp;\alpha_i\geqslant0 ,\quad i&#x3D;1,2,\ldots,m .\end{aligned}$$<br>如何求解？一般来说可以用通用的二次规划方法求解，也可以用SMO算法<br>SMO 的基本思路是先固定$\alpha_i$之外的所有参数，然后求$\alpha_i$上的极值.由于存在约束$\sum</em>{i&#x3D;1}^m\alpha_iy_i&#x3D;0$,若固定$\alpha_i$之外的其他变量，则$\alpha_i$可由其他变量导出. 于是，SMO 每次选择两个变量$\alpha_i$和$\alpha_j$,并固定其他参数. 这样，在参数初始化后，SMO 不断执行如下两个步骤直至收敛：</p><p>$$\text{选取一对需更新的变量 }\alpha_i\text{ 和 }\alpha_j;$$<br>$$\text{固定 }\alpha_i\text{ 和 }\alpha_j\text{ 以外的参数, 求解式}(6.11)\text{获得更新后的 }\alpha_i\text{ 和 }\alpha_j$$</p><p>具体的：<br>$$\alpha_{i}y_{i}+\alpha_{j}y_{j}&#x3D;c , \alpha_{i}\geqslant0 , \alpha_{j}\geqslant0 ,\c&#x3D;-\sum_{k\neq i,j}\alpha_ky_k$$</p><p>为此我们可以求出每一步优化问题的闭式解<br>偏移项可以利用kkt条件求出<br>$$y_s\left(\sum_{i\in S}\alpha_iy_i\boldsymbol{x}_i^\mathrm{T}\boldsymbol{x}_s+b\right)&#x3D;1$$</p><h1 id="6-3-核函数"><a href="#6-3-核函数" class="headerlink" title="6.3 核函数"></a>6.3 核函数</h1><p>原始的假设基于线性可分的思路，分割函数如下</p><p>$$\begin{aligned}<br>f(\boldsymbol{x})&amp; &#x3D;\boldsymbol{w}^\mathrm{T}\boldsymbol{x}+b \<br>&amp;&#x3D;\sum_{i&#x3D;1}^m\alpha_iy_i\boldsymbol{x}_i^\mathrm{T}\boldsymbol{x}+b<br>\end{aligned}$$</p><p>核函数的引入使得svm拥有了拟合非线性边界的问题，核函数把x映射到了高维空间<br>$$f(x)&#x3D;w^\mathrm{T}\phi(x)+b$$<br>最终要求解的对偶问题变为了<br>$$\max_{\alpha} \sum_{i&#x3D;1}^{m}\alpha_{i}-\frac{1}{2} \sum_{i&#x3D;1}^{m}\sum_{j&#x3D;1}^{m}\alpha_{i}\alpha_{j}y_{i}y_{j}\phi(\boldsymbol{x}<em>{i})^{\mathrm{T}}\phi(\boldsymbol{x}</em>{j})$$</p><p>为了避免高维内积的困难，引入核函数<br>$$\kappa(\boldsymbol{x}_i,\boldsymbol{x}_j)&#x3D;\langle\phi(\boldsymbol{x}_i),\phi(\boldsymbol{x}_j)\rangle&#x3D;\phi(\boldsymbol{x}_i)^\mathrm{T}\phi(\boldsymbol{x}_j)$$<br>给出一些常用核函数<br><img src="https://www.freeimg.cn/i/2024/11/09/672f34a0c36ca.webp" alt="1731146911184.png"></p><h1 id="6-4-软间隔与正则化"><a href="#6-4-软间隔与正则化" class="headerlink" title="6.4 软间隔与正则化"></a>6.4 软间隔与正则化</h1><p>允许svm在一些样本上出错，引入软间隔概念<br>比如，采用hinge损失，将目标函数改为<br>$$\min_{\boldsymbol{w},b} \frac{1}{2}|\boldsymbol{w}|^2+C\sum_{i&#x3D;1}^m\max\left(0,1-y_i\left(\boldsymbol{w}^\mathrm{T}\boldsymbol{x}<em>i+b\right)\right)$$<br>引入松弛变量，将上式子改写为<br>$$\min</em>{\boldsymbol{w},b,\xi_i}\quad\frac12|\boldsymbol{w}|^2+C\sum_{i&#x3D;1}^m\xi_i$$<br>$$\mathrm{s.t.}\quad y_i(\boldsymbol{w}^\mathrm{T}\boldsymbol{x}<em>i+b)\geqslant1-\xi_i\\xi</em>{i}\geqslant0 , i&#x3D;1,2,\ldots,m.$$<br>注：约束条件就是变量代换的恒等式<br>拉格朗日乘子法求解出对偶问题<br>$$\begin{aligned}<br>\underset{\boldsymbol{\alpha}}{\operatorname*{max}}&amp; \sum_{i&#x3D;1}^m\alpha_i-\frac12\sum_{i&#x3D;1}^m\sum_{j&#x3D;1}^m\alpha_i\alpha_jy_iy_j\boldsymbol{x}_i^\mathrm{T}\boldsymbol{x}<em>j \<br>\text{s.t.}&amp; \sum</em>{i&#x3D;1}^m\alpha_iy_i&#x3D;0 , \<br>&amp;0\leqslant\alpha_i\leqslant C ,\quad i&#x3D;1,2,\ldots,m .<br>\end{aligned}$$</p><h1 id="6-5支持向量回归SVR"><a href="#6-5支持向量回归SVR" class="headerlink" title="6.5支持向量回归SVR"></a>6.5支持向量回归SVR</h1><p>支持向量回归(Support Vector Regression, 简称 SVR)假设我们能容忍 $f(\boldsymbol{x})$ 与$y$之间最多有$\epsilon$的偏差，即仅当$f(\boldsymbol{x})$与$y$之间的差别绝对值大于$\epsilon$时才计算损失.如图 6.6 所示，这相当于以$f(\boldsymbol{x})$为中心，构建了一个宽度为 2$\epsilon$的间隔带，若训练样本落入此间隔带，则认为是被预测正确的.</p><h1 id="6-6-核方法"><a href="#6-6-核方法" class="headerlink" title="6.6 核方法"></a>6.6 核方法</h1>]]></content>
    
    
    <categories>
      
      <category>机器学习</category>
      
      <category>西瓜书</category>
      
    </categories>
    
    
    <tags>
      
      <tag>机器学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>熵权法模版</title>
    <link href="/2025/03/21/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1/%E7%86%B5%E6%9D%83%E6%B3%95/"/>
    <url>/2025/03/21/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1/%E7%86%B5%E6%9D%83%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h2 id="熵权法的目的是客观赋予每一个评价指标权重，而非主观判断或依靠所谓问卷调查"><a href="#熵权法的目的是客观赋予每一个评价指标权重，而非主观判断或依靠所谓问卷调查" class="headerlink" title="熵权法的目的是客观赋予每一个评价指标权重，而非主观判断或依靠所谓问卷调查"></a>熵权法的目的是客观赋予每一个评价指标权重，而非主观判断或依靠所谓问卷调查</h2><p>熵：是描述混乱程度的量纲.</p><p>信息熵：平均而言发生一个事件我们得到的信息量大小.（得到的信息越多，已掌握的信息越少）</p><p>熵权法：是一种可以对多对象、多指标进行综合评价的方法，其评价依据来源于数据本身，几乎不受主观因素的干扰.</p><p>它的基本思想是：信息熵小→得到的信息少，掌握的信息多→这组信息更靠谱→权重大.</p><h1 id="step1-正向化处理"><a href="#step1-正向化处理" class="headerlink" title="step1 正向化处理"></a>step1 正向化处理</h1><p><img src="https://img.simpletex.net/pdf/BzBdZgBf/fzDM6FmFdfcT1xiNkBu0NOlIyccFcdkV2.png"></p><ul><li>某个指标越小越好：极小型转极大型 $max-x$ 或$1&#x2F;x$</li><li>某个指标越接近某个值越好：<br>$$M&#x3D;\max\left{|x_i-x_{\mathrm{best}}|\right},\quad\tilde{x}<em>i&#x3D;1-\frac{|x_i-x</em>{\mathrm{best}}|}M$$</li><li>落在某个区间最好<br>区间型转极大型：数值不要太大也不要太小，落在某个区间最好，如人体温度值落在36~37°C最好.<br>设对于一组区间型指标${x_i}$其最佳区间为$[a,b]$那么可以这样正向化：<br>先算最值到边界的最大距离$M&#x3D;\max\left{a-\min\left{x_i\right},\max\left{x_i\right}-b\right}$,再令各元素$\tilde{x}_i$<br>$$\begin{aligned}&amp;\tilde{x}_i&#x3D;\begin{cases}1-\frac{a-x_i}M&amp;,x_i&lt;a\1&amp;,a\leq x_i\leq b\1-\frac{x_i-b}M&amp;,x_i&gt;b&amp;\end{cases}\end{aligned}$$</li></ul><h1 id="step2标准化处理"><a href="#step2标准化处理" class="headerlink" title="step2标准化处理"></a>step2标准化处理</h1><p>已有正向化处理之后的矩阵<br> $\begin{aligned}&amp; X&#x3D;\begin{bmatrix}x_{11}&amp;x_{12}&amp;\cdots&amp;x_{1m}\x_{21}&amp;x_{22}&amp;\cdots&amp;x_{2m}\\varvdots&amp;\varvdots&amp;\ddots&amp;\varvdots\x_{21}&amp;\cdots&amp;x_{2m}\end{bmatrix}\end{aligned}$</p><p>设标准化的矩阵为$Z$,那么$Z$中的每一个元素：$\tilde{z}<em>{ij}&#x3D;\frac{x</em>{ij}}{\sqrt{\sum_{i&#x3D;1}^nx_{ij}^2}}$</p><p>得到标准化矩阵<br>$$\tilde{Z}&#x3D;\begin{bmatrix}\tilde{z}<em>{11}&amp;\tilde{z}</em>{12}&amp;\cdots&amp;\tilde{z}<em>{1m}\\tilde{z}</em>{21}&amp;\tilde{z}<em>{22}&amp;\cdots&amp;\tilde{z}</em>{2m}\\vdots&amp;\vdots&amp;\ddots&amp;\vdots\\tilde{z}<em>{n1}&amp;\tilde{z}</em>{n2}&amp;\cdots&amp;\tilde{z}_{nm}\end{bmatrix}$$</p><h1 id="step3计算信息熵和熵权"><a href="#step3计算信息熵和熵权" class="headerlink" title="step3计算信息熵和熵权"></a>step3计算信息熵和熵权</h1><p>计算信息熵<br>$$e_j&#x3D;-\frac1{\ln n}\sum_{i&#x3D;1}^np_{ij}\ln\left(p_{ij}\right)(j&#x3D;1,2,\cdots,m)$$<br>求出每一个特征的信息效用值<br>$$d_j{&#x3D;}1-e_j$$<br>归一化求得熵权<br>$$W_j&#x3D;d_j&#x2F;\sum_{j&#x3D;1}^md_j\left(j&#x3D;1,2,\cdotp\cdotp\cdotp,m\right)$$</p>]]></content>
    
    
    <categories>
      
      <category>数学建模</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>微观经济学</title>
    <link href="/2025/03/21/%E6%9D%82%E8%B0%88/%E7%BB%8F%E6%B5%8E%E5%AD%A6%E5%8E%9F%E7%90%86%E5%AE%8C%E6%95%B4%E7%89%88/"/>
    <url>/2025/03/21/%E6%9D%82%E8%B0%88/%E7%BB%8F%E6%B5%8E%E5%AD%A6%E5%8E%9F%E7%90%86%E5%AE%8C%E6%95%B4%E7%89%88/</url>
    
    <content type="html"><![CDATA[<h1 id="第二章：需求供给和均衡价格"><a href="#第二章：需求供给和均衡价格" class="headerlink" title="第二章：需求供给和均衡价格"></a>第二章：需求供给和均衡价格</h1><p>符号说明</p><ul><li>P表示price，价格</li><li>Q表示Quantity，数量</li></ul><h2 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h2><ul><li>需求是在一定的时期，在一既定的价格水平下，消费者愿意并且能够购买的商品数量</li><li>假定其它条件不变，需求量与价格之间成反方向变动</li></ul><h3 id="影响需求量的因素"><a href="#影响需求量的因素" class="headerlink" title="影响需求量的因素"></a>影响需求量的因素</h3><p>需求是一个函数，一条曲线，需求量是函数上的一个点</p><ul><li>需求量的变动：“沿着需求曲线的移动”<br>Movements along Demand Curves<br>这种变动是由该商品价格的变动引起的。</li></ul><p><a href="https://imgse.com/i/pAoera8"><img src="https://s21.ax1x.com/2024/12/03/pAoera8.md.png" alt="pAoera8.md.png"></a></p><ul><li>需求的变动：“需求曲线的移动”<br>Shifts of Demand Curves<br>这种变动是由价格之外的其他因素的变动引起的。</li></ul><p><a href="https://imgse.com/i/pAoecGQ"><img src="https://s21.ax1x.com/2024/12/03/pAoecGQ.png" alt="pAoecGQ.png"></a></p><h2 id="供给"><a href="#供给" class="headerlink" title="供给"></a>供给</h2><ul><li><p>供给量的变动”是“沿着供给曲线的移动”<br>Movements along Supply Curves<br>这种变动是由该商品价格的变动引起的。</p></li><li><p>“供给的变动”是“供给曲线的移动”<br>Shifts of Supply Curves<br>这种变动是由价格之外的其他因素的变动引起的。</p></li></ul><p>市场供给是市场上所有的单个生产者的供给的总和</p><h2 id="均衡价格"><a href="#均衡价格" class="headerlink" title="均衡价格"></a>均衡价格</h2><p>此时供给与需求平衡</p><h2 id="弹性"><a href="#弹性" class="headerlink" title="弹性"></a>弹性</h2><p>需求与供给随着价格的变动而变动。比如需求随价格上涨而降低；供给随价格上涨而增加。</p><p>那么价格变动后，需求或者供给反应程度有多大呢？</p><p>这个就是“弹性”的概念了。数学上弹性其实就是相对导数</p><p>市场由供给和需求两侧构成的，弹性需要对双方进行评测，及“需求价格弹性”和“供给价格弹性”。</p><p>定义<br>$$  \frac {\Delta y&#x2F;y}{\Delta x&#x2F;x}$$<br>y的x弹性，</p><p>例如$\varepsilon&#x3D;\frac{\partial Q_d}{\partial p}\frac{p}{Q_d}$为需求的价格弹性，对他进行分情况讨论</p><p>Elastic: |ε|&gt;1 ；Inelastic： |ε|&lt;1 ；Unit elastic： |ε|&#x3D;1 </p><p><a href="https://imgse.com/i/pATQhBd"><img src="https://s21.ax1x.com/2024/12/05/pATQhBd.md.png" alt="pATQhBd.md.png"></a></p><h2 id="线性需求曲线上弹性的几何意义"><a href="#线性需求曲线上弹性的几何意义" class="headerlink" title="线性需求曲线上弹性的几何意义"></a>线性需求曲线上弹性的几何意义</h2><p>依然考虑的是需求价格弹性</p><p><a href="https://imgse.com/i/pATQqgS"><img src="https://s21.ax1x.com/2024/12/05/pATQqgS.md.png" alt="pATQqgS.md.png"></a></p><h2 id="需求收入弹性"><a href="#需求收入弹性" class="headerlink" title="需求收入弹性"></a>需求收入弹性</h2><p>根据需求收入弹性，可以判断该商品是奢侈品、必需品，还是低档品（劣等品）。</p><p>Normal good: $\varepsilon _y&gt; 0$</p><p>Necessity:$0&lt;\varepsilon_y&lt;1$</p><p>Luxury: $\varepsilon_y&gt;1$</p><p>Inferior good:$\varepsilon _y&lt; 0$</p><h2 id="交叉价格弹性"><a href="#交叉价格弹性" class="headerlink" title="交叉价格弹性"></a>交叉价格弹性</h2><p>需求交叉价格弹性（Cross-price elasticity of demand），简称交叉价格弹性，用于衡量一种商品的需求量对另一种商品价格变动的敏感程度。根据需求交叉价格弹性，我们可以判断两种商品之间的关系：它们是替代品、互补品，还是无关品。</p><p>$$\varepsilon_{p_z}&#x3D;\frac{\partial Q_d}{\partial p_z}\frac{p_z}{Q_d}$$</p><ol><li><p><strong>替代品</strong>：</p><ul><li><strong>关系定义</strong>：两种商品之间可以互相替代以满足消费者的某一种欲望，则这两种商品互为替代品。</li><li><strong>交叉价格弹性系数特征</strong>：当两种商品之间存在替代关系时，需求交叉价格弹性为正（Exy&gt;0）。这意味着，当其中一种商品（如商品Y）价格上涨时，消费者可能会转向购买另一种可替代的商品（如商品X），从而导致商品X的需求量增加。</li><li><strong>实例</strong>：大米与小麦、汽油与柴油等。当汽油价格上涨时，消费者可能会选择购买柴油车，从而增加柴油的需求量。</li></ul></li><li><p><strong>互补品</strong>：</p><ul><li><strong>关系定义</strong>：两种商品必须同时使用才能满足消费者的某一种欲望，则这两种商品互为互补品。</li><li><strong>交叉价格弹性系数特征</strong>：当两种商品之间存在互补关系时，需求交叉价格弹性为负（Exy&lt;0）。这意味着，当其中一种商品（如胶卷）价格上涨时，消费者可能会减少购买，同时减少对另一种互补商品（如相机）的需求。</li><li><strong>实例</strong>：汽车与汽油、相机与胶卷等。当汽油价格上涨时，消费者可能会减少汽车的使用，从而降低对汽油的需求。</li></ul></li><li><p><strong>无关品</strong>：</p><ul><li><strong>关系定义</strong>：两种商品之间既不存在替代关系也不存在互补关系，即它们的需求量是相互独立的。</li><li><strong>交叉价格弹性系数特征</strong>：当两种商品之间无相关关系时，需求交叉价格弹性为零（Exy&#x3D;0）。这意味着，一种商品价格的变化对另一种商品的需求量没有影响。</li><li><strong>实例</strong>：手机和面包通常被视为相互独立的商品，手机价格的变动不太可能影响面包的需求量。</li></ul></li></ol><h1 id="第三章：消费者行为理论"><a href="#第三章：消费者行为理论" class="headerlink" title="第三章：消费者行为理论"></a>第三章：消费者行为理论</h1><h2 id="效用理论"><a href="#效用理论" class="headerlink" title="效用理论"></a>效用理论</h2><ul><li>效用（utility）：U，简单的理解为消费者的收获&#x2F;满足程度</li></ul><p>效用有两种表示，一种是基于数量的基数效用</p><ul><li>消费者消费一定数量的商品或服务获得的效用满足以基数个单位表示出来的效用，例如1、2、3。</li><li>核心观点：效用是可以计量的，是可以加总求和的。</li><li>计量单位：效用单位（utils）。</li><li>分析方法：边际效用分析法</li></ul><p>一种是基于排序的序数效用。</p><ul><li>消费者对消费商品获得的效用满足程度不是以基数衡量，而是对不同商品组合按效用满足高低进行排序。</li><li>核心观点：效用只能用序数来表示。效用作为一种心理现象无法计量，也不能加总求和，只能表示出满足程度的高低与顺序。</li><li>分析方法：无差异曲线分析法</li></ul><h3 id="符号"><a href="#符号" class="headerlink" title="符号"></a>符号</h3><ul><li>总效用（total Utility）TU</li><li>边际效用（Marginal Utility） $MU &#x3D; \frac{dU}{dQ}$ 指的是增加单位产生的效用增加量</li></ul><h3 id="基数效用的描述：效用曲线"><a href="#基数效用的描述：效用曲线" class="headerlink" title="基数效用的描述：效用曲线"></a>基数效用的描述：效用曲线</h3><p>衡量基数效用使用总效用曲线与边际效用曲线，其中边际效用满足边际效用递减定律<br><a href="https://imgse.com/i/pAodwsx"><img src="https://s21.ax1x.com/2024/12/04/pAodwsx.md.png" alt="pAodwsx.md.png"></a></p><h3 id="序数效用的描述：无差异曲线"><a href="#序数效用的描述：无差异曲线" class="headerlink" title="序数效用的描述：无差异曲线"></a>序数效用的描述：无差异曲线</h3><p>无差异曲线（Indifference Curve，IC）是用来表示（消费者）偏好相同的两种商品的不同数量的各种组合的（平面曲线）。<br><a href="https://imgse.com/i/pAodRSA"><img src="https://s21.ax1x.com/2024/12/04/pAodRSA.md.png" alt="pAodRSA.md.png"></a></p><h3 id="边际替代率-（Marginal-Rate-of-Substitution，MRS）"><a href="#边际替代率-（Marginal-Rate-of-Substitution，MRS）" class="headerlink" title="边际替代率 （Marginal Rate of Substitution，MRS）"></a>边际替代率 （Marginal Rate of Substitution，MRS）</h3><p>在维持效用水平或满足程度不变的前提下，消费者增加 1 单位的某种商品的消费时，所需要放弃的另一种商品的消费数量。(是一个正数)<br>比如，考虑商品1对商品2的替代率</p><p>$MRS_{12}&#x3D;-\frac{\Delta X_2}{\Delta X_1}$</p><p>边际替代率也是递减的，且任意两商品的边际替代率等于该两种商品的边际效用之比，因为<br>$$\operatorname dU&#x3D;\frac{\partial U}{\partial X_1}\cdot\operatorname{d}X_1+\frac{\partial U}{\partial X_2}\cdot\operatorname{d}X_2&#x3D;0$$</p><ul><li>完全替代品，两种商品之间的替代比例不变</li></ul><p>$$U(X_1,X_2)&#x3D;aX_1+bX_2$$</p><p><a href="https://imgse.com/i/pAodLSs"><img src="https://s21.ax1x.com/2024/12/04/pAodLSs.md.png" alt="pAodLSs.md.png"></a></p><ul><li>完全互补品,两商品必须按照一定比例搭配使用</li></ul><p>$$U &#x3D; min{ aX_1,bX_2 }$$</p><p><a href="https://imgse.com/i/pAowZm6"><img src="https://s21.ax1x.com/2024/12/04/pAowZm6.md.png" alt="pAowZm6.md.png"></a></p><h2 id="预算约束曲线"><a href="#预算约束曲线" class="headerlink" title="预算约束曲线"></a>预算约束曲线</h2><p>$$ P_1 X_1+P_2 X_2 &#x3D; I $$<br><a href="https://imgse.com/i/pAowDcn"><img src="https://s21.ax1x.com/2024/12/04/pAowDcn.md.png" alt="pAowDcn.md.png"></a></p><h2 id="剩余"><a href="#剩余" class="headerlink" title="剩余"></a>剩余</h2><h4 id="消费者剩余"><a href="#消费者剩余" class="headerlink" title="消费者剩余"></a>消费者剩余</h4><ul><li>定义：消费者剩余是指消费者愿意支付的价格与实际购买商品或服务所需支付的价格之间的差额。简单来说，就是消费者在购买商品或服务时，感觉自己“赚”到的那部分价值。</li><li>例子：假设你想买一件衣服，你最多愿意支付100元，但实际上这件衣服只卖80元。那么，你在这笔交易中获得的消费者剩余就是20元。这20元并不是你实际得到的现金，而是你心理上感觉到的额外满足或“赚”到的价值。</li><li>意义：消费者剩余是衡量消费者福利的重要指标。它反映了消费者对商品或服务的满意程度，以及市场交易给消费者带来的额外利益。</li></ul><h4 id="生产者剩余"><a href="#生产者剩余" class="headerlink" title="生产者剩余"></a>生产者剩余</h4><ul><li>定义：生产者剩余是指生产者在销售商品或服务时所获得的经济利益，具体计算方式是实际销售价格与生产成本之间的差额。简单来说，就是生产者通过销售商品或服务，“多赚”到的那部分利润。</li><li>例子：假设一家工厂生产一件商品的成本是50元，但这件商品在市场上的售价是80元。那么，这家工厂在这件商品上获得的生产者剩余就是30元。这30元是工厂的实际利润，也是生产者剩余。</li><li>意义：生产者剩余衡量了生产者在市场交易中获得的额外收益。它反映了生产者的盈利能力，也是生产者愿意继续参与市场交易的动力之一。</li></ul><h2 id="消费者行为求解：效用最大化"><a href="#消费者行为求解：效用最大化" class="headerlink" title="消费者行为求解：效用最大化"></a>消费者行为求解：效用最大化</h2><p>消费者要实现效用最大化，其购买行为必须满足两个条件：</p><p>（1）最优的商品购买组合必须位于给定的预算线上 ；<br>（2）最优的商品购买组合必须是消费者在预算可行集中最偏好的。                 </p><p><a href="https://imgse.com/i/pAowrXq"><img src="https://s21.ax1x.com/2024/12/04/pAowrXq.md.png" alt="pAowrXq.md.png"></a></p><p>做题一般就是利用KKT条件求解切线点。</p><h2 id="价格—消费曲线"><a href="#价格—消费曲线" class="headerlink" title="价格—消费曲线"></a>价格—消费曲线</h2><p>在最大效用假设的前提下，商品的价格P和商品的消费数量X之间的关系</p><ul><li><p>替代效应<br>替代效应是指，在消费者的实际收入不变的情况下，某种商品价格的变动会导致消费者选择购买其他替代品的行为变化。简单来说，就是当一种商品价格上涨时，消费者可能会转而购买其价格相对较低、功能相似的替代品。</p></li><li><p>收入效应<br>收入效应则是指，在消费者的名义收入（即货币数量）不变的情况下，某种商品价格的变动会导致消费者的实际购买力或消费能力发生变化，从而影响对该商品的需求量。</p></li></ul><p><strong>关键点总结</strong></p><ul><li>替代效应：商品价格变动-&gt;消费者买替代品的倾向变动-&gt;该商品需求变动</li><li>收入效应：商品价格变动-&gt;消费者实际购买力（收入）变动-&gt;该商品需求变动</li></ul><p>在下文的说明中，如果一个效应使得需求变大了，就说这个效应此时表现为正向，反之为负向。</p><h4 id="正常物品"><a href="#正常物品" class="headerlink" title="正常物品"></a>正常物品</h4><p>指的是消费者收入越高，需求越大的商品</p><p>当商品降价时，替代效应为正向，收入效应也为正向，消费者需求变大</p><h4 id="低档物品"><a href="#低档物品" class="headerlink" title="低档物品"></a>低档物品</h4><p>指的是消费者收入越高，需求越小的商品，在收入者收入变小的时候需求反而增大</p><p>当商品降价时，替代效应为正向，收入效应反而为负向，一般而言替代效应的影响更大，消费者还是倾向于加大购买，需求上升。</p><p>特殊情况下，收入效应更大，商品降价的时候需求减少，称之为吉芬物品。</p><p><a href="https://imgse.com/i/pAorzi8"><img src="https://s21.ax1x.com/2024/12/04/pAorzi8.md.png" alt="pAorzi8.md.png"></a></p><h1 id="第四章：企业的生产和成本"><a href="#第四章：企业的生产和成本" class="headerlink" title="第四章：企业的生产和成本"></a>第四章：企业的生产和成本</h1><h2 id="生产函数"><a href="#生产函数" class="headerlink" title="生产函数"></a>生产函数</h2><p>定义<br>$$ Q&#x3D;f(L,k)$$<br>$L$为劳动，$K$为资本,$Q$代表能生产的最大产量<br>短期就是指仅有一个变量可以边，长期指的是两个变量都可以变</p><h2 id="生产函数重要规律：边际报酬递减"><a href="#生产函数重要规律：边际报酬递减" class="headerlink" title="生产函数重要规律：边际报酬递减"></a>生产函数重要规律：边际报酬递减</h2><p>边际报酬递减规律(The Law of Diminishing Return)：在技术水平和其他要素投入量不变的条件下，只增加某一要素的投入量，在一定范围内，这种要素的<strong>边际产量先递增</strong>，但当要素投入量超过一定<strong>临界点</strong>之后，这种要素的边际产量递减。</p><h2 id="短期生产"><a href="#短期生产" class="headerlink" title="短期生产"></a>短期生产</h2><h3 id="短期生产的三个产量指标"><a href="#短期生产的三个产量指标" class="headerlink" title="短期生产的三个产量指标"></a>短期生产的三个产量指标</h3><p>总产量(Total Product)：使用一定量生产要素所生产出来的全部产量。<br>$$TP &#x3D; f ( L, K)$$<br>平均产量(Average Product)：平均每单位生产要素所生产的产量。<br>$$AP &#x3D; TP&#x2F;L$$<br>边际产量(Marginal Product)：每增加一个单位生产要素所带来的总产量的变动量。<br>$$MP﹦△TP&#x2F;△L$$<br><a href="https://imgse.com/i/pAoyzvQ"><img src="https://s21.ax1x.com/2024/12/04/pAoyzvQ.md.png" alt="pAoyzvQ.md.png"></a><br>TPL线和APL线的关系：</p><ul><li>TPL线上任意一点与坐标原点所连接的线段的斜率都可以表示为该点上的APL值</li><li>APL最高点对应于TPL的最斜切线切点</li></ul><p>MPL线和APL线的关系：</p><ul><li>当MPL&gt; APL , APL↑  </li><li>当MPL &lt; APL , APL↓  </li><li>当MPL &#x3D; APL , APL最高，边际产量曲线与平均产量曲线相交，劳动力的平均产量等于劳动力的边际产量</li></ul><h3 id="短期生产的三个阶段"><a href="#短期生产的三个阶段" class="headerlink" title="短期生产的三个阶段"></a>短期生产的三个阶段</h3><p><a href="https://imgse.com/i/pAo6156"><img src="https://s21.ax1x.com/2024/12/04/pAo6156.md.png" alt="pAo6156.md.png"></a></p><ul><li>第一个阶段: 0～$AP_{max}$<br>劳动的平均产出递增，生产规模效益的表现；</li><li>第二个阶段: $AP_{max}$～$TP_{max}$<br>平均产出递减，总产出增速放慢；</li><li>第三个阶段: $TP_{max}$～<br>边际产出为负，总产出绝对下降。</li></ul><h2 id="长期生产"><a href="#长期生产" class="headerlink" title="长期生产"></a>长期生产</h2><h3 id="等产量线"><a href="#等产量线" class="headerlink" title="等产量线"></a>等产量线</h3><p>长期生产考虑到所有变量都可以变化，应当得到等产量曲线簇</p><p><a href="https://imgse.com/i/pAo6Urd"><img src="https://s21.ax1x.com/2024/12/04/pAo6Urd.md.png" alt="pAo6Urd.md.png"></a></p><p>类似的可以定义，边际技术替代率(marginal rate of technical substitution)：在维持产量水平不变的条件下，增加一单位某种生产要素投入量时所减少的另一种要素的投入数量。即，等产量曲线斜率的相反数（绝对值）<br>$$\boldsymbol{MRTS}_{\boldsymbol{LK}}&#x3D;-\frac{\Delta K}{\Delta L}$$<br>常见的<strong>等产量线</strong>有三</p><p>线性生产函数，生产要素之间的替代比例都是固定的<br>$$Q&#x3D;aL+bK$$<br>里昂惕夫生产函数：在每一个产量水平上任何一对要素投入量之间的比例都是固定的。即完全互补投入，完全不能替代。<br>$$Q&#x3D;Amin{  \frac{L}{u},\frac{K}{v}   }$$<br>柯布道格拉斯（C-D）生产函数：<br>$$Q&#x3D;AL^\alpha K^\beta$$</p><ul><li>A表示技术水平状况的技术系数，A越大，既定劳动和资本的投入数量所能生产的产量越大;</li><li>$\alpha$为产量劳动弹性，为劳动所得在总产量中所占的份额，劳动投入增加1%则产出增加的百分比为$\alpha$；</li><li>$\beta$表示产量资本弹性，为资本所得在总产量中所占的份额。</li></ul><h3 id="等成本线"><a href="#等成本线" class="headerlink" title="等成本线"></a>等成本线</h3><p>等成本线(Isocost Curve) ：在资本和劳动价格既定条件下，一定数量成本所能购买到的两种生产要素的各种最大组合的连线。<br><a href="https://imgse.com/i/pAo6jd1"><img src="https://s21.ax1x.com/2024/12/04/pAo6jd1.md.png" alt="pAo6jd1.md.png"></a><br>斜率绝对值为$\frac{w}{r}$，其中wr分别代表对应的价格</p><h3 id="生产要素最优组合"><a href="#生产要素最优组合" class="headerlink" title="生产要素最优组合"></a>生产要素最优组合</h3><p><a href="https://imgse.com/i/pAocMQg"><img src="https://s21.ax1x.com/2024/12/04/pAocMQg.md.png" alt="pAocMQg.md.png"></a></p><p>生产扩展线(Expansion Path):随着成本或者产量增加，按照企业的所有生产要素最优组合点描绘出来的一条曲线。</p><p><a href="https://imgse.com/i/pAoW48P"><img src="https://s21.ax1x.com/2024/12/04/pAoW48P.png" alt="pAoW48P.png"></a></p><h2 id="规模报酬"><a href="#规模报酬" class="headerlink" title="规模报酬"></a>规模报酬</h2><p>表示其他条件不变的情况下，企业内部各种生产要素按相同比例变化时所带来的产量变化。用以衡量企业规模与产量之间的关系。</p><p>规模报酬递增，指的是参数线性放大会导致产量更大规模的变大<br>$$f(\lambda L,\lambda K)&gt;\lambda f(L,K)$$<br>规模报酬不变：产量增加的比例等于各种生产要素增加的比例。<br>$$f(\lambda L,\lambda K)&#x3D;\lambda f(L,K)$$<br>规模报酬递减：<br>$$f(\lambda L,\lambda K)&lt;\lambda f(L,K)$$</p><h2 id="成本"><a href="#成本" class="headerlink" title="成本"></a>成本</h2><ul><li><p>生产成本(Accounting Cost)：表示生产一定量的产品所支付的费用。取决于产量Q和各种生产要素的价格P。</p></li><li><p>显成本(Explicit Cost)：会计成本，厂商在要素市场上购买或租用所需要的生产要素的实际支出。一般以货币形式支付并直接反映在帐面上。</p></li><li><p>隐成本(Implicit Cost)：对自己拥有的、且被用于生产的要素应支付的费用。不在帐目上反映。如：自有房屋作厂房，在会计账目上并无租金支出。</p></li><li><p>会计成本&#x3D;机会成本—隐成本&#x3D;显成本</p></li><li><p>生产成本&#x3D;机会成本&#x3D;显成本+隐成本</p></li></ul><h3 id="短期成本"><a href="#短期成本" class="headerlink" title="短期成本"></a>短期成本</h3><ul><li>总成本TC：厂商在短期内为生产一定数量的产品对全部生产要素所支出的总成本。</li><li>可变成本VC：厂商在短期内必须支付的能够调整的要素费用。随产量变动而变动。包括：原材料、燃料支出和工人工资。</li><li>固定成本FC：厂商在短期内必须支付的不能调整的要素费用。固定不变，不随产量变动而变动。包括：厂房和设备折旧，及管理人员工资。</li></ul><p>$$TC(Q)&#x3D;FC+VC$$</p><p>如果是短期总成本，那么K应该是不变的，为此</p><p>$$STC(Q)&#x3D;TFC+TVC&#x3D;w\bullet L(Q)+r\bullet\overline{K}$$<br>$$STC(Q)&#x3D;f(Q)+b$$</p><p><a href="https://imgse.com/i/pAo4UEQ"><img src="https://s21.ax1x.com/2024/12/04/pAo4UEQ.png" alt="pAo4UEQ.png"></a></p><p>短期平均成本也有类似的定义<br>$$SAC&#x3D;AFC+AVC$$</p><h3 id="几个关系"><a href="#几个关系" class="headerlink" title="几个关系"></a>几个关系</h3><p>边际产量与边际成本</p><p>记L(Q)为短期内劳动关于产量的函数<br>求边际成本（产量扩增，成本的变化，）<br>$$MC&#x3D;\frac{dTC}{dQ}&#x3D;\frac{d\left(w\cdot L(Q)+r\cdot\overline{K}\right)}{dQ}&#x3D;w\cdot\frac{dL(Q)}{d(Q)}+0$$<br>求边际产量（成本因素L扩增，产量Q的变化）<br>$$MP_L&#x3D;\frac{dQ}{dL(Q)}$$</p><h3 id="长期成本"><a href="#长期成本" class="headerlink" title="长期成本"></a>长期成本</h3><p>长期总成本LTC：厂商在长期中在每一个产量水平上通过选择最优的生产规模所能达到的最低总成本。<br><a href="https://imgse.com/i/pAoIGTg"><img src="https://s21.ax1x.com/2024/12/04/pAoIGTg.md.png" alt="pAoIGTg.md.png"></a></p><h2 id="规模经济"><a href="#规模经济" class="headerlink" title="规模经济"></a>规模经济</h2><p>规模经济：即内在经济，厂商由自身内部规模扩大所引起的经济效益的提高</p><p>规模不经济：即内在不经济，是指随着厂商规模扩张到一定程度，由于本身规模过大而引起的经济效益的下降。</p><h1 id="第五章：完全竞争市场"><a href="#第五章：完全竞争市场" class="headerlink" title="第五章：完全竞争市场"></a>第五章：完全竞争市场</h1><h2 id="5-1企业利润最大化"><a href="#5-1企业利润最大化" class="headerlink" title="5.1企业利润最大化"></a>5.1企业利润最大化</h2><h3 id="收益R-revenue"><a href="#收益R-revenue" class="headerlink" title="收益R(revenue)"></a>收益R(revenue)</h3><p>收益$R&#x3D;PQ&#x3D;P(Q)Q$<br>平均收益$AR&#x3D;P(Q)$<br>边际收益$MR&#x3D;\frac{dR}{dQ}$</p><p>市场需求函数取决于消费者的行为, 企业面临的需求函数不仅取决于消费者行为, 常常还要取决于同一市场中其他企业的行为。</p><h3 id="利润"><a href="#利润" class="headerlink" title="利润"></a>利润</h3><p>利润&#x3D;收益&#x3D;成本<br>$$\pi(Q)&#x3D;R(Q)-C(Q)$$<br>利润最大化的条件是<br>$$\pi(Q)^{&#96;}&#x3D;0$$<br>$$MR(Q)-MC(Q)&#x3D;0$$</p><h2 id="5-2完全竞争企业价格，收益"><a href="#5-2完全竞争企业价格，收益" class="headerlink" title="5.2完全竞争企业价格，收益"></a>5.2完全竞争企业价格，收益</h2><p>在完全竞争市场上，企业价格是价格的被动接受者，其需求函数非常简单，即</p><p>$$P&#x3D;P(Q)&#x3D;P_0$$</p><p>完全竞争企业的收益是其产量的线性函数，且与其产量成正比，斜率由市场价格$P_0$决定。即：<br>$$R&#x3D;P_0Q $$<br>$$AR&#x3D;P_0$$<br>$$MR&#x3D;P_0$$</p><p><a href="https://imgse.com/i/pAT1yQO"><img src="https://s21.ax1x.com/2024/12/05/pAT1yQO.md.png" alt="pAT1yQO.md.png"></a></p><ul><li><p>D：指市场需求曲线（Demand Curve）。在完全竞争市场中，市场需求曲线是一条向右下方倾斜的曲线，表示随着产品价格的下降，消费者对产品的需求量会增加。</p></li><li><p>S：指市场供给曲线（Supply Curve）。在完全竞争市场中，市场供给曲线是一条向右上方倾斜的曲线，表示随着产品价格的上升，生产者愿意提供的产品数量会增加。</p></li></ul><p>d：代表单个厂商的需求曲线（Firm Demand Curve），在完全竞争市场中，由于厂商是市场价格的被动接受者，因此其需求曲线d是一条水平线，表示无论厂商销售多少产品，其销售价格（即市场价格）都保持不变。<br>MR：代表边际收益（Marginal Revenue），是指增加一单位产品销售所带来的额外收益。在完全竞争市场中，由于市场价格是固定的，因此边际收益MR等于市场价格。</p><h2 id="5-3完全竞争企业的短期均衡"><a href="#5-3完全竞争企业的短期均衡" class="headerlink" title="5.3完全竞争企业的短期均衡"></a>5.3完全竞争企业的短期均衡</h2><p>短期利润，就是销售额减去短期成本$STC(Q)$<br>$$R&#x3D;PQ-STC$$<br>短期平衡条件，就是利润最大化了<br>$$R最大，\frac{dR}{dQ}&#x3D;0$$<br>$$P&#x3D;SMC$$<br>何时企业会停产？无论如何增加Q，无论Q为多大，利润R都不会增加了<br>$$R&#x3D;(P-SAC)Q&lt;0$$<br>$$P&lt;min(SAC)$$<br>如何求短期供给函数？，由$P&#x3D;SMC$反解出$Q$，保留使得$R&gt;0$的Q的解</p><h2 id="5-4完全竞争企业和市场的长期均衡"><a href="#5-4完全竞争企业和市场的长期均衡" class="headerlink" title="5.4完全竞争企业和市场的长期均衡"></a>5.4完全竞争企业和市场的长期均衡</h2><p>长期利润就是销售额减长期成本$LTC(Q)$<br>$$R&#x3D;PQ-LTC$$<br>长期均衡，满足零利润条件与平均成本最小条件<br>$$PQ-LTC&#x3D;0$$<br>$$min(LAC)$$</p><h2 id="5-5完全竞争市场的福利最大化"><a href="#5-5完全竞争市场的福利最大化" class="headerlink" title="5.5完全竞争市场的福利最大化"></a>5.5完全竞争市场的福利最大化</h2><p>完全竞争市场均衡实现了总剩余最大化</p><p><a href="https://imgse.com/i/pAT396U"><img src="https://s21.ax1x.com/2024/12/05/pAT396U.md.png" alt="pAT396U.md.png"></a></p><p><a href="https://imgse.com/i/pAT3wng"><img src="https://s21.ax1x.com/2024/12/06/pAT3wng.md.png" alt="pAT3wng.md.png"></a></p><h1 id="第六章-不完全竞争市场"><a href="#第六章-不完全竞争市场" class="headerlink" title="第六章 不完全竞争市场"></a>第六章 不完全竞争市场</h1><p>以下是对垄断、价格歧视和寡头概念的详细解释：</p><h3 id="垄断"><a href="#垄断" class="headerlink" title="垄断"></a>垄断</h3><ol><li><p><strong>定义</strong>：垄断指的是市场上只有一个或少数几个卖方，这些卖方可以控制市场上的商品或服务的供给和价格。垄断者可以根据自己的利益需求，调节价格与产量。垄断行业就是行业或市场中只有一个或极少数厂商的情况。而垄断市场就是指整个行业中只有一个或极少数的厂商的市场组织。</p></li><li><p><strong>供给曲线</strong>：在垄断市场条件下，无法得到如完全竞争条件下的具有规律性的可以表示产量和价格之间一一对应关系的厂商和行业的短期供给曲线。因此，对于垄断厂商来说，其供给曲线是不存在的。</p></li><li><p><strong>产生原因</strong>：垄断的基本原因是进入障碍，也就是说，垄断厂商能在其市场上保持唯一卖者的地位，是因为其他企业不能进入市场并与之竞争。</p></li><li><p><strong>种类</strong>：</p><ul><li><strong>特许垄断</strong>：有些独家经营的特权是由法律所规定并受到法律保护的，专利权和版权便是法律特许的垄断。为鼓励创造发明，绝大多数国家制定有专利法，可见专利垄断是由法律壁垒造成的。在某些场合下，政府授予某厂商独家经营的权利；也有时政府经过招标竞争通过合同的形式授予独家经营的特权。</li><li><strong>规模经济与自然垄断</strong>：如果某种产品需要大量固定设备投资，大规模生产可以使成本大大降低，那么，一个大厂商就可能成为该行业的唯一生产者。由一个大厂商供给全部市场需求时平均成本最低，两个或两个以上厂商在该市场上经营就难以获得利润，这种情况下，该厂商就形成自然垄断。</li><li><strong>技术性与策略性垄断</strong>：如果除垄断者外另无他人掌握某种生产技术或诀窍，该市场自然形成技术性垄断。在既无技术壁垒又无法律壁垒的情况下，厂商通过高筑壁垒以确立或巩固其垄断地位，这便是策略性垄断。</li></ul></li></ol><h3 id="价格歧视"><a href="#价格歧视" class="headerlink" title="价格歧视"></a>价格歧视</h3><p>以下是一级、二级、三级价格歧视的具体例子：</p><h4 id="一级价格歧视"><a href="#一级价格歧视" class="headerlink" title="一级价格歧视"></a>一级价格歧视</h4><p>一级价格歧视又称为完全价格歧视，指企业按照消费者愿意为每单位产品支付的最高价格，分别制定不同的销售价格，以攫取全部消费者剩余，增加企业利润。这种定价方式要求企业能够精确了解每个消费者的支付意愿，并据此制定不同的价格。</p><ul><li><strong>医院收费</strong>：医院根据病人的病情、社会地位和支付能力，对不同的病人制定不同的价格。例如，对于病情严重、支付能力强的病人，医院可能会收取更高的费用；而对于病情较轻、支付能力弱的病人，医院可能会给予一定的优惠。</li><li><strong>高端餐厅</strong>：顾客可以根据自己的口味和需求选择食材和烹饪方式，最终支付的价格完全取决于顾客所选择的项目和数量。这种定价方式使得餐厅能够准确捕捉每位顾客的支付意愿，从而实现利润最大化。</li><li><strong>偏远小镇的医生</strong>：在一个偏远小镇上只有一个医生，该医生了解该镇中每一家住户的收入状况和对医疗的需求状况，因此可以根据每一个人的保留价格制定医疗价格，这也是一级价格歧视的一种应用。</li></ul><h4 id="二级价格歧视"><a href="#二级价格歧视" class="headerlink" title="二级价格歧视"></a>二级价格歧视</h4><p>二级价格歧视，又称为数量歧视，指企业按照消费者购买数量的不同，制定不同的销售价格。这种定价方式能够鼓励消费者增加购买量，从而提高企业的销售额和利润。</p><ul><li><strong>超市牛奶</strong>：买的数量越多就越便宜。例如，当买一箱牛奶的时候，平均每瓶牛奶的价格可能在3元左右；若单独购买一瓶或是几瓶的时候，那么一瓶的价格往往在4元左右。</li><li><strong>电力公司定价</strong>：电力公司会对居民用电和商业用电实行不同的价格，通常会对居民用电在低谷时段提供折扣，以平衡电网负荷。这种定价策略既保证了电力公司的收入，又鼓励了消费者在非高峰时段使用电力。</li><li><strong>豆类公司销售</strong>：一家豆类公司以每公斤4美元的价格出售豆类，但如果客户订购至少10000公斤，价格降至每公斤3.5美元。</li></ul><h4 id="三级价格歧视"><a href="#三级价格歧视" class="headerlink" title="三级价格歧视"></a>三级价格歧视</h4><p>三级价格歧视，又称为群体定价，指企业根据不同的消费者群体（如学生、专业人士和老年人等）制定不同的销售价格。这种定价方式能够满足不同消费群体的需求，提高市场占有率和盈利能力。</p><ul><li><strong>电影票定价</strong>：电影院根据观众的不同身份、年龄、职业等因素制定不同的票价，例如成人票、儿童票等，以吸引更多不同层次的观众，提高票房收益。</li><li><strong>航空机票</strong>：航空公司对提前预订和最后时刻预订的机票收取不同的价格，以平衡航班的需求和供给。</li><li><strong>书籍销售</strong>：同一本书在不同的国家、地区或销售渠道中可能会有不同的价格。这取决于各市场的消费能力、竞争状况以及消费者的支付意愿。出版商通过调整价格来适应不同市场的特点，从而实现利润最大化。</li></ul><p>这些例子展示了不同级别的价格歧视在现实生活中的应用，以及它们如何帮助企业更好地满足市场需求，提高盈利能力。</p><h3 id="寡头"><a href="#寡头" class="headerlink" title="寡头"></a>寡头</h3><ol><li><strong>定义</strong>：寡头指的是掌握政治、经济大权的少数巨头。</li><li><strong>特征</strong>：寡头垄断市场的典型特征是厂商之间的行为相互影响，以至于厂商的决策要考虑竞争对手的反应。寡头垄断市场中的价格不完全是由市场的供求关系决定的。寡头垄断市场中，任何厂商在采取行动前都必须认真研究对手，并考虑对手可能做出的反应。寡头决策时，也要考虑边际收益和边际成本的问题。但是，边际收益情况往往难以确定，原因在于企业间存在具有直接针对性的竞争。</li></ol><p>综上所述，垄断、价格歧视和寡头都是市场经济中的重要概念，它们各自具有特定的定义、特征和影响。</p><h1 id="第七章：生产要素市场和收入分配"><a href="#第七章：生产要素市场和收入分配" class="headerlink" title="第七章：生产要素市场和收入分配"></a>第七章：生产要素市场和收入分配</h1><h2 id="7-1完全竞争和要素需求"><a href="#7-1完全竞争和要素需求" class="headerlink" title="7.1完全竞争和要素需求"></a>7.1完全竞争和要素需求</h2><p>要素分配</p><p>$$R&#x3D;PQ(L)-WL$$<br>最大R<br>$$VMP&#x3D;P*MP&#x3D;W$$</p><p>完全竞争企业使用要素的边际收益——边际产品价值<br>即：完全竞争企业增加使用一单位要素所带来的收益的增加量。符号为上面提到的<br>$$ VMP&#x3D;P<em>MP$$<br>边际产量</em>价格</p><h2 id="7-3劳动和工资"><a href="#7-3劳动和工资" class="headerlink" title="7.3劳动和工资"></a>7.3劳动和工资</h2><p>假定</p><ul><li>消费者每天必须睡眠8小时。 这样, 消费者可以自由支配的时间资源每天就不能超过16小时。</li><li>劳动者效用来自两方面，一方面是劳动收货工资，一方面是闲暇收获快乐，二者都有间接效用</li></ul><p><a href="https://imgse.com/i/pATqze1"><img src="https://s21.ax1x.com/2024/12/06/pATqze1.md.png" alt="pATqze1.md.png"></a></p><p><a href="https://imgse.com/i/pATLkSe"><img src="https://s21.ax1x.com/2024/12/06/pATLkSe.md.png" alt="pATLkSe.md.png"></a></p><p>劳动供给曲线的形状表现为一条向后弯曲的曲线，它指劳动供给曲线呈现出的劳动供给量随着工资上升先增加后逐渐减少的特征。劳动供给曲线向后弯曲的原因可以用工资增加的替代效应和收入效应来解释：</p><ul><li>替代效应：工资上升，收入增加，消费者用劳动替代闲暇，劳动供给增加。</li><li>收入效应：工资上升，收入增加，消费者相对更加富有而追求闲暇，劳动供给减少。</li></ul><p>当工资不断上升，达到某一水平之前，劳动供给量随价格的上升而上升，此时替代效应大于收入效应；当工资进一步上升并超过某一水平时，替代效应小于收入效应，劳动供给量呈下降趋势，劳动供给曲线向后弯曲。</p><h1 id="第八章：一般均衡和效率"><a href="#第八章：一般均衡和效率" class="headerlink" title="第八章：一般均衡和效率"></a>第八章：一般均衡和效率</h1><h2 id="帕累托最优"><a href="#帕累托最优" class="headerlink" title="帕累托最优"></a>帕累托最优</h2><h3 id="交换的帕累托最优"><a href="#交换的帕累托最优" class="headerlink" title="交换的帕累托最优"></a>交换的帕累托最优</h3><p>通过甲和乙所有无差异曲线可能的相切点的曲线,表示甲和乙间食品和布一切可能的有效率配置,该曲线被称做“交换契约曲线”。</p><p>$$MRS^{A}&#x3D;MRS^{B}$$</p><p><a href="https://imgse.com/i/pA7SoP1"><img src="https://s21.ax1x.com/2024/12/06/pA7SoP1.md.png" alt="pA7SoP1.md.png"></a></p><p>在交换契约曲线上的任何一点，都代表了两个消费者之间的一种有效率的商品配置。这意味着，在这种配置下，任何一方都不能通过交换进一步改善自己的境况，而不使另一方的境况恶化。</p><p>二者会一直交换，直到两个消费者对商品组合的偏好是相同的，或者说他们对商品组合的边际替代率是相等的</p><h3 id="生产的帕累托最优"><a href="#生产的帕累托最优" class="headerlink" title="生产的帕累托最优"></a>生产的帕累托最优</h3><p>$$MRTS^{C}&#x3D;MRTS^{D}$$</p><p>对应的是二者交换生产要素，达到最优<br><a href="https://imgse.com/i/pA7p8Z4"><img src="https://s21.ax1x.com/2024/12/06/pA7p8Z4.md.png" alt="pA7p8Z4.md.png"></a></p><p>二者的际技术替代率相等</p><h3 id="生产和交换的帕累托最优"><a href="#生产和交换的帕累托最优" class="headerlink" title="生产和交换的帕累托最优"></a>生产和交换的帕累托最优</h3><p><a href="https://imgse.com/i/pA79WN9"><img src="https://s21.ax1x.com/2024/12/06/pA79WN9.md.png" alt="pA79WN9.md.png"></a></p><ul><li>在埃奇渥斯盒状图中，交换的帕累托最优状态可以由无差异曲线的切点($MRS$相等)轨迹（交换的契约曲线）来表示。</li><li>同样地，生产的帕累托最优状态可以由等产量曲线的切点（$MRTS$相等）轨迹（生产的契约曲线）来表示。</li><li>而生产和交换的帕累托最优状态则可以通过将生产契约曲线转化为生产可能性曲线，并与无差异曲线相结合来进行分析。当生产可能性曲线与无差异曲线相切（$MRS&#x3D;MRT$）时，就达到了生产和交换的帕累托最优状态。</li></ul><h2 id="福利经济学"><a href="#福利经济学" class="headerlink" title="福利经济学"></a>福利经济学</h2><h3 id="福利经济学第一定理"><a href="#福利经济学第一定理" class="headerlink" title="福利经济学第一定理"></a>福利经济学第一定理</h3><p>福利经济学第一定理，也被称为“看不见的手”定理，它指出在完全竞争市场中，通过个人追求自身利益最大化和价格的调整所实现的均衡，即完全竞争均衡，在经济上是帕累托最优配置。换句话说，在完全竞争、无外部性、无交易成本、完全信息、无规模经济等理想条件下，市场竞争能够通过价格机制有效调节经济活动，从而达到帕累托最优的资源配置状态。这里的帕累托最优是指资源配置达到了这样一种状态：没有任何一种方法可以在不损害任何其他人利益的前提下，使至少一个人的利益得到增进。</p><p><strong>通俗解释</strong>：想象一个自由竞争的市场，比如一个农贸市场。每个卖家都想卖出更高的价格，每个买家都想以更低的价格买入。在这个市场中，价格就像一只“看不见的手”，在引导着资源的流向。如果西红柿的价格上涨，农民就会种植更多的西红柿，因为这样能赚钱。而消费者则会因为价格高而减少购买，或者选择其他便宜的蔬菜。最终，市场会自动调整到一个均衡状态，这时西红柿的供应和需求达到平衡，价格稳定，资源也得到了最有效的利用。这就是福利经济学第一定理所说的：在完全竞争的市场中，每个人追求自身利益最大化就会促使整个社会达到帕累托最优的资源配置状态。</p><h3 id="福利经济学第二定理"><a href="#福利经济学第二定理" class="headerlink" title="福利经济学第二定理"></a>福利经济学第二定理</h3><p>福利经济学第二定理则进一步探讨了政府与市场在资源配置中的角色。它指出在完全竞争的市场条件下，政府所要做的事情是改变个人之间禀赋的初始分配状态，其余的一切都可以由市场来解决。换句话说，任何一种符合帕累托效率的资源配置状态都能通过完全竞争市场实现。这意味着，只要初始的资源配置状态给定，市场机制就能够通过价格机制和个人自利的交易行为，达到帕累托最优的资源配置状态。政府可以通过税收、补贴等手段来改变初始的资源配置状态，以实现特定的社会目标或公平分配，而不会影响市场的帕累托效率。</p><p><strong>通俗解释</strong>：还是以农贸市场为例。假设政府认为当前的财富分配不够公平，想要帮助低收入群体。那么政府可以通过税收从高收入群体那里收取一部分钱，然后再通过补贴或转移支付的方式给低收入群体。这样，初始的财富分配就发生了改变。但是改变之后呢？市场会继续发挥作用。那些得到补贴的低收入群体可能会有更多的钱来购买蔬菜，从而增加了需求。而供应方（农民或卖家）则会因为需求增加而提高产量或保持价格稳定。最终，市场会再次达到一个新的均衡状态，这时资源配置仍然是帕累托最优的。这就是福利经济学第二定理所说的：政府可以干预初始资源分配以实现公平，但不能干预市场机制本身。</p><h3 id="结合具体例子"><a href="#结合具体例子" class="headerlink" title="结合具体例子"></a>结合具体例子</h3><p>为了更好地理解这两个定理，我们可以看一个更具体的例子：在一个小型村庄里，村民们共同拥有一片草地用于放牧牛羊。这片草地是有限的，过度放牧会导致草地退化，进而减少村民们的收益。假设这个村庄里的每个村民都是理性且自私的，他们会根据市场价格和个人偏好来决定放牧的数量。</p><ul><li><strong>应用第一定理</strong>：在没有政府干预的情况下，当草地开始出现退化迹象时，草的价格会上涨，因为供给减少了。这促使村民们减少放牧数量，从而保护了草地。同时，那些对草地使用需求较低的村民可能会选择减少放牧，而那些需求更高的村民则愿意支付更高的价格来保持放牧。随着时间推移，市场会自动调整到一个均衡状态，在这个状态下，草地的使用是可持续的，同时也达到了帕累托最优的状态——即每个村民都按照自己的偏好和支付意愿使用草地资源，没有人可以通过改变行为进一步增加自己的福利而不减少其他人的福利。</li><li><strong>应用第二定理</strong>：假设政府认为当前的草地分配不够公平，想要帮助那些拥有较少牛羊的村民。政府可以通过税收从拥有较多牛羊的村民那里收取一部分钱，然后再通过补贴的方式给那些拥有较少牛羊的村民。这样，初始的草地资源（或放牧权）分配就发生了改变。但是改变之后呢？市场会继续发挥作用。那些得到补贴的村民可能会有更多的钱来购买更多的牛羊或保持现有的放牧量，从而增加了对草地的需求。而供应方（草地本身）则是固定的。最终，市场会再次达到一个新的均衡状态，这时草地资源的配置仍然是帕累托最优的——即每个村民都按照自己的偏好和支付意愿使用草地资源，同时也没有进一步交换可以使得至少一个人的福利增加而不减少其他人的福利。</li></ul><p>综上所述，福利经济学第一定理和第二定理共同揭示了竞争性市场和帕累托效率之间的关系以及政府在其中的角色。这两个定理不仅为市场经济的有效性提供了理论支持，也为政府制定经济政策提供了重要的参考依据。</p><h1 id="第九章：市场失灵和微观经济政策"><a href="#第九章：市场失灵和微观经济政策" class="headerlink" title="第九章：市场失灵和微观经济政策"></a>第九章：市场失灵和微观经济政策</h1><h2 id="一、市场失灵的类型（原因）"><a href="#一、市场失灵的类型（原因）" class="headerlink" title="一、市场失灵的类型（原因）"></a>一、市场失灵的类型（原因）</h2><p>市场失灵的类型（原因）主要包括以下几个方面：</p><p>以下是对垄断与不完全竞争、公共物品与外部性、信息不对称与市场欺诈、分配不公与贫困问题如何导致市场失灵的具体分析，并附有相关例子：</p><h3 id="垄断与不完全竞争"><a href="#垄断与不完全竞争" class="headerlink" title="垄断与不完全竞争"></a>垄断与不完全竞争</h3><ul><li><p><strong>垄断</strong>：</p><ul><li><strong>原因</strong>：垄断是指一个或多个市场被单个供应商或少数几个供应商控制，这些供应商有能力限制产量、提高价格，从而获取超额利润。</li><li><strong>例子</strong>：假设某地区的电力供应被一家电力公司垄断，这家公司可能会提高电价，降低服务质量，因为消费者没有其他选择。这种情况下，市场机制无法有效调节电力供应和价格，导致市场失灵。</li></ul></li><li><p><strong>不完全竞争</strong>：</p><ul><li><strong>原因</strong>：不完全竞争市场存在多个供应商，但每个供应商的产品或服务都具有一定的差异性。这种差异性可能导致供应商之间无法形成充分竞争，价格机制无法有效发挥作用。</li><li><strong>例子</strong>：在品牌服装市场中，每个品牌都有其独特的风格和定位，消费者可能更愿意为某个特定品牌支付高价。这种情况下，品牌差异导致市场无法完全竞争，价格可能偏离成本，导致市场失灵。</li></ul></li></ul><h3 id="公共物品与外部性"><a href="#公共物品与外部性" class="headerlink" title="公共物品与外部性"></a>公共物品与外部性</h3><ul><li><p><strong>公共物品</strong>：</p><ul><li><strong>原因</strong>：公共物品具有非排他性和非竞争性，即任何人都可以使用，且一个人的使用不会影响其他人的使用。由于公共物品的这些特性，私人企业往往缺乏提供公共物品的动力，因为无法从消费者那里获得足够的回报。</li><li><strong>例子</strong>：国防是一个典型的公共物品。每个人都可以享受国防带来的安全保障，但没有人愿意为国防支付全部费用。如果完全依靠市场机制来提供国防服务，那么很可能导致国防投入不足，市场失灵。</li></ul></li><li><p><strong>外部性</strong>：</p><ul><li><strong>原因</strong>：外部性是指一个人的行为对旁观者福利的影响。当这种影响没有通过市场交易得到体现时，就产生了外部性。外部性可能导致市场失灵，因为市场价格无法准确反映资源的真实价值。</li><li><strong>例子</strong>：一个工厂在生产过程中排放污染物，对周边环境造成负面影响。这种污染行为对周边居民产生了额外的成本，但这些成本并没有通过市场交易得到体现。因此，市场机制无法有效调节工厂的污染行为，导致市场失灵。</li></ul></li></ul><h3 id="信息不对称与市场欺诈"><a href="#信息不对称与市场欺诈" class="headerlink" title="信息不对称与市场欺诈"></a>信息不对称与市场欺诈</h3><ul><li><p><strong>信息不对称</strong>：</p><ul><li><strong>原因</strong>：信息不对称是指交易双方在信息掌握上存在差异。一方可能拥有更多的信息，而另一方则处于信息劣势。这种信息不对称可能导致市场失灵，因为信息劣势的一方可能做出不理智的决策。</li><li><strong>例子</strong>：在二手车市场上，卖家通常比买家更了解车辆的真实状况。买家可能因为缺乏信息而购买到质量较差的车辆，导致市场失灵。</li></ul></li><li><p><strong>市场欺诈</strong>：</p><ul><li><strong>原因</strong>：市场欺诈是指一方利用信息不对称或虚假信息来误导或欺骗另一方，以获取不正当利益。</li><li><strong>例子</strong>：某些商家可能会通过虚假宣传或误导性广告来销售低质商品，这种行为损害了消费者的利益，破坏了市场的公平性和有效性。</li></ul></li></ul><h3 id="分配不公与贫困问题"><a href="#分配不公与贫困问题" class="headerlink" title="分配不公与贫困问题"></a>分配不公与贫困问题</h3><ul><li><p><strong>分配不公</strong>：</p><ul><li><strong>原因</strong>：市场机制可能导致收入分配不公。一些人群可能因为缺乏资源、技能或机会而无法获得足够的收入，导致贫富差距扩大。</li><li><strong>例子</strong>：在某些地区，由于教育资源分配不均，贫困地区的孩子可能无法接受良好的教育，从而影响他们未来的就业机会和收入水平。这种收入分配不公可能导致社会不稳定和市场失灵。</li></ul></li><li><p><strong>贫困问题</strong>：</p><ul><li><strong>原因</strong>：贫困问题是指一部分人群由于各种原因无法获得足够的收入来满足基本生活需求。</li><li><strong>例子</strong>：在某些发展中国家，由于经济不发达、就业机会有限等原因，大量人口处于贫困状态。这些贫困人口可能无法有效参与市场活动，导致市场需求不足，进而影响市场的正常运行。</li></ul></li></ul><h2 id="二、针对外部性的应对措施"><a href="#二、针对外部性的应对措施" class="headerlink" title="二、针对外部性的应对措施"></a>二、针对外部性的应对措施</h2><p>针对外部性，可以采取以下应对措施：</p><ol><li><p><strong>经济手段</strong>：</p><ul><li>征税：对造成外部不经济的企业征税，其数额等于该企业给社会其他成员造成的损失，从而使该企业的私人成本恰好等于社会成本。</li><li>补贴：对有正外部性的活动实施补贴，促进经济效益提高。</li></ul></li><li><p><strong>行政管制</strong>：</p><ul><li>政府可以通过规定或禁止某些行为来解决外部性问题。例如，对环境污染设定一个合理的污染水平，对超过这个水平的污染施加严格的惩罚。</li></ul></li><li><p><strong>产权界定</strong>：</p><ul><li>通过对外部性进行产权界定（如污染权、收益权等），然后通过市场化的方式让企业自行调整其经济行为，以达到控制外部性的目的。</li></ul></li><li><p><strong>私人解决方法</strong>：</p><ul><li>道德约束和社会约束：利用道德规范使经济人考虑自己的行为对他人的影响，将外部性内在化。</li><li>慈善行为：通过慈善行为来减轻外部性带来的负面影响。</li><li>经营整合：将有正的外部性的企业和有负的外部性的企业合并为一个企业，将外部性内部化。</li><li>利益各方签订合约：通过合约规定一方对另一方的支付，以解决外部性产生的无效率问题。</li></ul></li></ol><h2 id="三、公共物品和公共资源的分类及分类标准（必考）"><a href="#三、公共物品和公共资源的分类及分类标准（必考）" class="headerlink" title="三、公共物品和公共资源的分类及分类标准（必考）"></a>三、公共物品和公共资源的分类及分类标准（必考）</h2><ul><li><p>排他性（Excludability）指的是物品或服务在消费过程中能否将某些人或群体排除在外的特性。如果一种物品或服务能够被提供者有效地控制，使得只有支付费用或满足特定条件的人才能使用，那么这种物品或服务就具有排他性。</p></li><li><p>竞争性（Rivalry in Consumption）指的是一种物品或服务在消费过程中，一个人的使用是否会减少其他人对该物品或服务的使用量或质量。如果一种物品或服务在消费过程中存在这种“你用我就不能用”或“你多用我就少用”的情况，那么这种物品或服务就具有竞争性。<br>根据上述两点可以对常见的经济物品分类</p></li></ul><p>根据产品在消费上是否具有排他性和竞争性，可以将现实经济中的产品分为以下四类：</p><table><thead><tr><th>类别</th><th>排他性</th><th>竞争性</th><th>例子</th></tr></thead><tbody><tr><td>私人物品</td><td>有</td><td>有</td><td>衣服、食物、手机等</td></tr><tr><td>公共物品</td><td>无</td><td>无</td><td>国防、基础研究、不拥挤的不收费道路等</td></tr><tr><td>俱乐部产品</td><td>有</td><td>无</td><td>有线电视、不拥挤的收费道路、(无限大)健身房会员卡等</td></tr><tr><td>公共资源</td><td>无</td><td>有</td><td>公共牧场、渔场、空气和水体等</td></tr></tbody></table><p>考试会考公共物品和公共资源</p><h2 id="四、信息与信息价值的概念及信息不完全与信息不对称"><a href="#四、信息与信息价值的概念及信息不完全与信息不对称" class="headerlink" title="四、信息与信息价值的概念及信息不完全与信息不对称"></a>四、信息与信息价值的概念及信息不完全与信息不对称</h2><p>以下是信息不完全和信息不对称的例子：</p><h3 id="信息不完全"><a href="#信息不完全" class="headerlink" title="信息不完全"></a>信息不完全</h3><p>信息不完全是指市场的参与<strong>双方</strong>不具有充分的信息。例如：</p><ul><li>产品市场上的生产者无法准确预测市场上各种产品需求和要素供给变动的情况，消费者也无法了解所有商品市场上待售商品的质量和价格情况。</li><li>在劳动力市场上，求职者并不知道所有空缺职位的信息，而雇主也无法了解每一位雇员的才能和潜力。</li><li>在一个社交媒体帖子中，用户发表了一段关于旅行的心情，但没有说明具体的旅行地点和经历。</li><li>一个产品说明页面上，只列举了产品的名称和价格，但没有提供关于产品功能、优势和使用方法的详细介绍。</li><li>一篇关于环境保护的文章中，作者只列举了一些环境问题的关键词，却没有提供解决方案或具体的数据支持。</li><li>一个烹饪视频中，厨师只展示了做菜的过程，但没有提供具体的食材和调料用量，以及烹饪时间和步骤的解释。</li><li>在购买换季服装时，消费者可能不知道哪家的品质好且便宜。</li><li>在旅游区找餐馆吃午饭时，消费者可能不知道该去哪家餐馆。</li></ul><h3 id="信息不对称"><a href="#信息不对称" class="headerlink" title="信息不对称"></a>信息不对称</h3><p>信息不对称是指在信息不完全的市场上，交易双方所掌握的与交易相关的信息是不对称的，一方可能比另一方掌握更多信息，或一方掌握着另一方没有的信息。例如：</p><ul><li><strong>二手车市场</strong>：卖家对车辆的状况了解得更清楚，而买家可能无法准确判断车辆的真实状况。卖家可能隐瞒车辆的缺陷，而买家则可能因为信息不足而做出不利的购买决策。</li><li><strong>医疗市场</strong>：医生通常比患者更了解病情和治疗方案，患者可能无法准确评估不同治疗方案的效果和风险。</li><li><strong>保险市场</strong>：保险公司通常无法准确了解投保人的真实健康状况，而投保人可能隐瞒自己的健康问题以获取更低的保费。这可能导致保险公司在理赔时面临更大的风险。</li><li><strong>就业市场</strong>：雇主在招聘时可能无法准确了解求职者的真实能力和潜力，而求职者可能夸大自己的能力和经验。这可能导致雇主做出不利的招聘决策。</li></ul><p>信息不对称可能导致市场失灵，因为信息优势方可能利用信息不对称来损害信息劣势方的利益。例如，在二手车市场中，如果卖家隐瞒车辆的缺陷并高价出售，买家在发现车辆问题后可能不再愿意支付高价购买二手车，从而导致优质二手车被逐出市场，劣质二手车充斥市场。这种现象被称为“逆向选择”。此外，信息不对称还可能导致道德风险问题，即一方在交易完成后利用信息不对称来损害另一方的利益。例如，在保险市场中，投保人可能在购买保险后故意制造保险事故以获取赔偿。</p>]]></content>
    
    
    <categories>
      
      <category>随笔</category>
      
    </categories>
    
    
    <tags>
      
      <tag>随笔</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>24暑期算法竞赛集训</title>
    <link href="/2025/03/21/%E7%AE%97%E6%B3%95/240725%E4%BF%A1%E6%81%AF%E5%AD%A6%E7%AB%9E%E8%B5%9B%E9%9B%86%E8%AE%AD%E8%90%A5/"/>
    <url>/2025/03/21/%E7%AE%97%E6%B3%95/240725%E4%BF%A1%E6%81%AF%E5%AD%A6%E7%AB%9E%E8%B5%9B%E9%9B%86%E8%AE%AD%E8%90%A5/</url>
    
    <content type="html"><![CDATA[<h1 id="Day-1-小专题"><a href="#Day-1-小专题" class="headerlink" title="Day 1 小专题"></a>Day 1 小专题</h1><h3 id="多个输入"><a href="#多个输入" class="headerlink" title="多个输入"></a>多个输入</h3><p>读入大量数据的范式<br>比如，求未知个整数的和      </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> c=<span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> x;<br>    <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)<br>    &#123;<br>        cin&gt;&gt;x;<br>        <span class="hljs-keyword">if</span>(!cin) <span class="hljs-keyword">break</span>;<br>        c+=x;<br>    &#125;<br>    cout&lt;&lt;c&lt;&lt;endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>自己调试的时候要加ctrl z模拟文件流结束的EOF</p><h3 id="串与整数转换"><a href="#串与整数转换" class="headerlink" title="串与整数转换"></a>串与整数转换</h3><p>eg：把字符串转成整数数字</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">const</span> <span class="hljs-type">char</span>* s=<span class="hljs-string">&quot;12053&quot;</span>;<br><span class="hljs-type">int</span> n=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span>(*s)<br>&#123;<br>    n=n*<span class="hljs-number">10</span>+(*s-<span class="hljs-string">&#x27;0&#x27;</span>);<br>    s++;<br>&#125;<br>cout&lt;&lt;n;<br></code></pre></td></tr></table></figure><p>把数字转化为字符串</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">char</span> s[<span class="hljs-number">100</span>];<br>    <span class="hljs-type">int</span> n=<span class="hljs-number">12503</span>;<br>    <span class="hljs-type">char</span>* p=s;<br>    <span class="hljs-keyword">do</span>&#123;<br>        *p=n%<span class="hljs-number">10</span>+<span class="hljs-string">&#x27;0&#x27;</span>;<br>        p++;<br>        n/=<span class="hljs-number">10</span>;   <span class="hljs-comment">//update n</span><br>    &#125;<span class="hljs-keyword">while</span>(n&gt;<span class="hljs-number">0</span>);   <span class="hljs-comment">//后判断</span><br>    <span class="hljs-comment">//此时p指向最后一个数字的后一位</span><br>    *p=<span class="hljs-string">&#x27;\0&#x27;</span>;<br>    <span class="hljs-comment">//反转这个串</span><br>    p--；<br>    <span class="hljs-type">char</span>* q=s;<br>    <span class="hljs-keyword">while</span>(p&gt;q)<br>    &#123;<br>        chat t=*p;<br>        *p=*q;<br>        *q=t;<br>        p--;<br>        q++;<br>    &#125;<br>    cout&lt;&lt;s;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><br><br><br></code></pre></td></tr></table></figure><h3 id="进制转换"><a href="#进制转换" class="headerlink" title="进制转换"></a>进制转换</h3><p>串-&gt;值  高位算起<br>值-&gt;串  低位算起，结果反转</p><p>eg:16进制转换</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">const</span> <span class="hljs-type">char</span>* s=<span class="hljs-string">&quot;FF&quot;</span>;<br><span class="hljs-type">int</span> n=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span>(*s)<br>&#123;<br>    n=n*<span class="hljs-number">16</span>+((*s&gt;=<span class="hljs-string">&#x27;0&#x27;</span>&amp;&amp;*s&lt;=<span class="hljs-string">&#x27;9&#x27;</span>)? *s-<span class="hljs-string">&#x27;0&#x27;</span> : *s-<span class="hljs-string">&#x27;A&#x27;</span><span class="hljs-number">+10</span>);<br>    s++;<br>&#125;<br>cout&lt;&lt; n&lt;&lt; endl;<br><br><br>n=<span class="hljs-number">255</span>;<br><span class="hljs-type">int</span> a[]=&#123;<span class="hljs-string">&#x27;0&#x27;</span>,<span class="hljs-string">&#x27;1&#x27;</span>,<span class="hljs-string">&#x27;2&#x27;</span>,<span class="hljs-string">&#x27;3&#x27;</span>,<span class="hljs-string">&#x27;4&#x27;</span>,<span class="hljs-string">&#x27;5&#x27;</span>,<span class="hljs-string">&#x27;6&#x27;</span>,<span class="hljs-string">&#x27;7&#x27;</span>,<span class="hljs-string">&#x27;8&#x27;</span>,<span class="hljs-string">&#x27;9&#x27;</span>,<br>         <span class="hljs-string">&#x27;A&#x27;</span>.<span class="hljs-string">&#x27;B&#x27;</span>,<span class="hljs-string">&#x27;C&#x27;</span>.<span class="hljs-string">&#x27;D&#x27;</span>,<span class="hljs-string">&#x27;E&#x27;</span>,<span class="hljs-string">&#x27;F&#x27;</span>&#125;;<br><span class="hljs-type">char</span> buf[<span class="hljs-number">100</span>];<br><span class="hljs-type">char</span> *p=buf;<br><span class="hljs-keyword">do</span>&#123;<br>    *p=a[n%<span class="hljs-number">16</span>];<br>    p++;<br>    n/=<span class="hljs-number">16</span>;<br>&#125;<span class="hljs-keyword">while</span>(n&gt;<span class="hljs-number">0</span>);<br><br>*p=<span class="hljs-string">&#x27;\0&#x27;</span>;<br>p--;<br><span class="hljs-type">char</span>* q=buf;<br><span class="hljs-comment">//双指针交换</span><br><span class="hljs-keyword">while</span>(q&lt;p)&#123;<br>    <span class="hljs-type">char</span> t=*p;<br>    *p=*q;<br>    *q=t;<br>    p--;<br>    q++;<br>&#125;<br>cout&lt;&lt;n&lt;&lt;endl;<br><br></code></pre></td></tr></table></figure><p>事实上16进制可以直接调用API</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n=<span class="hljs-number">1000</span>;<br>    <span class="hljs-type">char</span> buf[<span class="hljs-number">100</span>];<br>    <span class="hljs-comment">//printf(&quot;%X&quot;,n); //16进制</span><br>    <br>    <span class="hljs-built_in">sprintf</span>(buf,<span class="hljs-string">&quot;%X&quot;</span>,n);  <span class="hljs-comment">//写入buf中</span><br>    <span class="hljs-type">const</span> <span class="hljs-type">char</span>* a[] =&#123;&#125;<br>    <span class="hljs-type">char</span>* p=buf;<br>    <span class="hljs-keyword">while</span>(*p)&#123;<br>        cout&lt;&lt; ((*p&gt;=<span class="hljs-string">&#x27;0&#x27;</span>&amp;&amp;*p&lt;=<span class="hljs-string">&#x27;9&#x27;</span>)? a[*p-<span class="hljs-string">&#x27;0&#x27;</span>] : a[*p-<span class="hljs-string">&#x27;A&#x27;</span><span class="hljs-number">+10</span>])<br>        p++;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="伪进制问题-Excel列地址"><a href="#伪进制问题-Excel列地址" class="headerlink" title="伪进制问题&#x2F;Excel列地址"></a>伪进制问题&#x2F;Excel列地址</h3><p>A B C D…Z  AA AB… ZZ</p><ul><li>Q1</li><li>字符转序号？ AA&#x3D;&gt; 27<br>1到26的进位而非0到25的进位<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">const</span> <span class="hljs-type">char</span>* s=<span class="hljs-string">&quot;XYZA&quot;</span>;<br><span class="hljs-type">int</span> n=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span>(*s)&#123;<br>    n=n*<span class="hljs-number">26</span>+(*S-<span class="hljs-string">&#x27;A&#x27;</span><span class="hljs-number">+1</span>);<br>    s++;<br>&#125;<br>cout&lt;&lt; n&lt;&lt; endl;<br><br></code></pre></td></tr></table></figure></li><li>Q2</li><li>序号转字符？<br>n 可以表示为<br>n&#x3D;26<em>26</em>26<em>a + 26</em>26<em>b + 26</em>c + d<br>发现 n%26&#x3D;d</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n=<span class="hljs-number">434901</span>;<br>    string s;<br><br>    <span class="hljs-keyword">do</span>&#123;<br>        <span class="hljs-type">int</span> a=n%<span class="hljs-number">26</span>;<br>        <span class="hljs-type">int</span> b=n/<span class="hljs-number">26</span>;<br>        <span class="hljs-keyword">if</span>(a==<span class="hljs-number">0</span>)&#123;<br>            a=<span class="hljs-number">26</span>;<br>            b--;<br>        &#125;   <span class="hljs-comment">//因为0 无对应字母</span><br>        s = (a<span class="hljs-number">-1</span>+<span class="hljs-string">&#x27;A&#x27;</span>) + s;   <span class="hljs-comment">//不用自己翻转了</span><br>        n=b;<br>    &#125;<span class="hljs-keyword">while</span>(n&gt;<span class="hljs-number">0</span>);<br><br>    cout&lt;&lt; s &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="基本排序"><a href="#基本排序" class="headerlink" title="基本排序"></a>基本排序</h3><ul><li>交换排序</li></ul><p>不断交换逆序的元素，达到最终的有序，冒泡排序就是一种交换排序算法，它比较并交换相邻的元素，当然我们也可以不局限于相邻的元素。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n;<br>    cin&gt;&gt;n;<br>    <span class="hljs-type">int</span>* buf =<span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[n];<br>    <span class="hljs-comment">// scanf buf</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++) <br>    &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;n<span class="hljs-number">-1</span>-i;j++)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(a[j]&gt;a[j<span class="hljs-number">+1</span>])<br>            <span class="hljs-built_in">swap</span>(a[j],a[j<span class="hljs-number">+1</span>]);<br>        &#125;<br>    &#125;<br><br><br><br>    <span class="hljs-keyword">delete</span> [] buf;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>选择排序</li></ul><p>从一堆元素中找出最小元素放入有序列，再从剩下的元素中选最小，重复上述操作直到最后一个元素。</p><p><img src="https://www.freeimg.cn/i/2024/07/25/66a204849ef8a.png" alt="1721894019395.png"></p><p>稳定性指的是：排序结束之后，相等的元素是否还是排序之前的顺序？<br>你别说，分开多个函数写还挺舒服。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-type">int</span> *p, <span class="hljs-type">int</span> n)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> t=<span class="hljs-number">0</span>; <span class="hljs-comment">//最小元素位置</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;n;i++)&#123;<br>        <span class="hljs-keyword">if</span>(p[i]&lt;p[t]) t=i;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(t&gt;<span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-type">int</span> x=p[<span class="hljs-number">0</span>];<br>        p[<span class="hljs-number">0</span>]=p[t];<br>        p[t]=x;<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">sort</span><span class="hljs-params">(<span class="hljs-type">int</span> *buf,<span class="hljs-type">int</span> n)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n<span class="hljs-number">-1</span>;i++)  <span class="hljs-comment">//从第一个开始找，从第二个开始找****从第n-1个开始找</span><br>    &#123;<br>        <span class="hljs-built_in">f</span>(buf+i,n-i);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>插入排序<br>基本思想是：把一个元素插入到有序队列的适当位置<br><img src="https://www.freeimg.cn/i/2024/07/25/66a21197a13e7.png" alt="1721897363146.png"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-type">int</span>* p,<span class="hljs-type">int</span> k)</span>   <span class="hljs-comment">//k待插入</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span>*q=p;<br>    <span class="hljs-type">int</span> t=p[k];<br>    <span class="hljs-comment">//查找应该插入的位置</span><br>    <span class="hljs-keyword">while</span>(*q&lt;t) q++;<br><br>    <span class="hljs-type">int</span> *r=p+k<span class="hljs-number">-1</span>;    <span class="hljs-comment">//右边界</span><br>    <span class="hljs-keyword">while</span>(r&gt;=q)&#123;<br>        r[<span class="hljs-number">1</span>]=r[<span class="hljs-number">0</span>];   <span class="hljs-comment">//做交换</span><br>        r--;<br>    &#125;<br>    *q=t;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">sort</span><span class="hljs-params">(<span class="hljs-type">int</span>* buf,<span class="hljs-type">int</span> n)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;n;i++)&#123;<br>        <span class="hljs-built_in">f</span>(buf,i)  <span class="hljs-comment">//i就是准备加入进来的元素</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><h3 id="vector"><a href="#vector" class="headerlink" title="vector"></a>vector</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    vector&lt;<span class="hljs-type">int</span>&gt; arr[<span class="hljs-number">100</span>];<br>    vector&lt;<span class="hljs-type">int</span>&gt; list;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">100</span>;i++)<br>    &#123;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;arr[i]);<br>        cout&lt;&lt;arr[i]&lt;&lt;endl;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">100</span>;i++)<br>    &#123;<br>        <span class="hljs-type">int</span> a=<span class="hljs-number">0</span>;<br>        cin&gt;&gt; a;<br>        list.<span class="hljs-built_in">push_back</span>(a);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>,list[i]);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们一般把vector当做链表看待使用，也就是第二种方式，这可以方便的处理不定长数组。<br>STL中的指针被称为迭代器</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">arr1</span><span class="hljs-params">(<span class="hljs-number">100</span>)</span></span>;<br><span class="hljs-type">int</span> arr2[<span class="hljs-number">100</span>];<br>vector&lt;<span class="hljs-type">int</span>&gt;::iterator p1;<br><span class="hljs-type">int</span> *p2;<br><br></code></pre></td></tr></table></figure><p>常见操作</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++">list.<span class="hljs-built_in">size</span>();<span class="hljs-comment">//数组元素个数   O(1)</span><br>list.<span class="hljs-built_in">clear</span>();<span class="hljs-comment">//一键清空数组 O(n)</span><br>list.<span class="hljs-built_in">empty</span>();<span class="hljs-comment">// 数组是否为空 O(1)</span><br>list.<span class="hljs-built_in">begin</span>()； <span class="hljs-comment">//首元素迭代器</span><br>list.<span class="hljs-built_in">end</span>()；<span class="hljs-comment">//最后一个元素的下一个元素的迭代器（此元素在数组中不存在）</span><br>list.<span class="hljs-built_in">erase</span>(p1) <span class="hljs-comment">//删除某个迭代器所在位置的元素 O(n) 这和实际的链表有区别，链表应该是O(1)</span><br>list.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">1</span>)  <span class="hljs-comment">//在数组最后添加元素  O(1);</span><br>list.<span class="hljs-built_in">pop_back</span>(<span class="hljs-number">1</span>) <span class="hljs-comment">//删除数组最后一个元素  O(1);</span><br></code></pre></td></tr></table></figure><h3 id="利用stl实现stack和queue"><a href="#利用stl实现stack和queue" class="headerlink" title="利用stl实现stack和queue"></a>利用stl实现stack和queue</h3><ul><li>括号匹配问题&#x2F;stack<br>策略：碰到左括号，压栈，碰到右括号，弹栈，判断是否相等。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">ok</span><span class="hljs-params">(<span class="hljs-type">char</span>* p)</span></span><br><span class="hljs-function"></span>&#123;<br>    stack&lt;<span class="hljs-type">char</span>&gt; a;<br>    <span class="hljs-keyword">while</span>(*p)&#123;<br>        <span class="hljs-keyword">if</span>(*p==<span class="hljs-string">&#x27;(&#x27;</span>) a.<span class="hljs-built_in">push</span>(<span class="hljs-string">&#x27;)&#x27;</span>);<br>        <span class="hljs-keyword">if</span>(*p==<span class="hljs-string">&#x27;[&#x27;</span>) a.<span class="hljs-built_in">push</span>(<span class="hljs-string">&#x27;[&#x27;</span>);<br>        <span class="hljs-keyword">if</span>(*p==<span class="hljs-string">&#x27;&#123;&#x27;</span>) a.<span class="hljs-built_in">push</span>(<span class="hljs-string">&#x27;&#123;&#x27;</span>);<br>        <span class="hljs-keyword">if</span>(*p==<span class="hljs-string">&#x27;)&#x27;</span>||*p==<span class="hljs-string">&#x27;]&#x27;</span>||*p==<span class="hljs-string">&#x27;&#125;&#x27;</span>)&#123;<br>            <span class="hljs-keyword">if</span>(a.<span class="hljs-built_in">empty</span>()) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            <span class="hljs-keyword">if</span>(a.<span class="hljs-built_in">top</span>()!=*p) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            a.<span class="hljs-built_in">pop</span>();<br>        &#125;<br>        p++<br>    &#125;<br>    <span class="hljs-keyword">return</span> a.<span class="hljs-built_in">empty</span>();<br>&#125;<br><br></code></pre></td></tr></table></figure><ul><li>queue 不多用，略</li></ul><h3 id="逆波兰表达式"><a href="#逆波兰表达式" class="headerlink" title="逆波兰表达式"></a>逆波兰表达式</h3><p>逆波兰表达式又叫后缀表达式，就是把运算符放在运算数的右边。<br>例子：我们常用的中缀表达式：（2+3）<em>5-（4</em>2）<br>逆波兰： 2 3 + 5 * 4 2 * -<br>不需要括号极大的方便了机器的求值</p><p>求值过程？遇到操作数就入栈<br>遇到操作符，则从栈弹出两个操作数，计算后再入栈。</p><ul><li>stringstream类</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span>  </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sstream&gt;</span>  </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span>  </span><br>  <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;  <br>    <span class="hljs-function">std::stringstream <span class="hljs-title">data</span><span class="hljs-params">(<span class="hljs-string">&quot;123 456 hello&quot;</span>)</span></span>;  <br>    <span class="hljs-type">int</span> a, b;  <br>    std::string s;  <br>  <br>    data &gt;&gt; a &gt;&gt; b &gt;&gt; s; <span class="hljs-comment">// 使用重载的 &gt;&gt; 操作符从 data 中提取数据  </span><br>  <br>    std::cout &lt;&lt; a &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; b &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; s &lt;&lt; std::endl; <span class="hljs-comment">// 输出提取的数据  </span><br>  <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;  <br><br>    <span class="hljs-comment">//结果 123 456 hello</span><br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c++"><br><span class="hljs-meta">#<span class="hljs-keyword">include</span>&lt;iostream?</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;sstream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stack&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstdlib&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    stack&lt;<span class="hljs-type">int</span>&gt; w;<br>    <span class="hljs-function">stringstream <span class="hljs-title">data</span><span class="hljs-params">(<span class="hljs-string">&quot;2 3 + 5 * 4 2 * -  &quot;</span>)</span></span>;   <br>    string s;   <br>    <span class="hljs-comment">//忽略了空白字符</span><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">    data &gt;&gt; s; 是一个输入操作，它从 stringstream 对象 data 中读取数据，并将读取的数据存储在字符串变量 s 中。这里的 &gt;&gt; 是 C++ 中的提取操作符，用于从输入流中提取数据。在这个上下文中，它从 data 中提取下一个非空白字符序列，并将其作为字符串存储在 s 中。</span><br><span class="hljs-comment">    */</span><br>    <span class="hljs-keyword">while</span>(data&gt;&gt; s)&#123;<br>        <span class="hljs-keyword">if</span>(s==<span class="hljs-string">&quot;+&quot;</span> || s==<span class="hljs-string">&quot;-&quot;</span> || s==<span class="hljs-string">&quot;*&quot;</span>)&#123;<br>            <span class="hljs-type">int</span> b=w.<span class="hljs-built_in">top</span>();w.<span class="hljs-built_in">pop</span>();<br>            <span class="hljs-type">int</span> a=w.<span class="hljs-built_in">top</span>();w.<span class="hljs-built_in">pop</span>();<br>            <span class="hljs-comment">//罗列if语句</span><br>            <span class="hljs-keyword">if</span>(s==<span class="hljs-string">&quot;+&quot;</span>) w.<span class="hljs-built_in">push</span>(a+b);<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(s==<span class="hljs-string">&quot;-&quot;</span>) w.<span class="hljs-built_in">push</span>(a-b);<br>            <span class="hljs-keyword">else</span> w.<span class="hljs-built_in">push</span>(a*b);<br>        &#125;<br>        <span class="hljs-keyword">else</span> &#123;<br>            w.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">atoi</span>(s.<span class="hljs-built_in">c_str</span>()));<br>        &#125;<br>    &#125;<br>    cout&lt;&lt;w.<span class="hljs-built_in">top</span>()&lt;&lt;endl;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h3><p>之前敲过了，现在简单复习一下，然后用链表解决约瑟夫环问题</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Node</span>&#123;<br>    <span class="hljs-type">int</span> data;<br>    Node* next;<br>    <span class="hljs-built_in">Node</span>(<span class="hljs-type">int</span> x)&#123;<br>        data=x;<br>        next=<span class="hljs-literal">NULL</span>;<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">len</span><span class="hljs-params">(Node* p)</span>    <span class="hljs-comment">//链表长度？</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(p)&#123;<br>        p=p-&gt;next;<br>        n++<br>    &#125;<br>    <span class="hljs-keyword">return</span> n;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">show</span><span class="hljs-params">(Node* p)</span></span>&#123;<br>    Node* t=head;<br>    <span class="hljs-keyword">while</span>(t)&#123;<br>        cout&lt;&lt;head-&gt;data&lt;&lt;endl;<br>        t=t-&gt;next;<br>    &#125;<br>    cout&lt;&lt;endl;<br>&#125;<br><br><span class="hljs-function">Node* <span class="hljs-title">del</span><span class="hljs-params">(Node* head,<span class="hljs-type">int</span> x)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(head==<span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>    Node* p=head;<br>    <span class="hljs-keyword">while</span>(p-&gt;next)&#123;<br>        <span class="hljs-keyword">if</span>(p-&gt;next-&gt;data==x)&#123;<br>            Node* q=p-&gt;next;<br>            p-&gt;next=(p-&gt;next)-&gt;next;<br>            <span class="hljs-keyword">delete</span> q;<br>            <span class="hljs-keyword">return</span> head;<br>        &#125;<br>    &#125;<br>&#125;<br><br><br></code></pre></td></tr></table></figure><h3 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;sstream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">bitree</span>&#123;<br>    <span class="hljs-type">int</span> data;<br>    bitree* left;<br>    bitree* right;<br>    <span class="hljs-built_in">bitree</span>(<span class="hljs-type">int</span> x)&#123;<br>        data=x;<br>        left=<span class="hljs-literal">NULL</span>;<br>        right=<span class="hljs-literal">NULL</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">height</span><span class="hljs-params">()</span></span>&#123;                   <span class="hljs-comment">//树的深度</span><br>        <span class="hljs-type">int</span> a =left? left-&gt;<span class="hljs-built_in">height</span>() : <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> b =right? right-&gt;<span class="hljs-built_in">height</span>() : <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(a,b)<span class="hljs-number">+1</span>;<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pre_order</span><span class="hljs-params">()</span></span>&#123;<br>    cout&lt;&lt;data&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>    <span class="hljs-keyword">if</span>(left) left-&gt;<span class="hljs-built_in">pre_order</span>();<br>    <span class="hljs-keyword">if</span>(right) right-&gt;<span class="hljs-built_in">pre_order</span>();<br>&#125;<br><span class="hljs-function">bitree* <span class="hljs-title">create_tree</span><span class="hljs-params">(stringstream* ss)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> x; *ss&gt;&gt;x;<br>    <span class="hljs-keyword">if</span>(x==<span class="hljs-number">-1</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br><br>    bitree* r = <span class="hljs-keyword">new</span> <span class="hljs-built_in">bitree</span>(x);<br><br>    r-left=<span class="hljs-built_in">create_tree</span>(ss);<br>    r-&gt;right =<span class="hljs-built_in">create_tree</span>(ss);<br><br>    <span class="hljs-keyword">return</span> r;<br><br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">/*bitree a(1);</span><br><span class="hljs-comment">    a.left = new bitree(2);</span><br><span class="hljs-comment">    a.right = new bitree(3);</span><br><span class="hljs-comment">    </span><br><span class="hljs-comment">    cout&lt;&lt; a.height()&lt;&lt;endl;*/</span><br>    <span class="hljs-function">stringstream <span class="hljs-title">ss</span><span class="hljs-params">(<span class="hljs-string">&quot;1 2 4 -1 -1 5 9 -1 -1 -1 3 -1 6 7 -1 -1 8 -1 -1&quot;</span>)</span></span>;<br>    bitree* p=<span class="hljs-built_in">create_tree</span>(&amp;ss);<br>    cout&lt;&lt; p-&gt;<span class="hljs-built_in">height</span>();<br>&#125;<br><br><br><br></code></pre></td></tr></table></figure><h3 id="树"><a href="#树" class="headerlink" title="树"></a>树</h3><p>多个分支考虑动态数组        </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Tree</span>&#123;<br>    string data;<br>    vector&lt;Tree*&gt; child;<br><br>    <span class="hljs-built_in">Tree</span>(string x)&#123;<br>        data = x;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>模拟一个菜单</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Tree</span>&#123;<br>    string data;<br>    vector&lt;Tree*&gt; child;<br><br>    <span class="hljs-built_in">Tree</span>(string x)&#123;<br>        data=x;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(Tree* t)</span></span>&#123;<br>        child.<span class="hljs-built_in">push_back</span>(t);<br>    &#125;<br><br>    <span class="hljs-function">string <span class="hljs-title">run</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(child.<span class="hljs-built_in">size</span>()==<span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> data;<br>        <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;child.<span class="hljs-built_in">size</span>();i++)&#123;<br>                cout&lt;&lt;i&lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;child[i]-&gt;data&lt;&lt;endl;<br>            &#125;<br>            cout&lt;&lt; <span class="hljs-string">&quot;-1 return to the pre&quot;</span>&lt;&lt;endl;<br><br>            <span class="hljs-type">int</span>  a; cin&gt;&gt;a;<br><br>            <span class="hljs-keyword">if</span>(a==<span class="hljs-number">-1</span>) <span class="hljs-keyword">return</span> <span class="hljs-string">&quot; &quot;</span>;<br>            <span class="hljs-keyword">if</span>(a&gt;=<span class="hljs-number">0</span>&amp;&amp; a&lt;child.<span class="hljs-built_in">size</span>())&#123;<br>                string r= child[a]-&gt;run;<br>                <span class="hljs-keyword">if</span>(r==<span class="hljs-string">&quot; &quot;</span>) <span class="hljs-keyword">continue</span>;<br>                <span class="hljs-keyword">return</span> r;<br>            &#125;<br>        &#125;<br><br>    &#125;<br><br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    Tree* a=<span class="hljs-keyword">new</span> <span class="hljs-built_in">Tree</span>(<span class="hljs-string">&quot;fruit&quot;</span>)；<br>    a-&gt;<span class="hljs-built_in">add</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Tree</span>(<span class="hljs-string">&quot;apple&quot;</span>));<br>    a-&gt;<span class="hljs-built_in">add</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Tree</span>(<span class="hljs-string">&quot;banana&quot;</span>));<br>    a-&gt;<span class="hljs-built_in">add</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Tree</span>(<span class="hljs-string">&quot;purple&quot;</span>));<br><br>    string r=a.<span class="hljs-built_in">run</span>();<br>    cout&lt;&lt;<span class="hljs-string">&quot;you select &quot;</span>&lt;&lt;r&lt;&lt;endl;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="dfs与bfs"><a href="#dfs与bfs" class="headerlink" title="dfs与bfs"></a>dfs与bfs</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;queue&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(Tree* p)</span></span>&#123;      <span class="hljs-comment">//先根序</span><br>    cout&lt;&lt;p-&gt;data &lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;p-&gt;child.<span class="hljs-built_in">size</span>();i++)<br>        <span class="hljs-built_in">dfs</span>(p-&gt;child[i]);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">bfs</span><span class="hljs-params">(Tree* p)</span></span>&#123;     <span class="hljs-comment">//使用队列</span><br>    queue&lt;Tree*&gt; Q;<br>    Q.<span class="hljs-built_in">push</span>(p);<br>    <span class="hljs-keyword">while</span>(!Q.<span class="hljs-built_in">empty</span>())&#123;<br>        Tree* q= Q.<span class="hljs-built_in">front</span>();<br>        Q.<span class="hljs-built_in">pop</span>();<br>        cout&lt;&lt;q-&gt;data&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;           <span class="hljs-comment">//打印次层</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;q-&gt;child.<span class="hljs-built_in">size</span>();i++)<br>            Q.<span class="hljs-built_in">push</span>(q-&gt;child[i];)    <span class="hljs-comment">//所有孩子入队</span><br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="树的二叉树表示"><a href="#树的二叉树表示" class="headerlink" title="树的二叉树表示"></a>树的二叉树表示</h3><p>在存储上使用二叉树，仍然能表示出一般树，甚至森林，也就是说二叉树和树存在一一对应关系<br>用二叉树表示的规则是：</p><ul><li>左孩子： 表示该节点的第一个孩子</li><li>右孩子： 表示该节点的下一个兄弟</li></ul><p>定理            </p><ul><li>树的先根遍历等于二叉树的先根序遍历          </li><li>树的后根遍历等于二叉树的<strong>中根序遍历</strong></li></ul><p><img src="https://www.freeimg.cn/i/2024/07/25/66a25997797d3.png" alt="1721915798292.png"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs c++"><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Tree</span>&#123;<br>    <span class="hljs-type">int</span> data;<br>    Tree* child;<br>    Tree* brother;<br><br>    <span class="hljs-built_in">Tree</span>(<span class="hljs-type">int</span> x)&#123;<br>        data=x;<br>        child=brother=<span class="hljs-literal">NULL</span><br>    &#125;<br><br>    <span class="hljs-type">void</span> <span class="hljs-built_in">add</span>(Tree* t)&#123;<br>        <span class="hljs-keyword">if</span>(child=<span class="hljs-literal">NULL</span>) child=t;   <span class="hljs-comment">//该节点没孩子就是该节点的孩子</span><br>        <span class="hljs-keyword">else</span> child-&gt;<span class="hljs-built_in">add_brother</span>(t);   <span class="hljs-comment">//该节点有孩子，但是该节点只能有一个孩子，所以作为该节点孩子的兄弟</span><br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add_brother</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(brother==<span class="hljs-literal">NULL</span>)  <br>            brother=t;<br>        <span class="hljs-keyword">else</span> <br>            brother-&gt;<span class="hljs-built_in">add_brother</span>(t);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pre_order</span><span class="hljs-params">()</span></span>&#123;<br>        cout&lt;&lt;data&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>        <span class="hljs-keyword">if</span>(child) child-&gt;<span class="hljs-built_in">pre_order</span>();<br>        <span class="hljs-keyword">if</span>(brother) brother-&gt;<span class="hljs-built_in">pre_order</span>();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">in_order</span><span class="hljs-params">()</span></span>&#123;<br>        <br>        <span class="hljs-keyword">if</span>(child) child-&gt;<span class="hljs-built_in">pre_order</span>();<br>        cout&lt;&lt;data&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>        <span class="hljs-keyword">if</span>(brother) brother-&gt;<span class="hljs-built_in">pre_order</span>();<br>    &#125;<br>    <br>&#125;;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-function">Tree <span class="hljs-title">a</span><span class="hljs-params">(<span class="hljs-number">1</span>)</span></span>;<br>    a.<span class="hljs-built_in">add</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Tree</span>(<span class="hljs-number">2</span>));<br>    a.<span class="hljs-built_in">add</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Tree</span>(<span class="hljs-number">3</span>));<br>    a.<span class="hljs-built_in">add</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Tree</span>(<span class="hljs-number">4</span>));<br>    a.child-&gt;brother-&gt;<span class="hljs-built_in">add</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Tree</span>(<span class="hljs-number">5</span>));<br>    a.child-&gt;brother-&gt;<span class="hljs-built_in">add</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Tree</span>(<span class="hljs-number">6</span>));<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="排序二叉树"><a href="#排序二叉树" class="headerlink" title="排序二叉树"></a>排序二叉树</h3><p>二叉树可以用于方便的搜索，动态查找</p><ul><li>插入数据时候，小的在左，大的在右</li><li>按照中根序遍历就可以得到排序结果</li><li>折半查找速度很快</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">bitree</span>&#123;<br>    <span class="hljs-type">int</span> data;<br>    bitree* left;<br>    bitree* right;<br>    <span class="hljs-built_in">bitree</span>(<span class="hljs-type">int</span> x)&#123;<br>        data=x;<br>        left=<span class="hljs-literal">NULL</span>;<br>        right=<span class="hljs-literal">NULL</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(bitree* t)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(t-&gt;data&lt;data)&#123;<br>            <span class="hljs-keyword">if</span>(left)<br>                left-&gt;<span class="hljs-built_in">add</span>(t);<br>            <span class="hljs-keyword">else</span> <br>                left=t;<br>        &#125;<br>        <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">if</span>(right)<br>                right-&gt;<span class="hljs-built_in">add</span>(t);<br>            <span class="hljs-keyword">else</span> <br>                right=t;<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">show</span><span class="hljs-params">()</span></span>&#123;<br>    <br>    <span class="hljs-keyword">if</span>(left) left-&gt;<span class="hljs-built_in">pre_order</span>();<br>    cout&lt;&lt;data&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>    <span class="hljs-keyword">if</span>(right) right-&gt;<span class="hljs-built_in">pre_order</span>();<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法竞赛</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>template:动态规划</title>
    <link href="/2025/03/21/%E7%AE%97%E6%B3%95/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E6%A8%A1%E7%89%88/"/>
    <url>/2025/03/21/%E7%AE%97%E6%B3%95/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E6%A8%A1%E7%89%88/</url>
    
    <content type="html"><![CDATA[<h1 id="背包问题"><a href="#背包问题" class="headerlink" title="背包问题"></a>背包问题</h1><h2 id="01背包"><a href="#01背包" class="headerlink" title="01背包"></a>01背包</h2><p><a href="https://imgse.com/i/pAhge6s"><img src="https://s21.ax1x.com/2024/11/25/pAhge6s.md.png" alt="pAhge6s.md.png"></a></p><p><a href="https://www.acwing.com/problem/content/2/">https://www.acwing.com/problem/content/2/</a></p><p>dp的过程可以理解为一个全局状态更新的过程，</p><ul><li>1，状态函数，记f[i][j]为前i个物品放入容量为j的背包的最大价值。</li><li>2，观察边界情况写转态转移，当前背包容量为j，考虑？第i个物品能否放入？是否放入？<br>若j&lt;w[i],无法放入，则f[i][j]&#x3D;f[i-1][j]<br>若j&gt;&#x3D;w[i],可以放入，判断要不要放入。f[i][j]&#x3D;max(f[i-1][j]+f[i-1][j-v[i]]+w[i])</li></ul><p><a href="https://imgse.com/i/pAhge6s"><img src="https://s21.ax1x.com/2024/11/25/pAhge6s.md.png" alt="pAhge6s.md.png"></a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)<br>    &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=m;j++)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(j&lt;v[i]) f[i][j]=f[i<span class="hljs-number">-1</span>][j];<br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                f[i][j]=<span class="hljs-built_in">max</span>(f[i<span class="hljs-number">-1</span>][j],f[i<span class="hljs-number">-1</span>][j-v[i]]+w[i]);<br>            &#125;<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><p>时间复杂度$O(mn)$,无法优化，空间复杂度可以优化，事实上维度i可以利用滚动数组省去。<br>也就是说我们每次从后往前优化f[j],确保使用的状态都是上一层的状态，防止串联情况发生。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)<br>    &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=m;j&gt;=v[i];j--)<br>        &#123;<br>            f[j]=<span class="hljs-built_in">max</span>(f[j],f[j-v[i]]+w[i]);<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><h2 id="完全背包问题"><a href="#完全背包问题" class="headerlink" title="完全背包问题"></a>完全背包问题</h2><p>完全背包就是在一维背包的基础上取消了对物品数量的限制。这对应着状态转移方程的变化。我们应当用刚刚更新过的值取更新现在的值<br><a href="https://imgse.com/i/pAhoG90"><img src="https://s21.ax1x.com/2024/11/26/pAhoG90.md.png" alt="pAhoG90.md.png"></a></p><ul><li>1.当前背包容量j&lt;w[i],不能放入，则f[i][j]&#x3D;f[i-1][j]</li><li>2.当前背包容量j&gt;&#x3D;w[i],能放入，但要比较代价<br>(1)若第i件物品不放入背包，则 f[i][j]&#x3D;f[i-1][j]<br>(2)若第i件物品放入背包，则 f[i][j]&#x3D;f[i][j-w[i]]+c[i]<br>在选择第i件物品的情况下(无论多少)，背包容量为j-w[i]时包含了放入放入了第i件物品的情况(因为从前往后更新的)。容量为j时还可以再放入第i件物品，所以用f[i][j-w[i]]更新f[i][j]</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)<br>    &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=m;j++)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(j&gt;=v[i])  f[j]=<span class="hljs-built_in">max</span>(f[j],f[j-v[i]]+w[i]);<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><h2 id="多重背包-朴素算法"><a href="#多重背包-朴素算法" class="headerlink" title="多重背包-朴素算法"></a>多重背包-朴素算法</h2><p>朴素的思想是把多重背包转化为01背包处理，第i种物品可以取0件，1件…s[i]件，为此取第i种物品的情况分解为取s[i]种01背包的物品，每件体积为kv[i];价值为kw[i];</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)<br>    &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=m;j&gt;=v[i];j--)<br>        &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=<span class="hljs-number">0</span>;k*v[i]&lt;=j&amp;&amp;k&lt;=s[i];k++)<br>            &#123;<br>                f[j]=<span class="hljs-built_in">max</span>(f[j],f[j-k*v[i]]+k*w[i]);<br>            &#125;<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><h2 id="多重背包-二进制优化"><a href="#多重背包-二进制优化" class="headerlink" title="多重背包-二进制优化"></a>多重背包-二进制优化</h2><p>二进制优化基于这样一个事实，一个数n一定可以由 一系列2的k次方的数相加表示，比如我们要取出50个苹果，我们可以分成几个箱子：（1,2,4,8,16,19），则0-50之间的任意个数都可以使用且仅使用上面的数一次后相加得到。基于这一事实，在多重背包问题中我们可以把第i件物品拆分为若干件物品，转化为01背包问题。例如si&#x3D;12，拆分系数为1,2,4,5，对应(v1,wi),(2vi,2wi),4(vi,4wi),(5vi,5wi).</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1010</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> M = <span class="hljs-number">2010</span>;<br><span class="hljs-type">int</span> v[N],w[N],s[N],vv[<span class="hljs-number">12</span>*N],ww[<span class="hljs-number">12</span>*N],n,m,cnt=<span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> f[M];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cin&gt;&gt;n&gt;&gt;m;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++) cin&gt;&gt;v[i]&gt;&gt;w[i]&gt;&gt;s[i];<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)<br>    &#123;<br>        <span class="hljs-type">int</span> k=<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span>(k&lt;=s[i])<br>        &#123;<br>            cnt++;<br>            vv[cnt]=k*v[i];<br>            ww[cnt]=k*w[i];<br>            s[i]-=k;<br>            k=k*<span class="hljs-number">2</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(s[i])<br>        &#123;<br>            cnt++;<br>            vv[cnt]=s[i]*v[i];<br>            ww[cnt]=s[i]*w[i];<br>            <br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=cnt;i++)<br>    &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=m;j&gt;=vv[i];j--)<br>        f[j]=<span class="hljs-built_in">max</span>(f[j],f[j-vv[i]]+ww[i]);<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>,f[m]);<br>&#125;<br></code></pre></td></tr></table></figure><p>时间复杂度由$O(n \sum s_i)$化为$O(n\sum logs_i)$<br>拆s[i]的过程自己维护一个动态数组，不要用vector，因为vector下标是从0开始的。</p><h2 id="分组背包"><a href="#分组背包" class="headerlink" title="分组背包"></a>分组背包</h2><p>n组物品和一个容量为m的背包，同一组中的物品最多选一个。<br>更新思路和01背包其实是一样的，不过每次更新j的时候，在当前j下试探组中每一个物品即可<br>由于只能取一次，滚动数组优化的时候j和01背包类似，从大到小更新。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)<br>    &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=m;j&gt;=<span class="hljs-number">0</span>;j--)<br>        &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=<span class="hljs-number">1</span>;k&lt;=s[i];k++)<br>            &#123;<br>                <span class="hljs-keyword">if</span>(j&gt;=v[i][k])<br>                f[j]=<span class="hljs-built_in">max</span>(f[j],f[j-v[i][k]]+w[i][k]);<br>            &#125;<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><h1 id="线性dp"><a href="#线性dp" class="headerlink" title="线性dp"></a>线性dp</h1><h2 id="数字三角形"><a href="#数字三角形" class="headerlink" title="数字三角形"></a>数字三角形</h2><p>充分体现出数组开大的好处，没赋值的地方都是0，边界条件基本不用细致考虑。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">510</span>;<br><span class="hljs-type">int</span> n,f[N][N];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cin&gt;&gt;n;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)<br>    &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=i;j++)<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;f[i][j]);<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=n;i&gt;=<span class="hljs-number">1</span>;i--)<br>    &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=i;j++)<br>        &#123;<br>            f[i][j]+=<span class="hljs-built_in">max</span>(f[i<span class="hljs-number">+1</span>][j],f[i<span class="hljs-number">+1</span>][j<span class="hljs-number">+1</span>]);<br>        &#125;<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>,f[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>]);<br>&#125;<br>````<br><br>## 最长上升子序列(LIS)-朴素算法<br><br>题目描述：<br><br>给定一个无序的整数数组，找出其中最长上升子序列(LIS)的长度。输入：[<span class="hljs-number">5</span>,<span class="hljs-number">7</span>,<span class="hljs-number">1</span>,<span class="hljs-number">9</span>,<span class="hljs-number">4</span>,<span class="hljs-number">6</span>,<span class="hljs-number">2</span>,<span class="hljs-number">8</span>,<span class="hljs-number">3</span>]<br><br>输出：<span class="hljs-number">4</span><br><br>解释：最长上升子序列是[<span class="hljs-number">1</span>,<span class="hljs-number">4</span>,<span class="hljs-number">6</span>,<span class="hljs-number">8</span>]<br><br>其长度为<span class="hljs-number">4</span>。<br><br>我们使用f[i]记录以a[i]结尾的LIS长度，这样可以保证最优子结构。<br><br>并使用双指针ij进行遍历，对于当下遍历的a[i],遍历所有(<span class="hljs-number">1</span>&lt;=j&lt;i),当下的LIS一定是前面的LIS加上a[i]得到的，为此<br>得到代码如下<br>```c++<br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1010</span>;<br><span class="hljs-type">int</span> n;<br><span class="hljs-type">int</span> a[N], f[N];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;n);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++ ) <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;a[i]);<br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)<br>    &#123;<br>        f[i]=<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;i;j++)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(a[i]&gt;a[j]) f[i]=<span class="hljs-built_in">max</span>(f[j]<span class="hljs-number">+1</span>,f[i]);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++ ) res = <span class="hljs-built_in">max</span>(res, f[i]);<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, res);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>时间复杂度$O(n(n-1)&#x2F;2)$</p><h2 id="贪心-二分优化LIS"><a href="#贪心-二分优化LIS" class="headerlink" title="贪心+二分优化LIS"></a>贪心+二分优化LIS</h2><p><a href="https://imgse.com/i/pA4PrcD"><img src="https://s21.ax1x.com/2024/11/26/pA4PrcD.png" alt="pA4PrcD.png"></a></p><p>这个算法把时间复杂度优化到了$O(nlogm)$,原因在于最大长度的维护使用了二分。具体的操作是这样的，维护一个b[len].<br><a href="https://imgse.com/i/pA4PHBj"><img src="https://s21.ax1x.com/2024/11/26/pA4PHBj.png" alt="pA4PHBj.png"></a></p><p>注意b不是最长上升子序列，但b的长度始终代表出现过的最长上升子序列长度。<br>比如我们看上图b由259到249的更新过程，LIS实际上由259变为了24，不删除9是有这样两种考虑</p><ul><li>在本题数据中4代替了5,9没必要删去，让他呆在这里即可，后续如果由2,4发展出了更长的LIS，一定是踩过9向前发展的（本题6踩过了9）</li><li>如果9后面跟的是10，怎么办？没关系，因为4只是代替了5，由2 4 9 10和2 5 9 10构成的序列长度是一样的<br>无论如何，b的长度可以代表出现过的最长LIS的长度。</li></ul><p>复习一下二分模版</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// l==r时退出while循环</span><br><span class="hljs-comment">// 全都是闭区间</span><br><span class="hljs-comment">// else后 l总是+1，r总是-1</span><br><span class="hljs-comment">// mid加不加1只取决于r=mid还是l=mid,只是为了防止l=mid出现死循环，l=1 r=2 mid=1.5=1 则l=mid=1死循环</span><br><span class="hljs-comment">// 不需要可以判断答案在哪一个区间，看看怎么写check能够使得 r=mid或者l=mid即可</span><br><br><br><span class="hljs-comment">// 区间[l, r]被划分成[l, mid]和[mid + 1, r]时使用：比如找第一个大于等于五的数的位置</span><br><span class="hljs-comment">// if(a[mid]&gt;=5) r=mid</span><br><span class="hljs-comment">// else l = mid+1</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">bsearch_1</span><span class="hljs-params">(<span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">while</span> (l &lt; r)<br>    &#123; <br>        <span class="hljs-type">int</span> mid = l + r &gt;&gt; <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">check</span>(mid)) r = mid;    <br>        <span class="hljs-keyword">else</span> l = mid + <span class="hljs-number">1</span>;    <span class="hljs-comment">//严格边界</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> l;<br>&#125;<br><span class="hljs-comment">// 区间[l, r]被划分成[l, mid - 1]和[mid, r]时使用：</span><br><span class="hljs-comment">//比如找最后一个小于等于5的数的位置， check就是 if a[mid]&lt;=5</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">bsearch_2</span><span class="hljs-params">(<span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">while</span> (l &lt; r)<br>    &#123;<br>        <span class="hljs-type">int</span> mid = l + r + <span class="hljs-number">1</span> &gt;&gt; <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">check</span>(mid)) l = mid;<br>        <span class="hljs-keyword">else</span> r = mid - <span class="hljs-number">1</span>;    <span class="hljs-comment">//严格边界</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> l;<br>&#125;<br></code></pre></td></tr></table></figure><p>本题</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">100006</span>;<br><span class="hljs-type">int</span> a[N],b[N],len=<span class="hljs-number">0</span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br><br>    <span class="hljs-type">int</span> l=<span class="hljs-number">1</span>,r=len;<br>    <span class="hljs-keyword">while</span>(l&lt;r)<br>    &#123;<br>        <span class="hljs-type">int</span> mid =l+r&gt;&gt;<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span>(b[mid]&gt;=x) r=mid;<br>        <span class="hljs-keyword">else</span> l=mid<span class="hljs-number">+1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> r;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n; <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;n);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++) <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;a[i]);<br>    b[<span class="hljs-number">1</span>]=a[<span class="hljs-number">1</span>]; len=<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">2</span>;i&lt;=n;i++)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(a[i]&gt;b[len]) b[++len]=a[i];<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            <span class="hljs-type">int</span> j =<span class="hljs-built_in">find</span>(a[i]);<br>            b[j]=a[i];<br>        &#125;<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>,len);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="最长公共子序列"><a href="#最长公共子序列" class="headerlink" title="最长公共子序列"></a>最长公共子序列</h2><p>下面的图包含了更新f和记录序列的方式，利用了前驱数组p[i][j],可以通过·回溯找到最长公共子序列</p><p><a href="https://imgse.com/i/pA4VcDS"><img src="https://s21.ax1x.com/2024/11/26/pA4VcDS.md.png" alt="pA4VcDS.md.png"></a></p><p>下面给出求最长长度的代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N =<span class="hljs-number">1010</span>;<br><span class="hljs-type">int</span> f[N][N],n,m;<br><span class="hljs-comment">//f[i][j]表示用a的前i个数，b的前j个数</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);<br>    string a,b;<br>    cin&gt;&gt;a&gt;&gt;b;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)<br>    &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=m;j++)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(a[i<span class="hljs-number">-1</span>]==b[j<span class="hljs-number">-1</span>]) f[i][j]=f[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>]<span class="hljs-number">+1</span>;<br>            <span class="hljs-keyword">else</span> f[i][j]=<span class="hljs-built_in">max</span>(f[i<span class="hljs-number">-1</span>][j],f[i][j<span class="hljs-number">-1</span>]);<br>        &#125;<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>,f[n][m]);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="最短编辑距离"><a href="#最短编辑距离" class="headerlink" title="最短编辑距离"></a>最短编辑距离</h2><p><a href="https://imgse.com/i/pA4dSkd"><img src="https://s21.ax1x.com/2024/11/27/pA4dSkd.md.png" alt="pA4dSkd.md.png"></a></p><p><a href="https://imgse.com/i/pA4av0e"><img src="https://s21.ax1x.com/2024/11/27/pA4av0e.md.png" alt="pA4av0e.md.png"></a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1010</span>;<br><span class="hljs-type">int</span> f[N][N],n,m;<br>string a,b;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cin&gt;&gt;n;<br>    cin&gt;&gt;a;<br>    cin&gt;&gt;m;<br>    cin&gt;&gt;b;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++) f[i][<span class="hljs-number">0</span>]=i;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=m;j++) f[<span class="hljs-number">0</span>][j]=j;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)<br>    &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=m;j++)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(a[i<span class="hljs-number">-1</span>]==b[j<span class="hljs-number">-1</span>]) f[i][j]=f[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>];<br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                f[i][j]=<span class="hljs-built_in">min</span>(f[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>],<span class="hljs-built_in">min</span>(f[i<span class="hljs-number">-1</span>][j],f[i][j<span class="hljs-number">-1</span>]))<span class="hljs-number">+1</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>,f[n][m]);<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="区间dp：石子划分"><a href="#区间dp：石子划分" class="headerlink" title="区间dp：石子划分"></a>区间dp：石子划分</h1><p>如何划分石子使得代价最小？</p><p><a href="https://imgse.com/i/pA4wzRI"><img src="https://s21.ax1x.com/2024/11/27/pA4wzRI.md.png" alt="pA4wzRI.md.png"></a></p><p>关键在于遍历的顺序和划分的理解。按照区间长度枚举，是因为dp更新较长区间的时候，必然会用到较短区间的结果，也就是状态集合的扩张。为此</p><ul><li>大循环是len的枚举。         </li><li>在给定的的len下枚举所有长为len的区间，因此中间循环是枚举左端点，从而枚举所有长为len的区间。          </li><li>转态转移是考虑内部所有划分得到的最小值，因此枚举划分点k即可。</li></ul><p><a href="https://imgse.com/i/pA409QP"><img src="https://s21.ax1x.com/2024/11/27/pA409QP.md.png" alt="pA409QP.md.png"></a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">310</span>;<br><span class="hljs-type">int</span> n;<br><span class="hljs-type">int</span> s[N];<br><span class="hljs-type">int</span> f[N][N];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;n);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++ ) <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;s[i]);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++ ) s[i] += s[i - <span class="hljs-number">1</span>];<br>    <span class="hljs-built_in">memset</span>(f,<span class="hljs-number">0x3f</span>,<span class="hljs-keyword">sizeof</span> f);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++) f[i][i]=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> len=<span class="hljs-number">2</span>;len&lt;=n;len++)<br>    &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> l=<span class="hljs-number">1</span>;l+len<span class="hljs-number">-1</span>&lt;=n;l++)<br>        &#123;<br>            <span class="hljs-type">int</span> r = l+len<span class="hljs-number">-1</span>;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=l;k&lt;r;k++)<br>            &#123;<br>                f[l][r]=<span class="hljs-built_in">min</span>(f[l][r],f[l][k]+f[k<span class="hljs-number">+1</span>][r]+s[r]-s[l<span class="hljs-number">-1</span>]);<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, f[<span class="hljs-number">1</span>][n]);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="计数类dp-整数分解"><a href="#计数类dp-整数分解" class="headerlink" title="计数类dp-整数分解"></a>计数类dp-整数分解</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1010</span>;<br><span class="hljs-type">int</span> f[N][N];<br><span class="hljs-type">int</span> n;<br><span class="hljs-type">int</span> mod = <span class="hljs-number">1e9</span><span class="hljs-number">+7</span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;n);<br>    f[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]=<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++) f[i][<span class="hljs-number">0</span>]=<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)<br>    &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=n;j++)<br>        <span class="hljs-comment">//如果写朴素算法，一定要判断范围</span><br>        <span class="hljs-keyword">if</span>(j&gt;=i) f[i][j]=(f[i<span class="hljs-number">-1</span>][j]+f[i][j-i])%mod;<br>        <span class="hljs-keyword">else</span> f[i][j]=f[i<span class="hljs-number">-1</span>][j]%mod;<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>,f[n][n]%mod);<br></code></pre></td></tr></table></figure><h1 id="树形dp"><a href="#树形dp" class="headerlink" title="树形dp"></a>树形dp</h1><p><a href="https://imgse.com/i/pA45ef0"><img src="https://s21.ax1x.com/2024/11/27/pA45ef0.md.png" alt="pA45ef0.md.png"></a></p><p><a href="https://imgse.com/i/pA45npV"><img src="https://s21.ax1x.com/2024/11/27/pA45npV.md.png" alt="pA45npV.md.png"></a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">6010</span>;<br><br><span class="hljs-type">int</span> n;<br>vector&lt;<span class="hljs-type">int</span>&gt; adj[N];  <span class="hljs-comment">// 使用vector表示邻接表</span><br><span class="hljs-type">int</span> happy[N];<br><span class="hljs-type">int</span> f[N][<span class="hljs-number">2</span>];<br><span class="hljs-type">bool</span> has_fa[N];<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> u)</span></span><br><span class="hljs-function"></span>&#123;<br>    f[u][<span class="hljs-number">1</span>] = happy[u];<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j : adj[u])  <span class="hljs-comment">// 遍历u的所有子节点</span><br>    &#123;<br>        <span class="hljs-built_in">dfs</span>(j);<br><br>        f[u][<span class="hljs-number">1</span>] += f[j][<span class="hljs-number">0</span>];<br>        f[u][<span class="hljs-number">0</span>] += <span class="hljs-built_in">max</span>(f[j][<span class="hljs-number">0</span>], f[j][<span class="hljs-number">1</span>]);<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;n);<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;happy[i]);<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n - <span class="hljs-number">1</span>; i++)<br>    &#123;<br>        <span class="hljs-type">int</span> a, b;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;a, &amp;b);<br>        adj[b].<span class="hljs-built_in">push_back</span>(a);  <span class="hljs-comment">// 将a添加到b的邻接表中</span><br>        has_fa[a] = <span class="hljs-literal">true</span>;<br>    &#125;<br><br>    <span class="hljs-type">int</span> root = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (has_fa[root]) root++;<br><br>    <span class="hljs-built_in">dfs</span>(root);<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, <span class="hljs-built_in">max</span>(f[root][<span class="hljs-number">0</span>], f[root][<span class="hljs-number">1</span>]));<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法竞赛</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>template:图论</title>
    <link href="/2025/03/21/%E7%AE%97%E6%B3%95/%E5%9B%BE%E8%AE%BA%E4%B8%8E%E6%90%9C%E7%B4%A2%E6%A8%A1%E7%89%88/"/>
    <url>/2025/03/21/%E7%AE%97%E6%B3%95/%E5%9B%BE%E8%AE%BA%E4%B8%8E%E6%90%9C%E7%B4%A2%E6%A8%A1%E7%89%88/</url>
    
    <content type="html"><![CDATA[<h1 id="树的dfs"><a href="#树的dfs" class="headerlink" title="树的dfs"></a>树的dfs</h1><p>dfs俗称爆搜，用于搜索所有情况<br>dfs需要维护的数据结构：表征当前遍历位置的u，表征某个状态是否被遍历过的st[N],（可能）当前遍历路径下的方案。<br>输出n个数的全排列</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">40</span>;<br><span class="hljs-type">int</span> path[N],n;<br><span class="hljs-type">bool</span> st[N];<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> u)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//设置递归出口</span><br>    <span class="hljs-keyword">if</span>(u==n<span class="hljs-number">+1</span>) <br>    &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++) cout&lt;&lt;path[i]&lt;&lt;<span class="hljs-string">&#x27; &#x27;</span>;<br>        cout&lt;&lt;endl;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(!st[i])<br>        &#123;<br>            st[i]=<span class="hljs-literal">true</span>;<br>            path[u]=i;<br>            <span class="hljs-built_in">dfs</span>(u<span class="hljs-number">+1</span>);<br>            <span class="hljs-comment">//状态复原是关键</span><br>            st[i]=<span class="hljs-literal">false</span>;<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cin&gt;&gt;n;<br>    <span class="hljs-built_in">dfs</span>(<span class="hljs-number">1</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="树的bfs"><a href="#树的bfs" class="headerlink" title="树的bfs"></a>树的bfs</h1><p>bfs用于寻找最短路，因为他每次先把等距离的路径全搜完再搜索更进一步的路               </p><p>bfs维护的数据结构：g[N][N]存图，d[N][N]存距离，一个queue存当下需要遍历的状态，并不断分裂队头状态为他的子状态并将子状态入队队尾       </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;queue&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">110</span>;<br><span class="hljs-type">int</span> n,m;<br><span class="hljs-type">int</span> g[N][N],d[N][N];<br><span class="hljs-keyword">typedef</span> pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt; pii;<br><span class="hljs-comment">//不要建坐标系，x第x行，y第y列</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">bfs</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    queue&lt;pii&gt; q;<br>    q.<span class="hljs-built_in">push</span>(&#123;<span class="hljs-number">0</span>,<span class="hljs-number">0</span>&#125;);<br>    <span class="hljs-built_in">memset</span>(d,<span class="hljs-number">-1</span>,<span class="hljs-keyword">sizeof</span> d);<br>    d[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]=<span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> dx[<span class="hljs-number">4</span>]=&#123;<span class="hljs-number">1</span>,<span class="hljs-number">-1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>&#125;;<br>    <span class="hljs-type">int</span> dy[<span class="hljs-number">4</span>]=&#123;<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">-1</span>&#125;;<br>    <span class="hljs-keyword">while</span>(q.<span class="hljs-built_in">size</span>())<br>    &#123;<br>        pii t=q.<span class="hljs-built_in">front</span>();<br>        q.<span class="hljs-built_in">pop</span>();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">4</span>;i++)<br>        &#123;<br>            <span class="hljs-type">int</span> x=t.first+dx[i];<br>            <span class="hljs-type">int</span> y=t.second+dy[i];<br>            <span class="hljs-keyword">if</span>(x&gt;=<span class="hljs-number">0</span>&amp;&amp;x&lt;n&amp;&amp;y&gt;=<span class="hljs-number">0</span>&amp;&amp;y&lt;m&amp;&amp;g[x][y]==<span class="hljs-number">0</span>&amp;&amp;d[x][y]==<span class="hljs-number">-1</span>)<br>            &#123;<br>                q.<span class="hljs-built_in">push</span>(&#123;x,y&#125;);<br>                d[x][y]=d[t.first][t.second]<span class="hljs-number">+1</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cin&gt;&gt;n&gt;&gt;m;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)<br>    &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;m;j++)<br>        cin&gt;&gt;g[i][j];<br>    &#125;<br>    <span class="hljs-built_in">bfs</span>();<br>    cout&lt;&lt;d[n<span class="hljs-number">-1</span>][m<span class="hljs-number">-1</span>];<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="图的dfs"><a href="#图的dfs" class="headerlink" title="图的dfs"></a>图的dfs</h1><p>考虑树的重心问题                </p><p>定义：树的重心是一个节点，当从树中移除该节点（及其所有连接的边）后，剩余的子树中最大的那棵包含最少的节点数。换句话说，树的重心是将树分成若干部分时，使得各部分节点数尽可能均衡的那个节点</p><p>如何存储无向图？邻接表：开一个vector数组存储每一个点联通的点            </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1e5</span><span class="hljs-number">+10</span>;<br>vector&lt;<span class="hljs-type">int</span>&gt; d[N];    <span class="hljs-comment">//点u联通的点存在 vector d[u]中</span><br><span class="hljs-type">int</span> n,ans=N;   <span class="hljs-comment">//注意ans的初始化</span><br><span class="hljs-type">bool</span> st[N];<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b)</span>    <span class="hljs-comment">//无向图</span></span><br><span class="hljs-function"></span>&#123;<br>    d[a].<span class="hljs-built_in">push_back</span>(b);<br>    d[b].<span class="hljs-built_in">push_back</span>(a);<br>&#125;<br><span class="hljs-comment">//求u的子支大小之和，包括u自己</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> u)</span></span><br><span class="hljs-function"></span>&#123;<br>    st[u]=<span class="hljs-literal">true</span>;<br>    <span class="hljs-type">int</span> sum=<span class="hljs-number">0</span>,size=<span class="hljs-number">0</span>;     <span class="hljs-comment">//sum存子支大小之和，size存最大子支大小</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> son:d[u])    <span class="hljs-comment">//遍历所有联通点</span><br>    &#123;<br>        <span class="hljs-keyword">if</span>(st[son]) <span class="hljs-keyword">continue</span>;    <span class="hljs-comment">//已经遍历过，跳过</span><br>        <span class="hljs-type">int</span> s=<span class="hljs-built_in">dfs</span>(son);          <span class="hljs-comment">//该子支大小</span><br>        sum+=s;                  <span class="hljs-comment">//更新sum</span><br>        size=<span class="hljs-built_in">max</span>(size,s);        <span class="hljs-comment">//更新size</span><br>    &#125;<br>    size=<span class="hljs-built_in">max</span>(size,n-sum<span class="hljs-number">-1</span>);      <span class="hljs-comment">//更新size</span><br>    ans=<span class="hljs-built_in">min</span>(ans,size);           <span class="hljs-comment">//更新全局答案</span><br>    <span class="hljs-keyword">return</span> sum<span class="hljs-number">+1</span>;              <br>&#125;<br><span class="hljs-comment">//所有点一定可以都被遍历到，因为这是联通图</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cin&gt;&gt;n;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n<span class="hljs-number">-1</span>;i++)<br>    &#123;<br>        <span class="hljs-type">int</span> a,b;<br>        cin&gt;&gt;a&gt;&gt;b;<br>        <span class="hljs-built_in">add</span>(a,b);<br>        <span class="hljs-built_in">add</span>(b,a);<br>    &#125;<br>    <span class="hljs-built_in">dfs</span>(<span class="hljs-number">1</span>);<br>    cout&lt;&lt;ans;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="图的bfs"><a href="#图的bfs" class="headerlink" title="图的bfs"></a>图的bfs</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;queue&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">int</span> n,m;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1e5</span><span class="hljs-number">+10</span>;<br><span class="hljs-type">int</span> d[N];<br>vector&lt;<span class="hljs-type">int</span>&gt; e[N];<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b)</span></span><br><span class="hljs-function"></span>&#123;<br>    e[a].<span class="hljs-built_in">push_back</span>(b);<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">bfs</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">memset</span>(d,<span class="hljs-number">-1</span>,<span class="hljs-keyword">sizeof</span> d);<br>    queue&lt;<span class="hljs-type">int</span>&gt; q;<br>    q.<span class="hljs-built_in">push</span>(<span class="hljs-number">1</span>);<br>    d[<span class="hljs-number">1</span>]=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(q.<span class="hljs-built_in">size</span>())<br>    &#123;<br>        <span class="hljs-type">int</span> t=q.<span class="hljs-built_in">front</span>();<br>        q.<span class="hljs-built_in">pop</span>();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> son:e[t])<br>        &#123;<br>            <span class="hljs-keyword">if</span>(d[son]!=<span class="hljs-number">-1</span>) <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                q.<span class="hljs-built_in">push</span>(son);<br>                d[son]=d[t]<span class="hljs-number">+1</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>   <br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cin&gt;&gt;n&gt;&gt;m;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;m;i++)<br>    &#123;<br>        <span class="hljs-type">int</span> a,b;<br>        cin&gt;&gt;a&gt;&gt;b;<br>        <span class="hljs-comment">//注意有向边还是无向边</span><br>        <span class="hljs-built_in">add</span>(a,b);<br>    &#125;<br>    <span class="hljs-built_in">bfs</span>();<br>    cout&lt;&lt;d[n];<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="拓扑序列"><a href="#拓扑序列" class="headerlink" title="拓扑序列"></a>拓扑序列</h1><p>给定一个n个点 m 条边的有向图，点的编号是 1 到 n, 图中可能存在重边和自环。<br>请输出任意一个该有向图的拓扑序列，如果拓扑序列不存在，则输出 一1。<br>若一个由图中所有点构成的序列$A$满足：对于图中的每条边$(x,y),x$在 A 中都出现在   $y$之前，则称 $A$ 是该图的<br>一个拓扑序列。</p><p>拓扑序列的主要思路是：关注入度的变化，一开始有入度为0的点直接入队，入队后更新他连接的子节点的入度，如果子节点的入度变为零则入队，直到队列变空<br>期间维护一个数组存储每次出队元素进入拓扑序列即可，最终cout出去。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;queue&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1e5</span><span class="hljs-number">+10</span>;<br>vector&lt;<span class="hljs-type">int</span>&gt; d[N]; <span class="hljs-comment">// 邻接表</span><br><span class="hljs-type">int</span> top[N],in[N],idx=<span class="hljs-number">-1</span>,n,m;<br><span class="hljs-comment">//top存序列，in存入度，idx维护拓扑序列指针</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b)</span></span><br><span class="hljs-function"></span>&#123;<br>    d[a].<span class="hljs-built_in">push_back</span>(b);<br>&#125;<br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">topsort</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    queue&lt;<span class="hljs-type">int</span>&gt; q;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)<br>    &#123;<br>        <span class="hljs-comment">//一开始有入度为0的点直接入队</span><br>        <span class="hljs-keyword">if</span>(!in[i]) q.<span class="hljs-built_in">push</span>(i);<br>    &#125;<br>    <span class="hljs-keyword">while</span>(q.<span class="hljs-built_in">size</span>())<br>    &#123;<br>        <span class="hljs-comment">//先删掉的点肯定是在拓扑序列前面的点，直接加入top</span><br>        <span class="hljs-type">int</span> t=q.<span class="hljs-built_in">front</span>();<br>        top[++idx]=t;<br>        q.<span class="hljs-built_in">pop</span>();<br>        <span class="hljs-comment">//分裂，更新他子节点的入度，判断每个子节点是否可以入队</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> son: d[t])<br>        &#123;<br>            in[son]--;<br>            <span class="hljs-keyword">if</span>(in[son]==<span class="hljs-number">0</span>) q.<span class="hljs-built_in">push</span>(son);<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">//判断所有点是否都用上，都用上说明这是一个拓扑序列</span><br>    <span class="hljs-keyword">return</span> n==(idx<span class="hljs-number">+1</span>);<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;m;i++)<br>    &#123;<br>        <span class="hljs-type">int</span> a,b; cin&gt;&gt;a&gt;&gt;b;<br>        <span class="hljs-built_in">add</span>(a,b);<br>        in[b]++;<br>    &#125;<br>    top[<span class="hljs-number">0</span>]=<span class="hljs-number">-1</span>;    <br>    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">topsort</span>()) <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;=idx;i++) cout&lt;&lt;top[i]&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>    <span class="hljs-keyword">else</span>  cout&lt;&lt;<span class="hljs-string">&quot;-1&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="dijkstra求最短路"><a href="#dijkstra求最短路" class="headerlink" title="dijkstra求最短路"></a>dijkstra求最短路</h1><h2 id="朴素版本"><a href="#朴素版本" class="headerlink" title="朴素版本"></a>朴素版本</h2><p>dijkstra适用于求所有边权都是正值的最短路，他基于贪心的基本思想。<br>简单来说，就是要维护这样的一个状态表格<br>$$\begin{array}{l|l|l|l|l|l|l|l}\text{步骤}&amp;\text{S}&amp;\text{v}2&amp;\text{v}3&amp;\text{v}4&amp;\text{v}5&amp;\text{v}6\\hdashline1&amp;\text{v}1&amp;10&amp;\infty&amp;\infty&amp;\infty&amp;3\\hline2&amp;\text{v}1—\text{v}6&amp;5&amp;\infty&amp;9&amp;4\\hdashline3&amp;\text{v}1—\text{v}6—\text{v}5&amp;\infty&amp;\infty&amp;\infty&amp;\end{array}$$</p><p>g[N][N]存图，dist[N]存当前每个节点临时认定的最短路，再用st[N]存每个节点是否已经确认了最短状态，若st[i]&#x3D;&#x3D;true,则dist[N]存的就是确定的最短路。<br>观察这个表，发现几条性质        </p><ul><li>S列中，后面的路一定是由前面的路继续走出来的，因此一旦一条路作为全表最小被断言为最短，那么他一定就永远是最短，不可能被后续的路更新得更短，因为后面的路都是前面的路发展而来的</li><li>全表最小值t一定是当前状态的最短路，因为他无法更新了，他想由别的状态更新而来，然而别的状态还没接着走就都已经比他大了，而其他的未定dist还有可能接着更新，因为他有可能由t发展而来</li></ul><p>为此我们的dist需要求每一列的最小值，也就是不断更新dist[j]&#x3D;min(dist[t]+g[t][j]),同时每次循环中吧st[t]&#x3D;true即可</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">510</span>;<br><span class="hljs-type">int</span> g[N][N],dist[N],m,n;<br><span class="hljs-type">bool</span> st[N];<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dijkstra</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">memset</span>(dist,<span class="hljs-number">0x3f</span>,<span class="hljs-keyword">sizeof</span> dist);<br>    dist[<span class="hljs-number">1</span>]=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)<br>    &#123;<br>        <span class="hljs-type">int</span> t=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=n;j++)<br>        &#123;<br>            <span class="hljs-comment">//在没确定是否是最短路的集合中找出最短的</span><br>            <span class="hljs-keyword">if</span>(!st[j]&amp;&amp;dist[j]&lt;dist[t])<br>            &#123;<br>                t=j;<br>            &#125;<br>        &#125;<br>        st[t]=<span class="hljs-literal">true</span>;<br>        <span class="hljs-comment">//不必判断，全部更新即可，事实上st[j]==true的点不会被更新</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=n;j++) dist[j]=<span class="hljs-built_in">min</span>(dist[j],dist[t]+g[t][j]);<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);<br>    <span class="hljs-built_in">memset</span>(g,<span class="hljs-number">0x3f</span>,<span class="hljs-keyword">sizeof</span> g);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;m;i++)<br>    &#123;<br>        <span class="hljs-type">int</span> a,b,c; <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d&quot;</span>,&amp;a,&amp;b,&amp;c);<br>        g[a][b]=<span class="hljs-built_in">min</span>(g[a][b],c);<br>    &#125;<br>    <span class="hljs-built_in">dijkstra</span>();<br>    <span class="hljs-comment">//这里是因为memset赋值是按字节赋值，把每个字节赋值为0x进制下的3f，为此dist作为int数组有4个字节，则应与0x3f3f3f3f比较大小</span><br>    <span class="hljs-keyword">if</span>(dist[n]&gt;=<span class="hljs-number">0x3f3f3f3f</span>) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;-1&quot;</span>);<br>    <span class="hljs-keyword">else</span> <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>,dist[n]);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="堆优化版本"><a href="#堆优化版本" class="headerlink" title="堆优化版本"></a>堆优化版本</h2><p>堆优化版本就是说，我们始终维护一个堆进行全局最小值的查询而非采用先前的遍历算法</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;queue&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">typedef</span> pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt; pii;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">151010</span>;<br>vector&lt;pii&gt; node[N];<br><span class="hljs-type">int</span> n,m,dist[N];<br><span class="hljs-type">bool</span> st[N];<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">addn</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b,<span class="hljs-type">int</span> c)</span></span><br><span class="hljs-function"></span>&#123;<br>    node[a].<span class="hljs-built_in">push_back</span>(&#123;b,c&#125;);<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dijkstra</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">memset</span>(dist,<span class="hljs-number">0x3f</span>,<span class="hljs-keyword">sizeof</span> dist);<br>    dist[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<br>    priority_queue&lt;pii,vector&lt;pii&gt;,greater&lt;pii&gt;&gt; heap;<br>    <span class="hljs-comment">//dist,node，因为按照pii的第一个元素进行排序</span><br>    heap.<span class="hljs-built_in">push</span>(&#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>&#125;);<br>    <br>    <span class="hljs-keyword">while</span>(heap.<span class="hljs-built_in">size</span>())<br>    &#123;<br>        <span class="hljs-keyword">auto</span> t = heap.<span class="hljs-built_in">top</span>();<br>        heap.<span class="hljs-built_in">pop</span>();<br>        <br>        <span class="hljs-type">int</span> j = t.second;<br>        <span class="hljs-type">int</span> d = t.first;<br>        <br>        <span class="hljs-keyword">if</span>(st[j]) <span class="hljs-keyword">continue</span>;<br>        <span class="hljs-comment">//懒惰删除</span><br>        st[j] = <span class="hljs-literal">true</span>;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> son :node[j])<br>        &#123;<br>            <span class="hljs-type">int</span> w = son.second;<br>            <span class="hljs-type">int</span> idx = son.first;<br>            <span class="hljs-keyword">if</span>(d+w&lt;dist[idx]) &#123;<br>                dist[idx] = d+w;<br>                <span class="hljs-comment">//有了新dist就把新dist入堆</span><br>                heap.<span class="hljs-built_in">push</span>(&#123;dist[idx],idx&#125;);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;m;i++)<br>    &#123;<br>        <span class="hljs-type">int</span> a,b,c;<br>        cin&gt;&gt;a&gt;&gt;b&gt;&gt;c;<br>        <span class="hljs-built_in">addn</span>(a,b,c);<br>    &#125;<br>    <span class="hljs-built_in">dijkstra</span>();<br>    <span class="hljs-keyword">if</span>(dist[n]&gt;=<span class="hljs-number">0x3f3f3f3f</span>) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;-1&quot;</span>);<br>    <span class="hljs-keyword">else</span> <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>,dist[n]);<br>&#125;<br></code></pre></td></tr></table></figure><p>优先队列（heap）中可能会有冗余元素</p><p>冗余元素的出现主要是因为：</p><ul><li>重复加入：在算法的执行过程中，同一个顶点可能会因为多条路径被多次加入优先队列。例如，如果存在多条从起点到某个顶点的路径，并且这些路径的长度不同，那么该顶点可能会在每次找到更短路径时被重新加入优先队列。</li><li>懒惰删除：Dijkstra 算法的这个实现并没有在更新某个顶点的距离后立即从优先队列中删除所有旧的、距离更大的该顶点元素。这是因为直接删除优先队列中的元素是复杂的（通常需要 O(log N) 的时间复杂度），而且不是必要的。算法通过 st 数组来标记已经处理过的顶点，当从优先队列中取出一个顶点时，首先检查它是否已经被处理过。如果已经被处理过，就直接跳过；否则，进行距离更新和相邻顶点的处理。</li></ul><p>时间复杂度由$O(nm)$变为$O(nlog(m))$,改动在于全表最小距离的查找方式，由遍历查找的$O(m)$-&gt;堆查找的$O(log(m))$</p><h1 id="bellman-ford算法"><a href="#bellman-ford算法" class="headerlink" title="bellman-ford算法"></a>bellman-ford算法</h1><p> Bellman - ford 算法是求含负权图的单源最短路径的一种算法。<br> 其原理为不断对所有边进行遍历，每次使用这条边{a-&gt;b,w}的信息和两个节点的dist看看能否更新dist[b]&#x3D;min(dist[b],dist[a]+w)<br> 当遍历到第k次的时候，对应的是找到了允许最多走k条边的情况下的所有路<br> 如何理解？在每一次遍历的时候，相当于状态向外扩张，若一个点已经被遍历到，则dist非无穷，会更新与他相连的0x3f的dist<br> 若一个点还没走到，那么他指向的下一个边也不会被更新<br> 因此，若在 n-1 次松弛后还能更新，则说明图中有负环，因此无法得出结果，否则就完成<br> bellman-ford算法存边权信息很随意，只要可以遍历所有的边即可，为了简单考虑结构体方法。           </p><p>时间复杂度$O(nm)$</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N =<span class="hljs-number">510</span>,M = <span class="hljs-number">10010</span>;<br><span class="hljs-type">int</span> n,m,k,dist[N],last[N];<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Edge</span>&#123;<br>    <span class="hljs-type">int</span> a;<br>    <span class="hljs-type">int</span> b;<br>    <span class="hljs-type">int</span> w;<br>&#125; edge[M];<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">bellman_ford</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">memset</span>(dist,<span class="hljs-number">0x3f</span>,<span class="hljs-keyword">sizeof</span> dist);<br>    dist[<span class="hljs-number">1</span>]=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;k;i++)<br>    &#123;<br>        <span class="hljs-comment">//必须有copy这一步，因为走k条边的dist是由走k-1条边的状态更新过来的，不copy会导致“串联”</span><br>        <span class="hljs-built_in">memcpy</span>(last,dist,<span class="hljs-keyword">sizeof</span> dist);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;m;j++)<br>        &#123;<br>            <span class="hljs-type">int</span> a = edge[j].a;<br>            <span class="hljs-type">int</span> b = edge[j].b;<br>            <span class="hljs-type">int</span> w = edge[j].w;<br>            dist[b]=<span class="hljs-built_in">min</span>(dist[b],last[a]+w);<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d&quot;</span>,&amp;n,&amp;m,&amp;k);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;m;i++)<br>    &#123;<br>        <span class="hljs-type">int</span> a,b,w;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d&quot;</span>,&amp;a,&amp;b,&amp;w);<br>        edge[i].a=a;<br>        edge[i].b=b;<br>        edge[i].w=w†;<br>    &#125;<br>    <span class="hljs-built_in">bellman_ford</span>();<br>    <span class="hljs-comment">//这是考虑到负权边的存在，为此取了一个大的比较合适的数作为判断边界</span><br>    <span class="hljs-keyword">if</span>(dist[n]&gt;<span class="hljs-number">0x3f3f3f3f</span> / <span class="hljs-number">2</span>) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;impossible&quot;</span>);<br>    <span class="hljs-keyword">else</span> <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>,dist[n]);<br>    <br>&#125;<br></code></pre></td></tr></table></figure><p>bellman-ford算法绝大部分情况下时间复杂度高于SPFA，在需要限制最多走k条边的情况下才必须使用SPFA算法</p><h1 id="SPFA算法-队列优化的Bellman-Ford算法"><a href="#SPFA算法-队列优化的Bellman-Ford算法" class="headerlink" title="SPFA算法(队列优化的Bellman-Ford算法)"></a>SPFA算法(队列优化的Bellman-Ford算法)</h1><p>我们发现一件事，一个被更新的节点才有可能更新他的子节点，因此没必要每次遍历所有边，只需要维护一个队列，队列里记录刚被更新过的点即可</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;queue&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1e5</span><span class="hljs-number">+10</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> M = <span class="hljs-number">1e5</span><span class="hljs-number">+10</span>;<br><span class="hljs-keyword">typedef</span> pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt; pii;<br>vector&lt;pii&gt; adj[N];<br><span class="hljs-type">int</span> dist[N];<br><span class="hljs-type">bool</span> st[N];<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b,<span class="hljs-type">int</span> c)</span></span><br><span class="hljs-function"></span>&#123;<br>    adj[a].<span class="hljs-built_in">push_back</span>(&#123;b,c&#125;);<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">spfa</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">memset</span>(dist,<span class="hljs-number">0x3f</span>,<span class="hljs-keyword">sizeof</span> dist);<br>    dist[<span class="hljs-number">1</span>]=<span class="hljs-number">0</span>;<br>    queue&lt;<span class="hljs-type">int</span>&gt; q;<br>    q.<span class="hljs-built_in">push</span>(<span class="hljs-number">1</span>);<br>    st[<span class="hljs-number">1</span>]=<span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">while</span>(q.<span class="hljs-built_in">size</span>())<br>    &#123;<br>        <span class="hljs-type">int</span> t = q.<span class="hljs-built_in">front</span>();<br>        q.<span class="hljs-built_in">pop</span>();<br>        st[t]=<span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> edge : adj[t])<br>        &#123;<br>            <span class="hljs-type">int</span> j = edge.first;<br>            <span class="hljs-type">int</span> w = edge.second;<br>            <span class="hljs-keyword">if</span>(dist[t]+w&lt;dist[j])<br>            &#123;<br>                <span class="hljs-keyword">if</span>(!st[j]) q.<span class="hljs-built_in">push</span>(j);<br>                dist[j]=dist[t]+w;<br>                st[j]=<span class="hljs-literal">true</span>; <span class="hljs-comment">//不加也可以过</span><br>            &#125;<br>                <br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n,m; <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;m;i++)<br>    &#123;<br>        <span class="hljs-type">int</span> a,b,c; <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d&quot;</span>,&amp;a,&amp;b,&amp;c);<br>        <span class="hljs-built_in">add</span>(a,b,c);<br>    &#125;<br>    <span class="hljs-built_in">spfa</span>();<br>    <span class="hljs-keyword">if</span>(dist[n]&gt;<span class="hljs-number">0x3f3f3f3f</span>/<span class="hljs-number">2</span>) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;impossible&quot;</span>);   <span class="hljs-comment">//图不联通</span><br>    <span class="hljs-keyword">else</span> <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>,dist[n]);<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="SPFA判断负环"><a href="#SPFA判断负环" class="headerlink" title="SPFA判断负环"></a>SPFA判断负环</h1><ul><li>1，判断有无负环：有负环则会陷入负环无限循环，维护一个对应的cnt（某个点在路径中出现的次数），当远大于n说明陷入了无限循环</li><li>2，由于图未必联通，因此要注意我们不是判断1所在的独立图是否有负环，而是全体是否有负环，为此一开始将所有点入队</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;queue&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1e5</span><span class="hljs-number">+10</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> M = <span class="hljs-number">1e5</span><span class="hljs-number">+10</span>;<br><span class="hljs-keyword">typedef</span> pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt; pii;<br>vector&lt;pii&gt; adj[N];<br><span class="hljs-type">int</span> dist[N],cnt[N],n,m;<br><span class="hljs-type">bool</span> st[N];<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b,<span class="hljs-type">int</span> c)</span></span><br><span class="hljs-function"></span>&#123;<br>    adj[a].<span class="hljs-built_in">push_back</span>(&#123;b,c&#125;);<br>&#125;<br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">spfa</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">memset</span>(dist,<span class="hljs-number">0x3f</span>,<span class="hljs-keyword">sizeof</span> dist);<br>    dist[<span class="hljs-number">1</span>]=<span class="hljs-number">0</span>;<br>    queue&lt;<span class="hljs-type">int</span>&gt; q;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++) <br>    &#123;<br>        q.<span class="hljs-built_in">push</span>(i);<br>        st[i]=<span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">while</span>(q.<span class="hljs-built_in">size</span>())<br>    &#123;<br>        <span class="hljs-type">int</span> t = q.<span class="hljs-built_in">front</span>();<br>        q.<span class="hljs-built_in">pop</span>();<br>        st[t]=<span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> edge : adj[t])<br>        &#123;<br>            <span class="hljs-type">int</span> j = edge.first;<br>            <span class="hljs-type">int</span> w = edge.second;<br>            <span class="hljs-keyword">if</span>(dist[t]+w&lt;dist[j])<br>            &#123;<br>                <span class="hljs-keyword">if</span>(!st[j]) q.<span class="hljs-built_in">push</span>(j);<br>                dist[j]=dist[t]+w;<br>                cnt[j]++;<br>                <span class="hljs-keyword">if</span>(cnt[j]&gt;=n<span class="hljs-number">+2</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>                <br>            &#125;<br>                <br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;m;i++)<br>    &#123;<br>        <span class="hljs-type">int</span> a,b,c; <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d&quot;</span>,&amp;a,&amp;b,&amp;c);<br>        <span class="hljs-built_in">add</span>(a,b,c);<br>    &#125;<br>    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">spfa</span>()) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Yes&quot;</span>);<br>    <span class="hljs-keyword">else</span> <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;No&quot;</span>);<br>    <br>&#125;<br></code></pre></td></tr></table></figure><h1 id="floyd算法"><a href="#floyd算法" class="headerlink" title="floyd算法"></a>floyd算法</h1><p>floyd算法基于动态规划，定义d(k,i,j)为只经过前k个点的前提下，i到j的最小路。<br>状态更新方程为 d(k,i,j)&#x3D;min(d(k-1,i,k)+d(k-1,k,j))<br>第一维可以省去</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">210</span>;<br><span class="hljs-type">int</span> dist[N][N],n,m,k;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">floyd</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=<span class="hljs-number">1</span>;k&lt;=n;k++)<br>    &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)<br>        &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=n;j++)<br>            dist[i][j]=<span class="hljs-built_in">min</span>(dist[i][j],dist[i][k]+dist[k][j]);<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">memset</span>(dist,<span class="hljs-number">0x3f</span>,<span class="hljs-keyword">sizeof</span> dist);<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d&quot;</span>,&amp;n,&amp;m,&amp;k);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;m;i++)<br>    &#123;<br>        <span class="hljs-type">int</span> a,b,c; <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d&quot;</span>,&amp;a,&amp;b,&amp;c);<br>        dist[a][b]=<span class="hljs-built_in">min</span>(dist[a][b],c);<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)<br>    &#123;<br>        dist[i][i]=<span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-built_in">floyd</span>();<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;k;i++)<br>    &#123;<br>        <span class="hljs-type">int</span> x,y; cin&gt;&gt;x&gt;&gt;y;<br>        <span class="hljs-keyword">if</span>(dist[x][y]&gt;<span class="hljs-number">0x3f3f3f3f</span>/<span class="hljs-number">2</span>) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;impossible\n&quot;</span>);<br>        <span class="hljs-keyword">else</span> <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,dist[x][y]);<br>    &#125;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><h1 id="prim求最小生成树"><a href="#prim求最小生成树" class="headerlink" title="prim求最小生成树"></a>prim求最小生成树</h1><ul><li>最小生成树指的是用上全部顶点和适当的边使得这一图形构成一个树，求使得边权重和最小的树</li><li>思路和dijkstra类似，基本思路也是对外扩充，d[i]维护的是点i距离当前的树(集合)最小的距离，每次向外扩展树选取距离最近的点加进来，重复n次直到所有点都进来或者中间发现无法把所有点都加进来。期间用st[N]记录哪些点已经加进了生成树</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">510</span>;<br><span class="hljs-type">int</span> g[N][N],d[N],st[N],n,m,res=<span class="hljs-number">0</span>;<br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">prim</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">memset</span>(d,<span class="hljs-number">0x3f</span>,<span class="hljs-keyword">sizeof</span> d);<br>    d[<span class="hljs-number">1</span>]=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)<br>    &#123;<br>        <span class="hljs-type">int</span> t=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=n;j++)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(!st[j]&amp;&amp;d[j]&lt;d[t]) t=j;<br>        &#125;<br>        st[t] = <span class="hljs-literal">true</span>;<br>        res += d[t];<br>        <span class="hljs-keyword">if</span>(d[t]==<span class="hljs-number">0x3f3f3f3f</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=n;j++)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(!st[j]) d[j]=<span class="hljs-built_in">min</span>(d[j],g[t][j]);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">memset</span>(g,<span class="hljs-number">0x3f</span>,<span class="hljs-keyword">sizeof</span> g);<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;m;i++)<br>    &#123;<br>        <span class="hljs-type">int</span> a,b,c;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d&quot;</span>,&amp;a,&amp;b,&amp;c);<br>        g[a][b]=<span class="hljs-built_in">min</span>(g[a][b],c);<br>        g[b][a]=g[a][b];<br>    &#125;<br>    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">prim</span>()) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;impossible&quot;</span>);<br>    <span class="hljs-keyword">else</span> <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>,res);<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="kruskal求最小生成树"><a href="#kruskal求最小生成树" class="headerlink" title="kruskal求最小生成树"></a>kruskal求最小生成树</h1><ul><li><p>将所有边按照权值的大小进行升序排序，然后从小到大一一判断。</p></li><li><p>如果这个边与之前选择的所有边不会组成回路，就选择这条边（并查集检查祖宗，应当不一样才可选择）；反之，舍去。</p></li><li><p>直到具有 n 个顶点的连通网筛选出来 n-1 条边为止。</p></li><li><p>筛选出来的边和所有的顶点构成此连通网的最小生成树。</p></li></ul><p>此方法可以用数学归纳法证明：任何时候 Kruskal 算法选择的边集都被 MST 所包含：</p><h3 id="奠基："><a href="#奠基：" class="headerlink" title="奠基："></a>奠基：</h3><p>选择的第一条边必然属于MST，也就是证明最短的边一定属于MST，证明如下：倘若两点之间最短的边不属于MST，那么连接这两点，必然在MST中构成一个环，断开这个环上任意一条边都可使得MST更小，这不符合MST最优的性质，因此只能是选择的第一条边一定属于MST</p><h3 id="归纳"><a href="#归纳" class="headerlink" title="归纳"></a>归纳</h3><p>如果选择的前k条边都属于MST，则下面遍历过程中被抛弃的边一定不属于MST，被选择的那条边一定就是MST里面的边</p><ul><li>先证明遍历过程中被抛弃的边一定不属于MST：抛弃的边都是加入后会成环的边，由于我们由小到大的遍历顺序，成的这个环上边权最大的就是刚加进来的那条边，他不可能替代掉先前的任何一条边，为此此边可以抛弃</li><li>再证明被选择的边就是MST里面的边，这是因为他是第一个出现的不成环的边，后面出现的不成环的边一定比他权大，因此就选择这条边</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1e5</span><span class="hljs-number">+10</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> M = <span class="hljs-number">2e5</span><span class="hljs-number">+10</span>;<br><span class="hljs-type">int</span> n,m,p[N],res=<span class="hljs-number">0</span>,cnt=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Edge</span>&#123;<br>    <span class="hljs-type">int</span> a,b,c;<br>    <br>&#125; edge[M];<br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(<span class="hljs-type">const</span> Edge&amp; e1,<span class="hljs-type">const</span> Edge&amp; e2)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span>(e<span class="hljs-number">1.</span>c&lt;e<span class="hljs-number">2.</span>c);<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(p[x]!=x) p[x]=<span class="hljs-built_in">find</span>(p[x]);<br>    <span class="hljs-keyword">return</span> p[x];<br>&#125;<br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">kruskal</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++) p[i]=i;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;m;i++)<br>    &#123;<br>        <span class="hljs-type">int</span> a = edge[i].a, b = edge[i].b,c = edge[i].c;<br>        <span class="hljs-type">int</span> pa = <span class="hljs-built_in">find</span>(a);<span class="hljs-type">int</span> pb = <span class="hljs-built_in">find</span>(b);<br>        <span class="hljs-keyword">if</span> (pa != pb)<br>        &#123;<br>            p[pa] = pb;<br>            res += c;<br>            cnt ++ ;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(cnt&lt;n<span class="hljs-number">-1</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i ++ )<br>    &#123;<br>        <span class="hljs-type">int</span> a, b, w;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d&quot;</span>, &amp;a, &amp;b, &amp;w);<br>        edge[i] = &#123;a, b, w&#125;;<br>    &#125;<br>    <span class="hljs-built_in">sort</span>(edge,edge+m,cmp);<br>    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">kruskal</span>()) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>,res);<br>    <span class="hljs-keyword">else</span> <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;impossible&quot;</span>);<br>    <br>&#125;<br></code></pre></td></tr></table></figure><h1 id="染色法判断二分图"><a href="#染色法判断二分图" class="headerlink" title="染色法判断二分图"></a>染色法判断二分图</h1><p>这个题的图包含连通图和非连通图两种情况，若是连通图便不需要主函数里的for循环了，但是这里只需处理非联通图即可，主函数使用for循环枚举所有图，就把两种情况都包含进去了</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">int</span> n,m;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1e5</span><span class="hljs-number">+10</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> M = <span class="hljs-number">1e5</span><span class="hljs-number">+10</span>;<br><span class="hljs-type">int</span> color[N];<br>vector&lt;<span class="hljs-type">int</span>&gt; edge[N];<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b)</span></span><br><span class="hljs-function"></span>&#123;<br>    edge[a].<span class="hljs-built_in">push_back</span>(b);<br>    edge[b].<span class="hljs-built_in">push_back</span>(a);<br>&#125;<br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> c)</span></span><br><span class="hljs-function"></span>&#123;<br>    color[x]=c;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> t: edge[x])<br>    &#123;<br>        <span class="hljs-keyword">if</span>(!color[t])<br>        &#123;<br>            <span class="hljs-keyword">if</span>(!<span class="hljs-built_in">dfs</span>(t,<span class="hljs-number">3</span>-c)) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(color[t]==c) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    <br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;m;i++)<br>    &#123;<br>        <span class="hljs-type">int</span> u,v;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;u,&amp;v);<br>        <span class="hljs-built_in">add</span>(u,v);<br>    &#125;<br>    <span class="hljs-type">bool</span> flag=<span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(!color[i])<br>        &#123;<br>            <span class="hljs-keyword">if</span>(!<span class="hljs-built_in">dfs</span>(i,<span class="hljs-number">1</span>))<br>            &#123;<br>                flag=<span class="hljs-literal">false</span>;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(flag) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Yes&quot;</span>);<br>    <span class="hljs-keyword">else</span> <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;No&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="最短路的总结"><a href="#最短路的总结" class="headerlink" title="最短路的总结"></a>最短路的总结</h1><p><a href="https://imgse.com/i/pAhQ8Dx"><img src="https://s21.ax1x.com/2024/11/25/pAhQ8Dx.md.png" alt="pAhQ8Dx.md.png"></a></p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法竞赛</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>算法竞赛集训笔记（一）stl</title>
    <link href="/2025/03/21/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B%E9%9B%86%E8%AE%AD%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <url>/2025/03/21/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B%E9%9B%86%E8%AE%AD%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="算法竞赛集训笔记（一）-c-stl"><a href="#算法竞赛集训笔记（一）-c-stl" class="headerlink" title="算法竞赛集训笔记（一） c++stl"></a>算法竞赛集训笔记（一） c++stl</h1><h2 id="基础内容，从hello-world谈起"><a href="#基础内容，从hello-world谈起" class="headerlink" title="基础内容，从hello world谈起"></a>基础内容，从hello world谈起</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cout&lt;&lt;<span class="hljs-string">&quot;hello world!&quot;</span>&lt;&lt;endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>c语言的头文件在c++全部可以使用，但是要把.h后缀去掉，在前面加上c     </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;manth.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cmath&gt;</span></span><br></code></pre></td></tr></table></figure><p>c++中，所有标准库前面的东西都要加std::,为此我们写下using namespace std，但是起名时容易和库函数冲突，比如（prev,next,sort,count不可以再用了），避免冲突，改写一下常见变量名</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++">count -&gt;cnt<br>next  -&gt;nxt<br>prev  -&gt;prv<br></code></pre></td></tr></table></figure><p>另外，将endl替换为”\n”,最后换行效果是一样的，但是endl可以清空缓存区，使用c++写代码尽量使用endl即可</p><p>c++中一些新的数据类型<br>bool string 这些是包含在<iostream>中的</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">bool</span> flag1=<span class="hljs-literal">true</span>;<br><span class="hljs-type">bool</span> flag2=<span class="hljs-number">1</span>;<br>cout&lt;&lt;flag;    <span class="hljs-comment">// 1</span><br><br><span class="hljs-type">char</span>* str=<span class="hljs-string">&quot;hello&quot;</span>;<br>string str=<span class="hljs-string">&quot;hello&quot;</span><br>cout&lt;&lt;str;   <span class="hljs-comment">//hello</span><br></code></pre></td></tr></table></figure><p>c++输入</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++">cin&gt;&gt;number <span class="hljs-comment">//scanf(&quot;%d&quot;,&amp;number)</span><br>cin&gt;&gt;str    <span class="hljs-comment">//scanf(&quot;%s&quot;,str)</span><br>cin.<span class="hljs-built_in">getline</span>(str,<span class="hljs-number">1000</span>) <br><span class="hljs-comment">//scanf(&quot;%s&quot;,str) 这里的str必须用 </span><br><span class="hljs-comment">//char str[100]声明，</span><br><span class="hljs-comment">//而不可以 string str或者char*str</span><br><span class="hljs-built_in">getline</span>(cin,str) <span class="hljs-comment">//这里的str则必须是string类型的</span><br></code></pre></td></tr></table></figure><p>cin判断EOF</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">while</span>(cin&gt;&gt;a)<br>&#123;<br>    <span class="hljs-comment">//代码主题</span><br>&#125;<br></code></pre></td></tr></table></figure><p>与c语言比较，cin比sacnf慢不少，而且输入小数用printf更方便。总体来说，用printf和scanf在速度上更有保证，有效避免TLE。</p><h2 id="c-语法特性"><a href="#c-语法特性" class="headerlink" title="c++语法特性"></a>c++语法特性</h2><h3 id="动态开辟内存"><a href="#动态开辟内存" class="headerlink" title="动态开辟内存"></a>动态开辟内存</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span>* number =<span class="hljs-keyword">new</span> <span class="hljs-type">int</span>;<br><span class="hljs-type">int</span>* arr=<span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[<span class="hljs-number">100</span>];<br><span class="hljs-type">int</span> *carr=(<span class="hljs-type">int</span>*)<span class="hljs-built_in">malloc</span>(<span class="hljs-number">100</span>*<span class="hljs-built_in">sizeof</span>(<span class="hljs-type">int</span>));<br></code></pre></td></tr></table></figure><h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><p>理解为没有*的指针,用于简化代码，避免了解引用的过程。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(<span class="hljs-type">int</span>&amp; a,<span class="hljs-type">int</span>&amp; b)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> c=a;<br>    a=b;<br>    b=c;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="函数重载"><a href="#函数重载" class="headerlink" title="函数重载"></a>函数重载</h3><p>c++中。函数是以函数名＋参数列表来区分的，两个函数可以名字相同，但是参数列表和返回值不同，函数部分参数可以省略，没有提供参数时用缺省值代替</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> a+b;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> a;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">minus</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b=<span class="hljs-number">0</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> a-b;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">add</span>(<span class="hljs-number">0</span>);<br>    <span class="hljs-built_in">add</span>(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>);<br>    <span class="hljs-built_in">minus</span>(<span class="hljs-number">0</span>)  <span class="hljs-comment">//默认b=0;</span><br><br>&#125;<br></code></pre></td></tr></table></figure><p>算法竞赛中常用默认参数这一特性</p><h3 id="struct特性-项目用"><a href="#struct特性-项目用" class="headerlink" title="struct特性(项目用)"></a>struct特性(项目用)</h3><p>构造函数，初始化函数。</p><h2 id="c-标准库（重点）"><a href="#c-标准库（重点）" class="headerlink" title="c++标准库（重点）"></a>c++标准库（重点）</h2><p>今日重点</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">&lt;vector&gt; &lt;string&gt; &lt;algorithm&gt;<br></code></pre></td></tr></table></figure><p>以后还会见到</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++">&lt;queue&gt; &lt;stack&gt; &lt;set&gt; &lt;map&gt;<br>&lt;bitset&gt; &lt;functional&gt; &lt;complex&gt;<br></code></pre></td></tr></table></figure><h3 id="c标准库常用函数回顾"><a href="#c标准库常用函数回顾" class="headerlink" title="c标准库常用函数回顾"></a>c标准库常用函数回顾</h3><p><code>&lt;cstring&gt;</code>   </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">strlen</span>(str)<span class="hljs-comment">//字符串长度</span><br><span class="hljs-built_in">strcmp</span> (str1,str2) <span class="hljs-comment">//字符串比较</span><br><span class="hljs-built_in">strcpy</span> (str1,str2) <span class="hljs-comment">//字符串拷贝str2 到str1中</span><br><span class="hljs-built_in">memset</span>(a,<span class="hljs-number">0</span>,<span class="hljs-built_in">sizeof</span>(a)) <span class="hljs-comment">//暴力清空</span><br></code></pre></td></tr></table></figure><p><code>&lt;cstdlib.h&gt;</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">qsort</span>() <span class="hljs-comment">//快排</span><br><span class="hljs-built_in">rand</span>()<span class="hljs-comment">//随机数</span><br><span class="hljs-built_in">malloc</span>() <span class="hljs-built_in">free</span>() <span class="hljs-comment">//动态内存分配</span><br></code></pre></td></tr></table></figure><p><code>&lt;ctime&gt;</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c">time(<span class="hljs-number">0</span>) <span class="hljs-number">1970</span>到现在的秒数<br>clock() 程旭启动到目前的毫米数<br></code></pre></td></tr></table></figure><h3 id="vector"><a href="#vector" class="headerlink" title="vector"></a>vector</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    vector&lt;<span class="hljs-type">int</span>&gt; arr[<span class="hljs-number">100</span>];<br>    vector&lt;<span class="hljs-type">int</span>&gt; list;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">100</span>;i++)<br>    &#123;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;arr[i]);<br>        cout&lt;&lt;arr[i]&lt;&lt;endl;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">100</span>;i++)<br>    &#123;<br>        <span class="hljs-type">int</span> a=<span class="hljs-number">0</span>;<br>        cin&gt;&gt; a;<br>        list.<span class="hljs-built_in">push_back</span>(a);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>,list[i]);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们一般把vector当做链表看待使用，也就是第二种方式，这可以方便的处理不定长数组。<br>STL中的指针被称为迭代器</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">arr1</span><span class="hljs-params">(<span class="hljs-number">100</span>)</span></span>;<br><span class="hljs-type">int</span> arr2[<span class="hljs-number">100</span>];<br>vector&lt;<span class="hljs-type">int</span>&gt;::iterator p1;<br><span class="hljs-type">int</span> *p2;<br><br></code></pre></td></tr></table></figure><p>常见操作</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++">list.<span class="hljs-built_in">size</span>();<span class="hljs-comment">//数组元素个数   O(1)</span><br>list.<span class="hljs-built_in">clear</span>();<span class="hljs-comment">//一键清空数组 O(n)</span><br>list.<span class="hljs-built_in">empty</span>();<span class="hljs-comment">// 数组是否为空 O(1)</span><br>list.<span class="hljs-built_in">begin</span>()； <span class="hljs-comment">//首元素迭代器</span><br>list.<span class="hljs-built_in">end</span>()；<span class="hljs-comment">//最后一个元素的下一个元素的迭代器（此元素在数组中不存在）</span><br>list.<span class="hljs-built_in">erase</span>(p1) <span class="hljs-comment">//删除某个迭代器所在位置的元素 O(n) 这和实际的链表有区别，链表应该是O(1)</span><br>list.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">1</span>)  <span class="hljs-comment">//在数组最后添加元素  O(1);</span><br>list.<span class="hljs-built_in">pop_back</span>(<span class="hljs-number">1</span>) <span class="hljs-comment">//删除数组最后一个元素  O(1);</span><br></code></pre></td></tr></table></figure><h3 id="string"><a href="#string" class="headerlink" title="string"></a>string</h3><p> 字符串string可以看成一个特殊的vector</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++">string str=<span class="hljs-string">&quot;hello&quot;</span>;<br>str.<span class="hljs-built_in">size</span>();   <span class="hljs-comment">//O（n） 但是vector O(1)</span><br>str.<span class="hljs-built_in">insert</span>(<span class="hljs-number">1</span>,<span class="hljs-string">&quot;aaa&quot;</span>); <span class="hljs-comment">//下标为1处插入一个字符或字符串</span><br><span class="hljs-comment">// 1也可以更换为某一个迭代器</span><br>str.<span class="hljs-built_in">c_str</span>() <span class="hljs-comment">//返回一个c语言字符串 用于printf()</span><br>str.<span class="hljs-built_in">append</span>(str2); <span class="hljs-comment">//str2拼接到str后面</span><br>str ==str2;<br>str+=str2;<br>str+=<span class="hljs-string">&#x27;a&#x27;</span>;   <span class="hljs-comment">//拼接</span><br></code></pre></td></tr></table></figure><h3 id="algorithm算法函数"><a href="#algorithm算法函数" class="headerlink" title="algorithm算法函数"></a>algorithm算法函数</h3><h4 id="sort快排"><a href="#sort快排" class="headerlink" title="sort快排"></a>sort快排</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> arr[] &#123;<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">1</span>,<span class="hljs-number">5</span>,<span class="hljs-number">4</span>&#125;;<br><span class="hljs-type">int</span> n=<span class="hljs-number">5</span>;<br><span class="hljs-built_in">sort</span>(arr,arr<span class="hljs-number">+5</span>);<span class="hljs-comment">//sort(开始元素指针，最后一个元素的下一个元素的指针) 复杂度O(nlogn),升序排序</span><br><br><br><br><span class="hljs-comment">//若vector？</span><br>vector&lt;<span class="hljs-type">int</span>&gt; arr <span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">1</span>,<span class="hljs-number">5</span>,<span class="hljs-number">4</span><br><span class="hljs-built_in">sort</span>(arr.<span class="hljs-built_in">begin</span>(),arr.<span class="hljs-built_in">end</span>());<br></code></pre></td></tr></table></figure><p>关键的点是必要时要写好比较函数cmp。下面给出一个比较函数坐标的例子</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Point</span><br>&#123;<br>    <span class="hljs-type">int</span> x,y;<br>&#125;<br>Point points[<span class="hljs-number">1110</span>];<br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(Point a,Point b)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(a.x!=b.x)<br>    &#123;<br>        <span class="hljs-keyword">return</span> a.x&lt;b.x;<br>    &#125;<br>    <span class="hljs-keyword">return</span> a.y&lt;b.y;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">sort</span>(points,points<span class="hljs-number">+10</span>,cmp);<br>&#125;<br></code></pre></td></tr></table></figure><p>min。max也是函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">nth_element</span>(arr.<span class="hljs-built_in">begin</span>(),arr.<span class="hljs-built_in">begin</span>()<span class="hljs-number">+2</span>,arr.<span class="hljs-built_in">end</span>());<br><span class="hljs-comment">//第三号元素站在了应有的位置，左边都是比他小的，右边都是比他大的，左右未必排好序</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>题目总结</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法竞赛</tag>
      
      <tag>c++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>算法竞赛集训笔记（二）</title>
    <link href="/2025/03/21/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B%E9%9B%86%E8%AE%AD%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <url>/2025/03/21/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B%E9%9B%86%E8%AE%AD%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h2 id="高精度算法模版（自拟自用）-int-2147483648～2147483647"><a href="#高精度算法模版（自拟自用）-int-2147483648～2147483647" class="headerlink" title="高精度算法模版（自拟自用） int   -2147483648～2147483647"></a>高精度算法模版（自拟自用） int   -2147483648～2147483647</h2><p>加法，其实就是模拟竖式计算，但是cin的数其高位在数组小脚标位置，我们做加法应该从自然数低位开始加法，因此在string转换为int数组（也可以vector）时倒序填入，然后用一个新数组存放两个数组相加得到的结果，最后倒序输出这个新数组即可。。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>string s1,s2;<br>cin&gt;&gt;s1&gt;&gt;s2;<br><span class="hljs-type">int</span> i,j=<span class="hljs-number">0</span>,k=<span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> a[<span class="hljs-number">510</span>];<span class="hljs-type">int</span> b[<span class="hljs-number">510</span>];<br><span class="hljs-built_in">memset</span>(a,<span class="hljs-number">0</span>,<span class="hljs-built_in">sizeof</span>(a));<br><span class="hljs-built_in">memset</span>(b,<span class="hljs-number">0</span>,<span class="hljs-built_in">sizeof</span>(b));<br><span class="hljs-type">int</span> maxn=<span class="hljs-built_in">max</span>(s<span class="hljs-number">1.</span><span class="hljs-built_in">size</span>(),s<span class="hljs-number">2.</span><span class="hljs-built_in">size</span>());<br><span class="hljs-keyword">for</span>(i=s<span class="hljs-number">1.</span><span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;i&gt;=<span class="hljs-number">0</span>;i--) a[j++]=s1[i]-<span class="hljs-string">&#x27;0&#x27;</span>;<br><span class="hljs-keyword">for</span>(i=s<span class="hljs-number">2.</span><span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;i&gt;=<span class="hljs-number">0</span>;i--) b[k++]=s2[i]-<span class="hljs-string">&#x27;0&#x27;</span>;<span class="hljs-comment">//赋值出整数数组</span><br><span class="hljs-comment">//模拟竖式加法</span><br><span class="hljs-type">int</span> c[<span class="hljs-number">511</span>];<br><span class="hljs-type">int</span> t=<span class="hljs-number">0</span>;<span class="hljs-comment">//存储上一位进位数;</span><br><span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;maxn;i++)<br>&#123;<br>c[i]=(a[i]+b[i]+t)%<span class="hljs-number">10</span>;<br>t=(a[i]+b[i]+t)/<span class="hljs-number">10</span>; <br>&#125;<br><span class="hljs-keyword">if</span>(t) <br>&#123;<br>c[i]=t;<br><span class="hljs-keyword">for</span>(i=maxn;i&gt;=<span class="hljs-number">0</span>;i--) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>,c[i]);<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br><span class="hljs-keyword">for</span>(i=maxn<span class="hljs-number">-1</span>;i&gt;=<span class="hljs-number">0</span>;i--) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>,c[i]);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>高精度乘法<br>一定要特判0的情况，初次提交在这里寄了一个点。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>string s1,s2;<br>cin&gt;&gt;s1&gt;&gt;s2;<br><span class="hljs-type">int</span> i,j=<span class="hljs-number">0</span>,k=<span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> a[<span class="hljs-number">2001</span>];<span class="hljs-type">int</span> b[<span class="hljs-number">2001</span>];<br><span class="hljs-built_in">memset</span>(a,<span class="hljs-number">0</span>,<span class="hljs-built_in">sizeof</span>(a));<br><span class="hljs-built_in">memset</span>(b,<span class="hljs-number">0</span>,<span class="hljs-built_in">sizeof</span>(b));<br><span class="hljs-keyword">for</span>(i=s<span class="hljs-number">1.</span><span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;i&gt;=<span class="hljs-number">0</span>;i--) a[j++]=s1[i]-<span class="hljs-string">&#x27;0&#x27;</span>;<br><span class="hljs-keyword">for</span>(i=s<span class="hljs-number">2.</span><span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;i&gt;=<span class="hljs-number">0</span>;i--) b[k++]=s2[i]-<span class="hljs-string">&#x27;0&#x27;</span>;<span class="hljs-comment">//赋值出整数数组</span><br><span class="hljs-comment">//模拟竖式乘法 </span><br><span class="hljs-type">int</span> c[<span class="hljs-number">5000</span>];<br><span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;s<span class="hljs-number">1.</span><span class="hljs-built_in">size</span>();i++)  <br>&#123;<br><span class="hljs-keyword">for</span>(j=<span class="hljs-number">0</span>;j&lt;s<span class="hljs-number">2.</span><span class="hljs-built_in">size</span>();j++)<br>&#123;<br>c[i+j]+=a[i]*b[j];<br>&#125;<br>&#125;<br><span class="hljs-type">int</span> t=<span class="hljs-number">0</span>;<span class="hljs-comment">//表示上一位进位 </span><br><span class="hljs-keyword">if</span>(s<span class="hljs-number">1.</span><span class="hljs-built_in">size</span>()==<span class="hljs-number">1</span>&amp;&amp;a[<span class="hljs-number">0</span>]==<span class="hljs-number">0</span>||s<span class="hljs-number">2.</span><span class="hljs-built_in">size</span>()==<span class="hljs-number">1</span>&amp;&amp;b[<span class="hljs-number">0</span>]==<span class="hljs-number">0</span>) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;0&quot;</span>);<br><span class="hljs-keyword">else</span><br>&#123;<br><span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;s<span class="hljs-number">1.</span><span class="hljs-built_in">size</span>()+s<span class="hljs-number">2.</span><span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;i++)<br>&#123;<br><span class="hljs-type">int</span> pc=c[i];<br>c[i]=(c[i]+t)%<span class="hljs-number">10</span>;<br>t=(pc+t)/<span class="hljs-number">10</span>; <br>&#125;<br><span class="hljs-keyword">if</span>(t)<br>&#123;<br>c[i]=t;<br><span class="hljs-keyword">for</span>(i=s<span class="hljs-number">1.</span><span class="hljs-built_in">size</span>()+s<span class="hljs-number">2.</span><span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;i&gt;=<span class="hljs-number">0</span>;i--) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>,c[i]);<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br><span class="hljs-keyword">for</span>(i=s<span class="hljs-number">1.</span><span class="hljs-built_in">size</span>()+s<span class="hljs-number">2.</span><span class="hljs-built_in">size</span>()<span class="hljs-number">-2</span>;i&gt;=<span class="hljs-number">0</span>;i--) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>,c[i]);<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>洛谷P1009  阶乘之和</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">int</span> a[<span class="hljs-number">105</span>];<br><span class="hljs-type">int</span> s[<span class="hljs-number">105</span>];<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ch</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> t=<span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> i,j;<br><span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">105</span>;i++)<br>&#123;<br>a[i]=a[i]*x+t;<br>t=a[i]/<span class="hljs-number">10</span>;<br>a[i]=a[i]%<span class="hljs-number">10</span>;<br>&#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> t=<span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> i;<br><span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">105</span>;i++)<br>&#123;<br>s[i]=s[i]+a[i]+t;<br>t=s[i]/<span class="hljs-number">10</span>;<br>s[i]=s[i]%<span class="hljs-number">10</span>;<br>&#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">memset</span>(a,<span class="hljs-number">0</span>,<span class="hljs-built_in">sizeof</span>(a));<br><span class="hljs-built_in">memset</span>(s,<span class="hljs-number">0</span>,<span class="hljs-built_in">sizeof</span>(s));<br>a[<span class="hljs-number">0</span>]=<span class="hljs-number">1</span>;<br>s[<span class="hljs-number">0</span>]=<span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> n;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;n);<br><span class="hljs-type">int</span> i;<br><span class="hljs-keyword">for</span>(i=<span class="hljs-number">1</span>;i&lt;=n;i++)<br>&#123;<br><span class="hljs-built_in">ch</span>(i);<br><span class="hljs-built_in">add</span>();<br>&#125;<br><span class="hljs-type">int</span> flag=<span class="hljs-number">104</span>;<br><span class="hljs-keyword">while</span>(s[flag]==<span class="hljs-number">0</span>)<br>&#123;<br>flag--;<br>&#125;<br><span class="hljs-keyword">for</span>(i=flag;i&gt;=<span class="hljs-number">0</span>;i--)<br>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>,s[i]);<br>&#125;<br> <br><br>&#125;<br></code></pre></td></tr></table></figure><p>快速幂模版 求a的n次方<br>考虑a进制下的幂次方求法<br><img src="https://mjj.today/i/OJZZET"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">qpow</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> n)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> ans=<span class="hljs-number">1</span>;<br><span class="hljs-keyword">while</span>(n)<br>&#123;<br><span class="hljs-keyword">if</span>(n&amp;<span class="hljs-number">1</span>) ans=ans*a;<br>a*=a;<br>n&gt;&gt;=<span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-keyword">return</span> ans;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>解释 用ans来存储最后的结果乘积。n&amp;1即n与1按位与，用来判断二进制下n最后一位是否为1，如果是则当前的a需要乘到ans中。之后n右移移位，相当于更新了二进制下的n末位。<br>常涉及到取模运算，记忆一些好用的性质。<br>$(A+B)mod b&#x3D;(A mod b+Bmodb)modb$<br>$(A<em>B)modb&#x3D;((Amodb)</em>(Bmodb))modb$<br>均可以通过待定系数法证明  (设$A&#x3D;Ka*b+Ra$)<br>高精度运算乘法加法用的相对较多。<br>高精度减法</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><br><span class="hljs-type">int</span> a[<span class="hljs-number">10</span>]=&#123;<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>&#125;;<br><span class="hljs-type">int</span> b[<span class="hljs-number">10</span>]=&#123;<span class="hljs-number">9</span>,<span class="hljs-number">9</span>,<span class="hljs-number">9</span>,<span class="hljs-number">9</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>&#125;;<br><span class="hljs-type">int</span> i,j;<br><span class="hljs-type">int</span> ans[<span class="hljs-number">10</span>]=&#123;<span class="hljs-number">0</span>&#125;;<br><span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">10</span>;i++)<br>&#123;<br><span class="hljs-keyword">if</span>(a[i]&gt;=b[i]) ans[i]=a[i]-b[i];<br><span class="hljs-keyword">else</span> <br>&#123;<br>a[i<span class="hljs-number">+1</span>]--;<br>a[i]=a[i]<span class="hljs-number">+10</span>;<br>ans[i]=a[i]-b[i];<br>&#125;<br>&#125;<br><span class="hljs-keyword">for</span>(i=<span class="hljs-number">9</span>;i&gt;=<span class="hljs-number">0</span>;i--) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>,ans[i]);<br>&#125;<br>```   <br><br>## 枚举的思考方式<br>情况较多开 <span class="hljs-type">long</span> <span class="hljs-type">long</span><br><br>## 地图类题目处理思路<br>一个利用特征值处理的方法<br>```c++<br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">int</span> dx[<span class="hljs-number">4</span>]=&#123;<span class="hljs-number">-1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>&#125;; <br><span class="hljs-type">int</span> dy[<span class="hljs-number">4</span>]=&#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">-1</span>&#125;;<br><span class="hljs-type">int</span> fx,fy,cx,cy,ff=<span class="hljs-number">0</span>,cf=<span class="hljs-number">0</span>,t=<span class="hljs-number">0</span>;<br><span class="hljs-type">bool</span> flag[<span class="hljs-number">160005</span>];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> i,j;<br><span class="hljs-type">char</span> a[<span class="hljs-number">11</span>][<span class="hljs-number">11</span>];<br><span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">10</span>;i++)<br>&#123;<br><span class="hljs-keyword">for</span>(j=<span class="hljs-number">0</span>;j&lt;<span class="hljs-number">10</span>;j++)         <span class="hljs-comment">//制图 </span><br>&#123;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot; %c&quot;</span>,&amp;a[i][j]);<br><span class="hljs-keyword">if</span>(a[i][j]==<span class="hljs-string">&#x27;F&#x27;</span>)<br>&#123;<br>fx=i;fy=j; a[i][j]=<span class="hljs-string">&#x27;.&#x27;</span>;<br>&#125;<br><span class="hljs-keyword">if</span>(a[i][j]==<span class="hljs-string">&#x27;C&#x27;</span>)<br>&#123;<br>cx=i;cy=j;a[i][j]=<span class="hljs-string">&#x27;.&#x27;</span>;<br>&#125;<br><br>&#125;<br><span class="hljs-built_in">getchar</span>();<br>&#125;<br><span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)<br>&#123;<br><span class="hljs-keyword">if</span>(cx==fx&amp;&amp;cy==fy)<br>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>,t);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-type">int</span> index=fx+fy*<span class="hljs-number">10</span>+cx*<span class="hljs-number">100</span>+cy*<span class="hljs-number">1000</span>+ff*<span class="hljs-number">10000</span>+cf*<span class="hljs-number">40000</span>;<br><br><br><span class="hljs-keyword">if</span>(flag[index])<span class="hljs-comment">//如果出现过了，则无解</span><br>        &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;0&quot;</span>);<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        flag[index]=<span class="hljs-number">1</span>;<br><span class="hljs-keyword">if</span>(fx+dx[ff]&gt;=<span class="hljs-number">0</span>&amp;&amp;fx+dx[ff]&lt;<span class="hljs-number">10</span>&amp;&amp;fy+dy[ff]&gt;=<span class="hljs-number">0</span>&amp;&amp;fy+dy[ff]&lt;<span class="hljs-number">10</span>&amp;&amp;a[fx+dx[ff]][fy+dy[ff]]!=<span class="hljs-string">&#x27;*&#x27;</span>)<br>&#123;<br>fx=fx+dx[ff];fy=fy+dy[ff];<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br>ff=(ff<span class="hljs-number">+1</span>)%<span class="hljs-number">4</span>;<br>&#125;<br><span class="hljs-keyword">if</span>(cx+dx[cf]&gt;=<span class="hljs-number">0</span>&amp;&amp;cx+dx[cf]&lt;<span class="hljs-number">10</span>&amp;&amp;cy+dy[cf]&gt;=<span class="hljs-number">0</span>&amp;&amp;cy+dy[cf]&lt;<span class="hljs-number">10</span>&amp;&amp;a[cx+dx[cf]][cy+dy[cf]]!=<span class="hljs-string">&#x27;*&#x27;</span>)<br>&#123;<br>cx=cx+dx[cf];cy=cy+dy[cf];<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br>cf=(cf<span class="hljs-number">+1</span>)%<span class="hljs-number">4</span>;<br>&#125;<br>t++;<br><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="DFS-BFS"><a href="#DFS-BFS" class="headerlink" title="DFS&#x2F;BFS"></a>DFS&#x2F;BFS</h2><p>关于搜索算法，先考虑深度优先搜索dfs，dfs的思路就是枚举各种可能，一条路走到黑，发现走不通就回溯，回到上一个节点继续枚举其他可能的路径。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//上楼梯问题，每次可以走一阶或两阶或三阶，问走法。</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">int</span> n,a[<span class="hljs-number">100000</span>],ans=<span class="hljs-number">0</span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> sum,<span class="hljs-type">int</span> num)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> i;<br><span class="hljs-keyword">if</span>(sum==n)   <span class="hljs-comment">//函数出口</span><br>&#123;<br><br><span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;num;i++) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>,a[i]);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;走了%d步&quot;</span>,num);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br>ans++;<br><span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-keyword">if</span>(sum&gt;n) <span class="hljs-keyword">return</span>;<br><span class="hljs-keyword">for</span>(i=<span class="hljs-number">1</span>;i&lt;=<span class="hljs-number">3</span>;i++)<br>&#123;<br>a[num]=i;          <span class="hljs-comment">//用数组a存储某一次探路中节点是哪些</span><br><span class="hljs-built_in">dfs</span>(sum+i,num<span class="hljs-number">+1</span>);  <span class="hljs-comment">//解决这样的子问题，在for循环内保证了所有节点的遍历</span><br>&#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;n);<br><span class="hljs-built_in">dfs</span>(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;一共有%d种走法&quot;</span>,ans);<br>&#125;<br></code></pre></td></tr></table></figure><p>关于广度优先搜索bfs，其思路则是一层一层遍历，使用队列来存储正在遍历的该层节点，每次将q.front()元素的全部向下连接节点入队后，再令这个去q.front()出队（使用q.pop()),在while(!q.empty())的情况下不断遍历，直到队列为空，则遍历完成。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/*有一个 n×m 的棋盘，在某个点 (x,y) 上有一个马，</span><br><span class="hljs-comment">要求你计算出马到达棋盘上任意一个点最少要走几步*/</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br>queue&lt;<span class="hljs-type">int</span>&gt; qx,qy;<br><span class="hljs-type">int</span> a[<span class="hljs-number">401</span>][<span class="hljs-number">401</span>]=&#123;<span class="hljs-number">0</span>&#125;,ans[<span class="hljs-number">401</span>][<span class="hljs-number">401</span>]=&#123;<span class="hljs-number">0</span>&#125;;   a记录每一个节点是否已经遍历过<br><span class="hljs-type">int</span> dx[<span class="hljs-number">8</span>]=&#123;<span class="hljs-number">-2</span>,<span class="hljs-number">-2</span>,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,<span class="hljs-number">-1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">-1</span>&#125;;<br><span class="hljs-type">int</span> dy[<span class="hljs-number">8</span>]=&#123;<span class="hljs-number">-1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">-1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">-2</span>,<span class="hljs-number">-2</span>,<span class="hljs-number">2</span>&#125;;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> n,m,x,y;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d%d&quot;</span>,&amp;n,&amp;m,&amp;x,&amp;y);<br>qx.<span class="hljs-built_in">push</span>(x);<br>qy.<span class="hljs-built_in">push</span>(y);<br>ans[x][y]=<span class="hljs-number">0</span>;a[x][y]=<span class="hljs-number">1</span>;<br><span class="hljs-keyword">while</span>(!qx.<span class="hljs-built_in">empty</span>())<br>&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">8</span>;i++)<br>        &#123;<br>        <span class="hljs-type">int</span> tx=qx.<span class="hljs-built_in">front</span>()+dx[i];<br>        <span class="hljs-type">int</span> ty=qy.<span class="hljs-built_in">front</span>()+dy[i];<br>        <span class="hljs-keyword">if</span>(tx&gt;<span class="hljs-number">0</span>&amp;&amp;tx&lt;=n&amp;&amp;ty&gt;<span class="hljs-number">0</span>&amp;&amp;ty&lt;=m&amp;&amp;a[tx][ty]==<span class="hljs-number">0</span>)<br>        &#123;<br>        a[tx][ty]=<span class="hljs-number">1</span>;  <span class="hljs-comment">//使得树向下分叉，避免无限循环 </span><br>        ans[tx][ty]=ans[qx.<span class="hljs-built_in">front</span>()][qy.<span class="hljs-built_in">front</span>()]<span class="hljs-number">+1</span>;<br>        qx.<span class="hljs-built_in">push</span>(tx);<br>        qy.<span class="hljs-built_in">push</span>(ty);<br>&#125;<br>&#125;<br>qx.<span class="hljs-built_in">pop</span>();<br>qy.<span class="hljs-built_in">pop</span>();<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=m;j++)&#123;<br><span class="hljs-keyword">if</span>(ans[i][j]==<span class="hljs-number">0</span>)<br>&#123;<br><span class="hljs-keyword">if</span>(i!=x||j!=y) ans[i][j]=<span class="hljs-number">-1</span>;<br>&#125;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%-5d&quot;</span>,ans[i][j]);<br>&#125;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>题目总结</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法竞赛</tag>
      
      <tag>c++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>template:数据结构</title>
    <link href="/2025/03/21/%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%A8%A1%E7%89%88/"/>
    <url>/2025/03/21/%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%A8%A1%E7%89%88/</url>
    
    <content type="html"><![CDATA[<h1 id="双链表"><a href="#双链表" class="headerlink" title="双链表"></a>双链表</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">100010</span>;<br><span class="hljs-type">int</span> m;<br><span class="hljs-type">int</span> e[N],l[N],r[N],idx;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-type">int</span> k,<span class="hljs-type">int</span> x)</span>  <span class="hljs-comment">//第k个节点右边插入一个数</span></span><br><span class="hljs-function"></span>&#123;<br>    e[idx]=x;<br>    l[idx]=k;<br>    r[idx]=r[k];<br>    l[r[k]]=idx;<br>    r[k]=idx;<br>    idx++;<br><br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">del</span><span class="hljs-params">(<span class="hljs-type">int</span> k)</span></span><br><span class="hljs-function"></span>&#123;<br><br>    l[r[k]]=l[k];<br>    r[l[k]]=r[k];<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    r[<span class="hljs-number">0</span>]=<span class="hljs-number">1</span>;<br>    l[<span class="hljs-number">1</span>]=<span class="hljs-number">0</span>;<br><br>    idx=<span class="hljs-number">2</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="模拟栈"><a href="#模拟栈" class="headerlink" title="模拟栈"></a>模拟栈</h1><p><code>s.empty()</code>判断非空</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stack&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 创建栈（默认使用deque）</span><br>    std::stack&lt;<span class="hljs-type">int</span>&gt; s;<br>    <br>    <span class="hljs-comment">// 压栈操作</span><br>    s.<span class="hljs-built_in">push</span>(<span class="hljs-number">10</span>);<br>    s.<span class="hljs-built_in">push</span>(<span class="hljs-number">20</span>);<br>    s.<span class="hljs-built_in">push</span>(<span class="hljs-number">30</span>);<br><br>    <span class="hljs-comment">// 查看栈顶</span><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;栈顶元素: &quot;</span> &lt;&lt; s.<span class="hljs-built_in">top</span>() &lt;&lt; std::endl; <span class="hljs-comment">// 30</span><br><br>    <span class="hljs-comment">// 出栈操作</span><br>    s.<span class="hljs-built_in">pop</span>();<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;弹出后栈顶: &quot;</span> &lt;&lt; s.<span class="hljs-built_in">top</span>() &lt;&lt; std::endl; <span class="hljs-comment">// 20</span><br> <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><h1 id="模拟队列"><a href="#模拟队列" class="headerlink" title="模拟队列"></a>模拟队列</h1><p><code>q.empty()</code>判断非空</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">100001</span>;<br><span class="hljs-type">int</span> a[N],hh=<span class="hljs-number">0</span>,tt=<span class="hljs-number">-1</span>; <span class="hljs-comment">//定义队头对位俩指针，这样初始化，当hh==tt队内有一个元素，当hh&gt;tt的时候·队内无元素。</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> M;<br>    cin&gt;&gt;M;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;M;i++)<br>    &#123;<br>        string s;<br>        cin&gt;&gt; s;<br>        <span class="hljs-keyword">if</span>(s == <span class="hljs-string">&quot;push&quot;</span>)<br>        &#123;<br>            <span class="hljs-type">int</span> x; cin&gt;&gt;x;<br>            tt++;<br>            a[tt]= x;<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(s==<span class="hljs-string">&quot;empty&quot;</span>)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(hh&gt;tt) cout&lt;&lt;<span class="hljs-string">&quot;YES&quot;</span>&lt;&lt;endl;<br>            <span class="hljs-keyword">else</span> cout&lt;&lt;<span class="hljs-string">&quot;NO&quot;</span>&lt;&lt;endl;<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(s==<span class="hljs-string">&quot;pop&quot;</span>)<br>        &#123;<br>            hh++;<br>        &#125;<br>        <span class="hljs-keyword">else</span>&#123;<br>            cout&lt;&lt;a[hh]&lt;&lt;endl;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="单调栈"><a href="#单调栈" class="headerlink" title="单调栈"></a>单调栈</h1><p>来源问题:给定一个长度为 N 的整数数列，输出每个数左边第一个比它小的数，如果不存在则输出 −1            </p><p>单调栈：用一个栈，维护一个单调的不定长序列，举个例子:</p><p>7 6 2 1 3 8 栈内维护降序列<br>7  7,6  7,6,2  7,6,2,1  7,6,3  8</p><p>手模一遍之后思路很清晰了，对所有数进行遍历，如果新数小于栈顶的数直接入栈，如果新数大于栈顶的数，则不断弹栈直到栈顶元素小于新数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">1e5</span><span class="hljs-number">+10</span>;<br><span class="hljs-type">int</span> s[N],top=<span class="hljs-number">-1</span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n;<br>    cin&gt;&gt;n;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++) <br>    &#123;<br>        <span class="hljs-type">int</span> x;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;x);<br>        <span class="hljs-keyword">if</span>(top==<span class="hljs-number">-1</span>) cout&lt;&lt;<span class="hljs-string">&quot;-1&quot;</span>&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>        <span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-keyword">while</span>(s[top]&gt;=x) top--;<br>            <span class="hljs-keyword">if</span>(top&gt;<span class="hljs-number">-1</span>) cout&lt;&lt;s[top]&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>            <span class="hljs-keyword">else</span> cout&lt;&lt;<span class="hljs-string">&quot;-1&quot;</span>&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>        &#125;<br>        s[++top]=x;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="滑动窗口-单调双端队列"><a href="#滑动窗口-单调双端队列" class="headerlink" title="滑动窗口&#x2F;单调双端队列"></a>滑动窗口&#x2F;单调双端队列</h1><h4 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h4><p>给定一个大小为$n\leq10^6$的数组。，有一个大小为$k$的滑动窗口，它从数组的最左边移动到最右边。你只能在窗口中看到$k$个数字。每次滑动窗口向右移动一个位置。</p><p>以下是一个例子：</p><p>数组 2 6 5 7 8 6 </p><p>每次的窗口中的值分别为 265 657 578 786</p><p>你的任务是确定滑动窗口位于每个位置时，窗口中的最大值和最小值。</p><p>解决这一问题可以直接暴力搜索，但是时间复杂度近似于$O(n^2)$。我们引入一种使用单调双端队列的方式，即维护一个定长$k$的升序&#x2F;降序区间。首先来确定双端队列的结构。</p><p><a href="https://imgse.com/i/pEKiuHU"><img src="https://s21.ax1x.com/2025/02/14/pEKiuHU.md.jpg" alt="pEKiuHU.md.jpg"></a></p><ul><li>使用数组模拟，<strong>队头在左，队尾在右</strong>，这是因为队尾会不断有新元素入队，倘若队尾在左的话会导致数组越界</li><li>符号法则:初始<code>hh=0</code> <code>tt=-1</code>,检查队列非空判断<code>hh&lt;=tt</code>即可，队尾入队总是使用<code>q[++tt]</code>,队头出队总是使用<code>hh++</code>.</li><li>队尾出队的条件:队列不空且新元素更优，则队尾不断出队</li><li>队头出队的条件:滑出了窗口范围</li></ul><p>本题的思路是，使用一个单调双端队列维护窗口内的一个单调序列，遍历每一个元素入队的过程，做两次判断，先判断队头元素是否需要滑出，再判断多少队尾元素会被等待入队的更优元素淘汰。然后入队新元素，如果<code>i&gt;k-1</code>则输出队头元素。</p><p>从这一思路我们也可以看出，应当使用q存储元素在数组中的下标而非元素值本身，因为算法涉及到判断队头元素是否需要划出，这是不能使用元素值判断的，必须通过比较队头元素下标<code>q[hh]</code>和当前窗口尾坐标<code>i-k+1</code>来判断</p><p>综上所述，由于每个元素最多入队出队一次，因此本题得以在$O(2N)$的时间复杂度内求解</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//队头是要出队的，hh放在左，tt放在右</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">1e6</span><span class="hljs-number">+10</span>;<br><span class="hljs-comment">//q[N]存存储元素的下标</span><br><span class="hljs-type">int</span> q[N],a[N],hh=<span class="hljs-number">0</span>,tt=<span class="hljs-number">-1</span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n,k;<br>    cin&gt;&gt;n&gt;&gt;k;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++) cin&gt;&gt;a[i];<br>    <span class="hljs-comment">//找最小元素</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)<br>    &#123;    <br>        <span class="hljs-comment">//如果队列非空并且队头指标已经不在遍历范围之内，则队头出队</span><br>        <span class="hljs-keyword">if</span>(tt&gt;=hh&amp;&amp;q[hh]&lt;i-k<span class="hljs-number">+1</span>) hh++;<br>        <span class="hljs-comment">//为ai入队做准备，如果队列非空，则一直排除更大的老元素</span><br>        <span class="hljs-keyword">while</span>(tt&gt;=hh&amp;&amp;a[q[tt]]&gt;a[i]) tt--;<br>        <span class="hljs-comment">//ai入队</span><br>        q[++tt]=i;<br>        <span class="hljs-comment">//超过k个数才可以打印，这是为了防止开始的情况</span><br>        <span class="hljs-keyword">if</span>(i&gt;=k<span class="hljs-number">-1</span>) cout&lt;&lt;a[q[hh]]&lt;&lt;<span class="hljs-string">&#x27; &#x27;</span>;<br>        <br>    &#125;<br>    hh=<span class="hljs-number">0</span>,tt=<span class="hljs-number">-1</span>;<br>    cout&lt;&lt;endl;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(tt&gt;=hh&amp;&amp;q[hh]&lt;i-k<span class="hljs-number">+1</span>) hh++;<br>        <span class="hljs-keyword">while</span>(tt&gt;=hh&amp;&amp;a[q[tt]]&lt;a[i]) tt--;<br>        q[++tt]=i;<br>        <span class="hljs-keyword">if</span>(i&gt;=k<span class="hljs-number">-1</span>) cout&lt;&lt;a[q[hh]]&lt;&lt;<span class="hljs-string">&#x27; &#x27;</span>;<br>    &#125;<br><br>&#125;<br><br><br></code></pre></td></tr></table></figure><h1 id="KMP字符串"><a href="#KMP字符串" class="headerlink" title="KMP字符串"></a>KMP字符串</h1><p>用小字符串在大字符串中匹配，找最开始出现的脚标。<br>算法的核心在于引入了next函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">100010</span>, M = <span class="hljs-number">1000010</span>;<br><br><span class="hljs-type">int</span> n, m;<br><span class="hljs-type">int</span> ne[N];<br><span class="hljs-type">char</span> s[M], p[N];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cin &gt;&gt; n &gt;&gt; p + <span class="hljs-number">1</span> &gt;&gt; m &gt;&gt; s + <span class="hljs-number">1</span>;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>, j = <span class="hljs-number">0</span>; i &lt;= n; i ++ )<br>    &#123;<br>        <span class="hljs-keyword">while</span> (j &amp;&amp; p[i] != p[j + <span class="hljs-number">1</span>]) j = ne[j];<br>        <span class="hljs-keyword">if</span> (p[i] == p[j + <span class="hljs-number">1</span>]) j ++ ;<br>        ne[i] = j;<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>, j = <span class="hljs-number">0</span>; i &lt;= m; i ++ )<br>    &#123;<br>        <span class="hljs-keyword">while</span> (j &amp;&amp; s[i] != p[j + <span class="hljs-number">1</span>]) j = ne[j];<br>        <span class="hljs-keyword">if</span> (s[i] == p[j + <span class="hljs-number">1</span>]) j ++ ;<br>        <span class="hljs-keyword">if</span> (j == n)<br>        &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>, i - n);<br>            j = ne[j];<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="trie树-字典树"><a href="#trie树-字典树" class="headerlink" title="trie树&#x2F;字典树"></a>trie树&#x2F;字典树</h1><p>需求描述：要求维护一个字符串集合，这个集合应当拥有两个功能</p><ul><li>查询一个字符串是否出现过</li><li>查询一个字符串的出现次数</li></ul><p>引入一种高效的数据结构：字典树</p><ul><li>子节点的唯一标识是idx</li><li>儿子数组son[a][i]存储节点a沿着i这条边走到的子节点</li><li>每个节点最多有26个分支，用数字0<del>25映射字母a</del>z</li><li><code>idx=0</code>为整个树的根</li></ul><p><a href="https://imgse.com/i/pEKmJ0I"><img src="https://s21.ax1x.com/2025/02/14/pEKmJ0I.md.png" alt="pEKmJ0I.md.png"></a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">1e5</span><span class="hljs-number">+10</span>;<br><span class="hljs-comment">// son[a][i]  idx==a节点的第i个儿子的idx</span><br><span class="hljs-comment">// cnt：在idx结尾的数有多少个</span><br><span class="hljs-type">int</span> son[N][<span class="hljs-number">27</span>],cnt[N]=&#123;<span class="hljs-number">0</span>&#125;,idx=<span class="hljs-number">0</span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insertt</span><span class="hljs-params">(string str)</span></span>&#123;<br>    <span class="hljs-type">int</span> p=<span class="hljs-number">0</span>;<br>    <span class="hljs-comment">//p表示当前遍历到的节点</span><br>    <span class="hljs-comment">//判断当前节点是否有对应的子节点，没有则创建，并把p更新为子节点</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;str.<span class="hljs-built_in">size</span>();i++)<br>    &#123;<br>        <span class="hljs-type">int</span> u=str[i]-<span class="hljs-string">&#x27;a&#x27;</span>;<br>        <span class="hljs-keyword">if</span>(!son[p][u]) son[p][u]=++idx;<br>        p=son[p][u];  <span class="hljs-comment">//为了单纯查找的情况的存在，不可写为 p=idx;</span><br>    &#125;<br>    cnt[p]++;<br><br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">queryt</span><span class="hljs-params">(string str)</span></span>&#123;<br>    <span class="hljs-type">int</span> p=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;str.<span class="hljs-built_in">size</span>();i++)<br>    &#123;<br>        <span class="hljs-type">int</span> u=str[i]-<span class="hljs-string">&#x27;a&#x27;</span>;<br>        <span class="hljs-keyword">if</span>(!son[p][u]) <br>        &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        p=son[p][u];<br>    &#125;<br>    <span class="hljs-comment">//最后在最终的字母对应的儿子的idx结尾</span><br>   <span class="hljs-keyword">return</span> cnt[p];<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n;<br>    cin&gt;&gt;n;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)<br>    &#123;<br>        string c, s;<br>        cin&gt;&gt;c&gt;&gt;s;<br>        <span class="hljs-keyword">if</span>(c==<span class="hljs-string">&quot;I&quot;</span>) <span class="hljs-built_in">insertt</span>(s);<br>        <span class="hljs-keyword">else</span> cout&lt;&lt;<span class="hljs-built_in">queryt</span>(s)&lt;&lt;endl;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h1><p>并查集，顾名思义，它的功能应当有：</p><ul><li>快速合并集合</li><li>查找两个元素是否属于同一个集合</li></ul><p>考虑经典情形：一开始1-n n个数，处理多次合并与查询的操作</p><p>算法的核心在于：只存父节点，并通过find函数不断优化整个树的结构<br>只存父节点是因为只需要维护是否属于同一个集合的信息，不同以往的还需要维护整个序列的信息。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1e5</span><span class="hljs-number">+10</span>;<br><span class="hljs-type">int</span> p[N];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//在没找到祖宗节点之前，不停的对父节点调用find</span><br>    <span class="hljs-keyword">if</span>(p[x]!=x) p[x]=<span class="hljs-built_in">find</span>(p[x]);<br>    <span class="hljs-comment">//找到祖宗节点后，返回祖宗节点，事实上前面的所有find函数收到的return都是祖宗节点</span><br>    <span class="hljs-comment">//完成了find过程中的顺便优化</span><br>    <span class="hljs-keyword">return</span> p[x];<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n,m;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++) p[i]=i;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;m;i++)<br>    &#123;<br>        <span class="hljs-type">char</span> c;<br>        cin&gt;&gt;c; <br>        <span class="hljs-type">int</span> a,b;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;a,&amp;b);<br>        <span class="hljs-comment">//合并a，b：a的祖宗节点归属于b的祖宗</span><br>        <span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;M&#x27;</span>) p[<span class="hljs-built_in">find</span>(a)]=<span class="hljs-built_in">find</span>(b);<br>        <span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-keyword">if</span>(<span class="hljs-built_in">find</span>(a)==<span class="hljs-built_in">find</span>(b)) cout&lt;&lt;<span class="hljs-string">&quot;Yes&quot;</span>;<br>            <span class="hljs-keyword">else</span> cout&lt;&lt;<span class="hljs-string">&quot;No&quot;</span>;<br>            cout&lt;&lt;endl;<br>        &#125;<br>    &#125;<br>    <br>&#125;<br><br></code></pre></td></tr></table></figure><h1 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h1><p>解决的问题：给定一个数列，从小到大输出前m个小的数<br>堆是一颗完全二叉树，任何一个节点的儿子都比父亲大，为此维护堆有两个基本的操作</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">down</span><span class="hljs-params">(<span class="hljs-type">int</span> u)</span><br>&#123;<br>    <span class="hljs-comment">//要找出三个里面的最小值作为新的父节点</span><br>    <span class="hljs-type">int</span> t = u;<br>    <span class="hljs-comment">//左儿子存在则判断左儿子是否更小</span><br>    <span class="hljs-keyword">if</span> (u * <span class="hljs-number">2</span> &lt;= size &amp;&amp; h[u * <span class="hljs-number">2</span>] &lt; h[t]) t = u * <span class="hljs-number">2</span>;<br>    <span class="hljs-comment">//右儿子存在则判断右儿子是否更小</span><br>    <span class="hljs-keyword">if</span> (u * <span class="hljs-number">2</span> + <span class="hljs-number">1</span> &lt;= size &amp;&amp; h[u * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>] &lt; h[t]) t = u * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>;<br>    <span class="hljs-comment">//如果idx==u处的data被更新过了，继续down下去</span><br>    <span class="hljs-keyword">if</span> (u != t)<br>    &#123;<br>        heap_swap(u, t);<br>        down(t);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//up操作相对比较简单，沿着一条线不停向上即可，注意到u/2可以包含u为奇数或者偶数的两种情况。</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">up</span><span class="hljs-params">(<span class="hljs-type">int</span> u)</span><br>&#123;<br>    <span class="hljs-comment">//</span><br>    <span class="hljs-keyword">while</span> (u / <span class="hljs-number">2</span> &amp;&amp; h[u] &lt; h[u / <span class="hljs-number">2</span>])<br>    &#123;<br>        heap_swap(u, u / <span class="hljs-number">2</span>);<br>        u &gt;&gt;= <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>两个函数接受的都是idx，考虑这个idx的节点data是否需要down下去或者up上来。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1e5</span><span class="hljs-number">+10</span>;<br><span class="hljs-type">int</span> n,m;<br><span class="hljs-comment">//堆是一个完全二叉树，对于父节点u。定义其左儿子为2*u，右儿子为2*u+1，树的指向既定且无法修改，我们可以修改不同idx位置对应的data</span><br><span class="hljs-type">int</span> h[N],idx;<br><span class="hljs-comment">//把大数down到底下，确保这个局部的根节点是最小数，并继续进行递归。</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">down</span><span class="hljs-params">(<span class="hljs-type">int</span> u)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> t=u;<br>    <span class="hljs-keyword">if</span>(<span class="hljs-number">2</span>*u&lt;=idx&amp;&amp;h[<span class="hljs-number">2</span>*u]&lt;h[t]) t=<span class="hljs-number">2</span>*u;<br>    <span class="hljs-keyword">if</span>(<span class="hljs-number">2</span>*u<span class="hljs-number">+1</span>&lt;=idx&amp;&amp;h[<span class="hljs-number">2</span>*u<span class="hljs-number">+1</span>]&lt;h[t]) t=<span class="hljs-number">2</span>*u<span class="hljs-number">+1</span>;<br>    <span class="hljs-keyword">if</span>(t!=u)<br>    &#123;<br>        <span class="hljs-built_in">swap</span>(h[t],h[u]);<br>        <span class="hljs-built_in">down</span>(t);  <span class="hljs-comment">//t位置变成了新的数，需要继续看看需不需要down。</span><br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cin&gt;&gt;n&gt;&gt;m;<br>    idx=n;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++) <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;h[i]);<br>    <span class="hljs-comment">// n/2是最后一个有son的节点，从此开始down就可以建堆</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=n/<span class="hljs-number">2</span>;i;i--) <span class="hljs-built_in">down</span>(i);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;m;i++)<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>,h[<span class="hljs-number">1</span>]);<br>        h[<span class="hljs-number">1</span>]=h[idx];<br>        idx--;<br>        <span class="hljs-built_in">down</span>(<span class="hljs-number">1</span>);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h1 id="哈希"><a href="#哈希" class="headerlink" title="哈希"></a>哈希</h1><p>一般情况下的hash都可以用stl写，</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;unordered_map&gt;</span></span><br><span class="hljs-function">unordered_map&lt;<span class="hljs-type">int</span>,<span class="hljs-type">bool</span>&gt; mp</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//类似数组的接口就可以完成基本的调用</span><br>    mp[<span class="hljs-number">1</span>]=<span class="hljs-literal">false</span>;<br>    mp[<span class="hljs-number">2</span>]=<span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>字符串哈希遇到基本需要手写</p><p>给定一个长度为 $\mathfrak{n}$ 的字符串，再给定 m 个询问，每个询问包含四个整数$l_1,r_1,l_2,r_2$,请你判断$[l_1,r_1]$和<br>$[l_2,r_2]$这两个区间所包含的字符串子串是否完全相同。</p><p>字符串中只包含大小写英文字母和数字。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs c++"><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> ULL;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1e5</span><span class="hljs-number">+5</span>,P = <span class="hljs-number">131</span>;<span class="hljs-comment">//131 13331</span><br>ULL h[N],p[N];<br><br><span class="hljs-comment">// h[i]前i个字符的hash值,从1开始计数</span><br><span class="hljs-comment">// 字符串变成一个p进制数字，体现了字符+顺序，需要确保不同的字符串对应不同的数字</span><br><span class="hljs-comment">// P = 131 或  13331 Q=2^64，在99%的情况下不会出现冲突</span><br><span class="hljs-comment">// 使用场景： 两个字符串的子串是否相同</span><br><span class="hljs-function">ULL <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-type">int</span> l,<span class="hljs-type">int</span> r)</span></span>&#123;<br>    <span class="hljs-keyword">return</span> h[r] - h[l<span class="hljs-number">-1</span>]*p[r-l<span class="hljs-number">+1</span>];<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">int</span> n,m;<br>    cin&gt;&gt;n&gt;&gt;m;<br>    string x;<br>    cin&gt;&gt;x;<br><br>    <span class="hljs-comment">//字符串从1开始编号，h[1]为前一个字符的哈希值</span><br>    p[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>    h[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>        p[i<span class="hljs-number">+1</span>] = p[i]*P;            <br>        h[i<span class="hljs-number">+1</span>] = h[i]*P +x[i];      <span class="hljs-comment">//前缀和求整个字符串的哈希值</span><br>    &#125;<br><br>    <span class="hljs-keyword">while</span>(m--)&#123;<br>        <span class="hljs-type">int</span> l1,r1,l2,r2;<br>        cin&gt;&gt;l1&gt;&gt;r1&gt;&gt;l2&gt;&gt;r2;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">query</span>(l1,r1) == <span class="hljs-built_in">query</span>(l2,r2)) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Yes\n&quot;</span>);<br>        <span class="hljs-keyword">else</span> <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;No\n&quot;</span>);<br><br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><h1 id="一些常用的stl数据结构"><a href="#一些常用的stl数据结构" class="headerlink" title="一些常用的stl数据结构"></a>一些常用的stl数据结构</h1><h2 id="queue-priority-queue"><a href="#queue-priority-queue" class="headerlink" title="queue&#x2F;priority_queue"></a>queue&#x2F;priority_queue</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;queue&gt;</span></span><br><span class="hljs-comment">//一般队列queue</span><br>queue&lt;<span class="hljs-type">int</span>&gt; q;    <br>q.<span class="hljs-built_in">push</span>(b);<br><span class="hljs-type">int</span> a = q.<span class="hljs-built_in">top</span>();<br>q.<span class="hljs-built_in">pop</span>();<br><br><span class="hljs-comment">//优先队列，默认是一个最大堆，也可以改为最小堆</span><br>priority_queue&lt;<span class="hljs-type">int</span>&gt; q;<br><span class="hljs-comment">// 最小堆： priority_queue&lt;int,greater&lt;int&gt;&gt; heap;</span><br>q.<span class="hljs-built_in">push</span>(b);  <span class="hljs-comment">//注意vector是push_back()</span><br><span class="hljs-type">int</span> a = q.<span class="hljs-built_in">top</span>();<br>q.<span class="hljs-built_in">pop</span>();<br><br><span class="hljs-comment">//引入pii,会按照pii第一个元素进行排序</span><br><span class="hljs-keyword">typedef</span> pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt; pii;<br>priority_queue&lt;pii,vector&lt;pii&gt;,greater&lt;pii&gt;&gt; heap;<br><span class="hljs-comment">// 分别代表，元素类型，存储使用的底层容器，排序规则是小在上</span><br></code></pre></td></tr></table></figure><h2 id="map-unordered-map"><a href="#map-unordered-map" class="headerlink" title="map&#x2F;unordered_map"></a>map&#x2F;unordered_map</h2><p>map和umap都是建立由键到值的映射，不过</p><ul><li>map原理是红黑树，会按照键进行升序排序，查找、插入和删除操作的时间复杂度是O(log n)。</li><li>而umap基于哈希，是无序的，查找、插入和删除操作的平均时间复杂度是O(1)。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;map&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    std::map&lt;std::string, <span class="hljs-type">int</span>&gt; wordCount;<br><br>    <span class="hljs-comment">// 插入键值对</span><br>    wordCount[<span class="hljs-string">&quot;banana&quot;</span>] = <span class="hljs-number">1</span>;<br>    wordCount[<span class="hljs-string">&quot;apple&quot;</span>] = <span class="hljs-number">2</span>;<br>    wordCount[<span class="hljs-string">&quot;cherry&quot;</span>] = <span class="hljs-number">1</span>;<br><br>    <span class="hljs-comment">// 遍历并输出键值对</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; pair : wordCount) &#123;<br>        std::cout &lt;&lt; pair.first &lt;&lt; <span class="hljs-string">&quot;: &quot;</span> &lt;&lt; pair.second &lt;&lt; std::endl;<br>    &#125;<br><br>    <span class="hljs-comment">// 查找元素</span><br>    <span class="hljs-keyword">auto</span> it = wordCount.<span class="hljs-built_in">find</span>(<span class="hljs-string">&quot;banana&quot;</span>);<br>    <span class="hljs-keyword">if</span> (it != wordCount.<span class="hljs-built_in">end</span>()) &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Found banana with count: &quot;</span> &lt;&lt; it-&gt;second &lt;&lt; std::endl;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行结果为<br>apple: 2<br>banana: 1<br>cherry: 1<br>Found banana with count: 1                         </p><p>但是unordered结果完全无序：<br>apple: 2<br>cherry: 1<br>banana: 1<br>Found banana with count: 1          </p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法竞赛</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>numpy框架探究</title>
    <link href="/2025/03/21/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/numpy%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0/"/>
    <url>/2025/03/21/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/numpy%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="性质与创建"><a href="#性质与创建" class="headerlink" title="性质与创建"></a>性质与创建</h1><h2 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h2><p>ndarray（N-dimensional array，即N维数组）是NumPy的核心数据结构。可将ndarray看作是一个“智能容器”。相比于python原生数据结构，他有更好的特性，因此性能更优。他在数学上等同于一个张量，不过有些性质为了程序设计的合理性，并不符合数学直觉，后面会一一谈到。</p><p>ndarray之所以比python原生数据结构更高效，主要由以下三个性质决定，从这里也可以明显看出:ndarray在内存管理上更像c，而不是python</p><ul><li><strong>同质数据类型</strong>：ndarray要求所有元素具有相同的数据类型。这种同质性使得ndarray在内存管理和数据操作上更加高效，避免了类型转换带来的额外开销。</li><li><strong>多维结构</strong>：ndarray支持多维结构，能够表示各种复杂的数据形式。</li><li><strong>连续内存存储</strong>：NumPy 的 ndarray 采用连续内存存储，即其在内存中连续分配空间。与之不同，Python 列表元素在内存里分散存储，各元素有独立内存地址，且列表含指向这些元素的指针。这种分散存储在访问元素时需多次指针跳转，致使访问效率低。而 ndarray 凭借连续内存存储，计算机只需依据元素索引和数组起始地址进行简单计算，就能直接定位元素内存位置，实现快速访问。</li></ul><h2 id="轴（axis）"><a href="#轴（axis）" class="headerlink" title="轴（axis）"></a>轴（axis）</h2><p>轴定义了ndarray的维度，数学上几维张量就有几个轴，ndarray亦是如此，以计算机视觉中常常涉及到的三通道彩色图像为例</p><p><a href="https://imgse.com/i/pEelG1e"><img src="https://s21.ax1x.com/2025/02/05/pEelG1e.md.jpg" alt="pEelG1e.md.jpg"></a></p><p>对于一个三通道的彩色图像，通常用一个形状为 <code>(height, width, channels)</code> 的三维 <code>ndarray</code> 来表示，其中：</p><ul><li><code>axis = 0</code>：对应图像的高度方向，也就是垂直方向。沿着这个轴操作，会对图像的不同行进行处理。</li><li><code>axis = 1</code>：对应图像的宽度方向，即水平方向。沿着这个轴操作，会对图像的不同列进行处理。</li><li><code>axis = 2</code>：对应图像的通道方向，即红、绿、蓝三个通道。沿着这个轴操作，会对同一像素位置的不同颜色通道进行处理。</li></ul><p>这种定义的好处是设计接口同一，但也导致会一些反数学直觉的现象：比如形状(1,3)和形状为(3,)的ndarray不是同一个东西，前者是一个二维矩阵，后者是一个一维向量，这将导致他们在数学运算上展示出一些差异。</p><h2 id="使用np-array-创建数组"><a href="#使用np-array-创建数组" class="headerlink" title="使用np.array()创建数组"></a>使用np.array()创建数组</h2><p><code>numpy.array()</code> 是 NumPy 库中用于创建数组的核心函数，</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs py">numpy.array(<span class="hljs-built_in">object</span>, dtype = <span class="hljs-literal">None</span>, copy = <span class="hljs-literal">True</span>, order = <span class="hljs-literal">None</span>, subok = <span class="hljs-literal">False</span>, ndmin = <span class="hljs-number">0</span>)<br></code></pre></td></tr></table></figure><p>详细解释各个参数的含义：            </p><h4 id="object"><a href="#object" class="headerlink" title="object"></a>object</h4><p> <code>object</code>表示要转换为 <code>ndarray</code> 的输入数据。可以是多种类型的对象，常见的有：</p><ul><li><strong>列表（list）</strong>：例如 <code>[1, 2, 3]</code> 或 <code>[[1, 2], [3, 4]]</code>，分别可以转换为一维和二维数组。</li><li><strong>元组（tuple）</strong>：像 <code>(1, 2, 3)</code> 也能被转换为一维数组。</li><li><strong>其他对象</strong>：包括ndarray对象，pdread出来的对象等</li></ul><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">import</span> pandas <span class="hljs-keyword">as</span> pd<br><br><span class="hljs-comment"># 从 CSV 文件读取数据</span><br>data = pd.read_csv(<span class="hljs-string">&#x27;data.csv&#x27;</span>)<br><span class="hljs-comment"># 转换为 NumPy 数组</span><br>X = np.array(data.drop(<span class="hljs-string">&#x27;target&#x27;</span>, axis=<span class="hljs-number">1</span>))<br>y = np.array(data[<span class="hljs-string">&#x27;target&#x27;</span>])<br></code></pre></td></tr></table></figure><h4 id="dtype"><a href="#dtype" class="headerlink" title="dtype"></a>dtype</h4><p> <code>dtype</code> 用于指定数组元素的数据类型，在选择数据类型时，性能差异是一个需要重点考虑的因素。常见的数据类型包括 Python 内置的 <code>int、float、bool</code> 等，以及 NumPy 特有的具体位数类型，如 <code>np.int32、np.float64</code> 等。后者效率远远高于前者，因为python原生数据包含结构引用计数和类型指针等额外信息。不过在不指定 <code>dtype</code> 时，NumPy 多数情况会自动使用合适的 NumPy 数据类型，但为了性能和代码的健壮性，明确指定 <code>dtype</code> 是更好的做法。</p><p> 在机器学习中，对于大规模数据集，选择合适的数据类型至关重要。例如，图像数据通常可以使用 <code>np.uint8</code> 类型，而神经网络中的权重和偏置通常使用 <code>np.float32</code> 以平衡精度和计算速度。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">import</span> cv2<br><br><span class="hljs-comment"># 读取图像</span><br>image = cv2.imread(<span class="hljs-string">&#x27;image.jpg&#x27;</span>)<br><span class="hljs-comment"># 转换为 NumPy 数组并指定数据类型</span><br>image_array = np.array(image, dtype=np.uint8)<br></code></pre></td></tr></table></figure><h4 id="copy（不常用）"><a href="#copy（不常用）" class="headerlink" title="copy（不常用）"></a>copy（不常用）</h4><p>可选参数，是一个布尔值，默认为 <code>True</code>。如果 <code>copy</code> 为 <code>True</code>，则会创建输入对象的一个副本；如果为 <code>False</code>，则尽可能不复制，而是直接使用输入对象的数据。当输入本身就是 <code>ndarray</code> 时，这个参数会影响是否创建新的数组对象。</p><h4 id="order-不常用"><a href="#order-不常用" class="headerlink" title="order(不常用)"></a>order(不常用)</h4><p>可选参数，用于指定数组在内存中的存储顺序，有三个可选值：</p><h4 id="subok-不常用"><a href="#subok-不常用" class="headerlink" title="subok(不常用)"></a>subok(不常用)</h4><p>在机器学习库中，有时会自定义数组子类以实现特定的功能。如果需要保留这些子类的属性和方法，将 subok 设置为 True；否则，使用默认的 False 会返回普通的 ndarray。</p><h4 id="ndmin"><a href="#ndmin" class="headerlink" title="ndmin"></a>ndmin</h4><p>确保数组具有最小的维度，这在处理一些需要固定维度输入的机器学习模型时非常有用。例如，某些模型要求输入数据至少是二维的，使用 <code>ndmin</code> 可以保证输入数据符合要求。</p><h2 id="使用函数生成数组"><a href="#使用函数生成数组" class="headerlink" title="使用函数生成数组"></a>使用函数生成数组</h2><h3 id="np-arange"><a href="#np-arange" class="headerlink" title="np.arange()"></a>np.arange()</h3><p>类似于python的<code>range()</code>函数,接受参数为<code>首项开，末项闭合，步长可指定</code></p><p><code>np.arange(start,stop,step,dtype=None)</code></p><p>在超参数调优时，我们可能需要对某个超参数进行等间隔取值来评估模型性能。例如，在调整学习率时，我们可以使用 <code>np.arange</code> 生成一系列等间隔的学习率值。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-comment"># 生成一系列等间隔的学习率值</span><br>learning_rates = np.arange(<span class="hljs-number">0.01</span>, <span class="hljs-number">0.1</span>, <span class="hljs-number">0.01</span>)<br><br><span class="hljs-keyword">for</span> lr <span class="hljs-keyword">in</span> learning_rates:<br>    model = LogisticRegression(C=<span class="hljs-number">1</span>/lr)<br>    model.fit(X_train, y_train)<br>    score = model.score(X_test, y_test)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;Learning rate: <span class="hljs-subst">&#123;lr&#125;</span>, Accuracy: <span class="hljs-subst">&#123;score&#125;</span>&quot;</span>)<br><br></code></pre></td></tr></table></figure><h3 id="np-linspace-np-logspace"><a href="#np-linspace-np-logspace" class="headerlink" title="np.linspace()&#x2F;np.logspace()"></a>np.linspace()&#x2F;np.logspace()</h3><p><code>np.linspace(start, stop, num=50, endpoint=True, retstep=False, dtype=None)</code>：用于创建一个线性等分的数组&gt;在绘制模型的损失曲线或准确率曲线时，我们需要在一定范围内均匀地取一些点作为横坐标。这时候可以使用 np.linspace 生成一系列等间隔的训练轮数作为画图用的横坐标</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-comment"># 假设我们训练了 100 轮，我们想以 10 为轮数间隔画图</span><br>epochs = np.linspace(<span class="hljs-number">1</span>, <span class="hljs-number">100</span>, <span class="hljs-number">10</span>)<br><span class="hljs-comment"># losses为记录好的损失变化数组</span><br>plt.plot(epochs, losses)<br>plt.xlabel(<span class="hljs-string">&#x27;Epochs&#x27;</span>)<br>plt.ylabel(<span class="hljs-string">&#x27;Loss&#x27;</span>)<br>plt.show()<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><figcaption><span>stop, num</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs np.logspace(start,"><br>```py<br># 生成一系列对数间隔的正则化参数 C 值<br>C_values = np.logspace(-3, 3, 7)<br><br>for C in C_values:<br>    model = SVC(C=C)<br>    model.fit(X_train, y_train)<br>    score = model.score(X_test, y_test)<br>    print(f&quot;C: &#123;C&#125;, Accuracy: &#123;score&#125;&quot;)<br></code></pre></td></tr></table></figure><h3 id="np-random-normal"><a href="#np-random-normal" class="headerlink" title="np.random.normal()"></a>np.random.normal()</h3><p><code>np.random.normal(loc=0.0, scale=1.0, size=None)</code>：用于生成服从正态分布的随机数数组，loc 是均值（默认为 0），scale 是标准差（默认为 1），size 是数组的形状（接受一个<strong>元组</strong>）</p><p>常常用于权重的初始化</p><p>快速生成可以直接用</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-comment"># 0-1 连续均匀分布</span><br>np.random.rand(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>)<br></code></pre></td></tr></table></figure><h3 id="np-ones-元组-np-zeros-元组"><a href="#np-ones-元组-np-zeros-元组" class="headerlink" title="np.ones(元组)&#x2F;np.zeros(元组)"></a>np.ones(元组)&#x2F;np.zeros(元组)</h3><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs py">np.ones((<span class="hljs-number">2</span>, <span class="hljs-number">3</span>))<br><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">array([[1., 1., 1.],</span><br><span class="hljs-string">       [1., 1., 1.]])</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br></code></pre></td></tr></table></figure><h1 id="统计与属性"><a href="#统计与属性" class="headerlink" title="统计与属性"></a>统计与属性</h1><p>以下是对 NumPy 中常用统计和属性相关函数用法的总结：主要明白两点基本原则</p><ul><li>shape，ndim，size是属性，不加括号</li><li>凡是按照轴操作的函数，操作完后都会减少一个维度</li></ul><h3 id="尺寸相关"><a href="#尺寸相关" class="headerlink" title="尺寸相关"></a>尺寸相关</h3><h4 id="np-shape"><a href="#np-shape" class="headerlink" title="np.shape"></a><code>np.shape</code></h4><ul><li><strong>功能</strong>：返回一个元组，表示数组形状。</li></ul><h4 id="arr-ndim"><a href="#arr-ndim" class="headerlink" title="arr.ndim"></a><code>arr.ndim</code></h4><ul><li><strong>功能</strong>：返回一个整数表示数组维度。</li></ul><h4 id="arr-size"><a href="#arr-size" class="headerlink" title="arr.size"></a><code>arr.size</code></h4><ul><li><strong>功能</strong>：返回一个整数表示数组元素个数</li></ul><h3 id="最值"><a href="#最值" class="headerlink" title="最值"></a>最值</h3><h4 id="np-max-arr-axis-和-np-min-arr-axis"><a href="#np-max-arr-axis-和-np-min-arr-axis" class="headerlink" title="np.max(arr,axis=?) 和 np.min(arr,axis=?)"></a><code>np.max(arr,axis=?)</code> 和 <code>np.min(arr,axis=?)</code></h4><ul><li><p><strong>功能</strong>：分别返回数组中的最大值和最小值。可以通过 <code>axis</code> 参数指定在哪个轴上进行操作。</p></li><li><p><strong>易错</strong>：<code>axis=0</code> ，<code>axis=1</code> 操作后数组的维度会减少，返回的是一维数组。</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><br>arr = np.array([[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>], <br>                [<span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>]])<br><br><span class="hljs-comment"># 不指定 axis，返回整个数组的最值</span><br>max_val = np.<span class="hljs-built_in">max</span>(arr)<br>min_val = np.<span class="hljs-built_in">min</span>(arr)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;整个数组最大值: <span class="hljs-subst">&#123;max_val&#125;</span>，类型: <span class="hljs-subst">&#123;<span class="hljs-built_in">type</span>(max_val)&#125;</span>&quot;</span>)  <span class="hljs-comment"># 整个数组最大值: 6，类型: &lt;class &#x27;numpy.int32&#x27;&gt;</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;整个数组最小值: <span class="hljs-subst">&#123;min_val&#125;</span>，类型: <span class="hljs-subst">&#123;<span class="hljs-built_in">type</span>(min_val)&#125;</span>&quot;</span>)  <span class="hljs-comment"># 整个数组最小值: 1，类型: &lt;class &#x27;numpy.int32&#x27;&gt;</span><br><br><span class="hljs-comment"># 指定 axis=0，按列求最值,降低arr一个维度</span><br>max_col = np.<span class="hljs-built_in">max</span>(arr, axis=<span class="hljs-number">0</span>)<br>min_col = np.<span class="hljs-built_in">min</span>(arr, axis=<span class="hljs-number">0</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;按列最大值: <span class="hljs-subst">&#123;max_col&#125;</span>， <span class="hljs-subst">&#123;np.shape(max_col)&#125;</span>&quot;</span>)  <span class="hljs-comment"># 按列最大值: [4 5 6]， (3,)</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;按列最小值: <span class="hljs-subst">&#123;min_col&#125;</span>， <span class="hljs-subst">&#123;np.shape(min_col)&#125;</span>&quot;</span>)  <span class="hljs-comment"># 按列最小值: [1 2 3]， (3,)</span><br><br><span class="hljs-comment"># 指定 axis=1，按行求最值，降低arr一个维度</span><br>max_row = np.<span class="hljs-built_in">max</span>(arr, axis=<span class="hljs-number">1</span>)<br>min_row = np.<span class="hljs-built_in">min</span>(arr, axis=<span class="hljs-number">1</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;按行最大值: <span class="hljs-subst">&#123;max_row&#125;</span>， <span class="hljs-subst">&#123;np.shape(max_row)&#125;</span>&quot;</span>)  <span class="hljs-comment"># 按行最大值: [3 6]， (2,)</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;按行最小值: <span class="hljs-subst">&#123;min_row&#125;</span>， <span class="hljs-subst">&#123;np.shape(min_row)&#125;</span>&quot;</span>)  <span class="hljs-comment"># 按行最小值: [1 4]， (2,)</span><br></code></pre></td></tr></table></figure><h3 id="平均求和标准差"><a href="#平均求和标准差" class="headerlink" title="平均求和标准差"></a>平均求和标准差</h3><h4 id="np-average-arr-axis-weights-arr"><a href="#np-average-arr-axis-weights-arr" class="headerlink" title="np.average(arr,axis=?,weights=?arr)"></a><code>np.average(arr,axis=?,weights=?arr)</code></h4><ul><li><strong>功能</strong>：计算数组的(加权)平均值。可通过 <code>axis</code> 参数指定计算轴，<code>weights</code> 参数指定权重。<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><br>arr = np.array([[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>], <br>                [<span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>]])<br>weights = np.array([<span class="hljs-number">0.2</span>, <span class="hljs-number">0.3</span>, <span class="hljs-number">0.5</span>])<br><br><span class="hljs-comment"># 不指定 axis，计算整个数组的加权平均</span><br>avg = np.average(arr)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;整个数组平均值: <span class="hljs-subst">&#123;avg&#125;</span>，类型: <span class="hljs-subst">&#123;<span class="hljs-built_in">type</span>(avg)&#125;</span>&quot;</span>)  <span class="hljs-comment"># 输出浮点数 3.5</span><br><br><span class="hljs-comment"># 指定 axis=0，按列计算加权平均</span><br>avg_col = np.average(arr, axis=<span class="hljs-number">0</span>, weights=weights)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;按列加权平均值: <span class="hljs-subst">&#123;avg_col&#125;</span>，类型: <span class="hljs-subst">&#123;<span class="hljs-built_in">type</span>(avg_col)&#125;</span>，形状: <span class="hljs-subst">&#123;np.shape(avg_col)&#125;</span>&quot;</span>)  <span class="hljs-comment"># 输出一维数组</span><br><br><span class="hljs-comment"># 指定 axis=1，按行计算加权平均</span><br>avg_row = np.average(arr, axis=<span class="hljs-number">1</span>, weights=weights)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;按行加权平均值: <span class="hljs-subst">&#123;avg_row&#125;</span>，类型: <span class="hljs-subst">&#123;<span class="hljs-built_in">type</span>(avg_row)&#125;</span>，形状: <span class="hljs-subst">&#123;np.shape(avg_row)&#125;</span>&quot;</span>)  <span class="hljs-comment"># 输出一维数组</span><br></code></pre></td></tr></table></figure></li><li><strong>易错点</strong>：若指定 <code>weights</code>，其形状要与计算轴的形状匹配。</li></ul><p>另外，不加权重的时候可以直接用<code>np.mean(arr,axis=?)</code></p><h4 id="np-sum-arr-axis"><a href="#np-sum-arr-axis" class="headerlink" title="np.sum(arr,axis=?)"></a><code>np.sum(arr,axis=?)</code></h4><ul><li><strong>功能</strong>：计算数组元素的总和。可通过 <code>axis</code> 参数指定计算轴。</li></ul><h4 id="np-std"><a href="#np-std" class="headerlink" title="np.std"></a><code>np.std</code></h4><ul><li><strong>功能</strong>：计算数组的标准差。可通过 <code>axis</code> 参数指定计算轴。</li></ul><p>这里标准差涉及到总体标准差和样本标准差的区别，np.std提供了一个一接口调整自由度</p><p>总体标准差用<br>$$<br>\sigma &#x3D; \sqrt{\frac{\sum_{i &#x3D; 1}^{N}(x_i - \mu)^2}{N}}<br>$$</p><p>在 <code>np.std</code> 函数中，当 <code>ddof</code>（Delta Degrees of Freedom，自由度）参数设置为 0 时，计算的就是总体标准差。示例代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><br><span class="hljs-comment"># 定义一个数组</span><br>data = np.array([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>])<br><br><span class="hljs-comment"># 计算总体标准差</span><br>population_std = np.std(data, ddof=<span class="hljs-number">0</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;总体标准差:&quot;</span>, population_std)<br></code></pre></td></tr></table></figure><p>样本标准差用<br>$$<br>s &#x3D; \sqrt{\frac{\sum_{i &#x3D; 1}^{n}(x_i - \bar{x})^2}{n - 1}}<br>$$<br>在 <code>np.std</code> 函数中，把 <code>ddof</code> 参数设置为 1 时，计算的就是样本标准差。</p><h1 id="形状与变化"><a href="#形状与变化" class="headerlink" title="形状与变化"></a>形状与变化</h1><p>注意：本章节中涉及的所有操作都是在创建<strong>视图</strong></p><ul><li>视图：是原数组的一个引用，与原数组共享底层数据存储。对视图的修改会直接反映到原数组上，反之亦然。<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs py">b = a.reshape(<span class="hljs-number">3</span>,<span class="hljs-number">4</span>)<br><span class="hljs-comment"># 此时a不变</span><br><br>b[<span class="hljs-number">0</span>,<span class="hljs-number">0</span>]=<span class="hljs-number">100</span> <span class="hljs-comment"># 或者b[0][0]=100</span><br><span class="hljs-comment"># 此时a[0,0]也会变</span><br><br></code></pre></td></tr></table></figure></li></ul><h4 id="np-expand-dims-arr-axis"><a href="#np-expand-dims-arr-axis" class="headerlink" title="np.expand_dims(arr,axis=?)"></a><code>np.expand_dims(arr,axis=?)</code></h4><ul><li><p><strong>功能</strong>：在数组的指定位置插入新的轴，从而增加数组的维度。新<code>axis</code>插入后，原来位于该位置的轴，以及之后的轴的编号都会依次向后移动一位。<br>例如：</p></li><li><p>对于一维数组 <code>arr = np.array([1, 2, 3])</code>，其形状为 <code>(3,)</code>。</p><ul><li>当 <code>axis = 0</code> 时，在第 0 个位置插入新轴，原来的元素都在新轴的下一级，所以形状变为 <code>(1, 3)</code>。</li><li>当 <code>axis = 1</code> 时，在第 1 个位置插入新轴，原来的每个元素都被单独放在新轴的一个位置，形状变为 <code>(3, 1)</code>。</li></ul></li><li><p><strong>示例</strong>：在深度学习中，很多模型要求输入具有 <code>(batch_size, channels, height, width)</code> 的格式。当我们有一个单张图像（假设为灰度图），其形状为 <code>(height, width)</code> 时，需要将其扩展为 <code>(1, 1, height, width)</code> 以满足模型输入要求。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><br><span class="hljs-comment"># 模拟一张 28x28 的灰度图像</span><br>image = np.random.rand(<span class="hljs-number">28</span>, <span class="hljs-number">28</span>)<br><span class="hljs-comment"># 扩展维度以匹配模型输入</span><br>input_image = np.expand_dims(np.expand_dims(image, axis=<span class="hljs-number">0</span>), axis=<span class="hljs-number">0</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;原图像形状:&quot;</span>, image.shape)  <span class="hljs-comment"># 输出: (28, 28)</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;扩展维度后的图像形状:&quot;</span>, input_image.shape)  <span class="hljs-comment"># 输出: (1, 1, 28, 28)</span><br></code></pre></td></tr></table></figure></li></ul><h4 id="np-squeeze"><a href="#np-squeeze" class="headerlink" title="np.squeeze"></a><code>np.squeeze</code></h4><ul><li><strong>功能</strong>：从数组中移除所有长度为 1 的轴。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><br><span class="hljs-comment"># 创建带有单维度轴的数组</span><br>arr = np.array([[[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]]])<br>squeezed_arr = np.squeeze(arr)<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;原数组形状:&quot;</span>, arr.shape)  <span class="hljs-comment"># 输出: (1, 1, 3)</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;压缩后数组形状:&quot;</span>, squeezed_arr.shape)  <span class="hljs-comment"># 输出: (3,)</span><br></code></pre></td></tr></table></figure><ul><li><strong>机器学习实战代码示例</strong>：在模型预测后，输出结果可能会带有不必要的单维度轴。例如，一个模型对单样本进行预测，输出形状为 <code>(1, 10)</code>，我们可以使用 <code>np.squeeze</code> 去掉多余的维度，得到 <code>(10,)</code> 的结果。</li></ul><h4 id="np-reshape-元组-或-arr-reshape-元组"><a href="#np-reshape-元组-或-arr-reshape-元组" class="headerlink" title="np.reshape((元组)) 或 arr.reshape((元组))"></a><code>np.reshape((元组))</code> 或 <code>arr.reshape((元组))</code></h4><ul><li><strong>功能</strong>：改变数组的形状，但保持元素总数不变。</li><li>由于python可以自动解包，不传入元组，直接<code>arr.reshape(n,m)</code>也行<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><br>arr = np.arange(<span class="hljs-number">12</span>)<br><span class="hljs-comment"># 使用 np.reshape</span><br>reshaped_arr_1 = np.reshape(arr, (<span class="hljs-number">3</span>, <span class="hljs-number">4</span>))<br><span class="hljs-comment"># 使用 arr.reshape</span><br>reshaped_arr_2 = arr.reshape((<span class="hljs-number">3</span>, <span class="hljs-number">4</span>))<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;原数组形状:&quot;</span>, arr.shape)  <span class="hljs-comment"># 输出: (12,)</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;使用 np.reshape 后的形状:&quot;</span>, reshaped_arr_1.shape)  <span class="hljs-comment"># 输出: (3, 4)</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;使用 arr.reshape 后的形状:&quot;</span>, reshaped_arr_2.shape)  <span class="hljs-comment"># 输出: (3, 4)</span><br></code></pre></td></tr></table></figure></li></ul><p>注意：</p><ul><li>reshape函数返回一个原数组的视图，不会使原数组形状改变。</li><li>可以用-1代替某个不想计算的维度，用于自动计算，如果只使用一个-1相当于flatten</li></ul><h4 id="arr-T"><a href="#arr-T" class="headerlink" title="arr.T"></a><code>arr.T</code></h4><ul><li><strong>功能</strong>：对于二维数组，交换行和列；对于更高维数组，反转维度顺序。</li><li><strong>一般代码示例</strong>：<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><br>arr = np.array([[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>], [<span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>]])<br>transposed_arr = arr.T<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;原数组形状:&quot;</span>, arr.shape)  <span class="hljs-comment"># 输出: (2, 3)</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;转置后数组形状:&quot;</span>, transposed_arr.shape)  <span class="hljs-comment"># 输出: (3, 2)</span><br></code></pre></td></tr></table></figure></li></ul><h4 id="np-transpose"><a href="#np-transpose" class="headerlink" title="np.transpose"></a><code>np.transpose</code></h4><ul><li><strong>功能</strong>：可以指定轴的新顺序来对数组进行转置，比 <code>arr.T</code> 更灵活。<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><br>arr = np.arange(<span class="hljs-number">24</span>).reshape((<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>))<br><span class="hljs-comment"># 指定轴的新顺序进行转置</span><br>transposed_arr = np.transpose(arr, (<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">2</span>))<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;原数组形状:&quot;</span>, arr.shape)  <span class="hljs-comment"># 输出: (2, 3, 4)</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;转置后数组形状:&quot;</span>, transposed_arr.shape)  <span class="hljs-comment"># 输出: (3, 2, 4)</span><br></code></pre></td></tr></table></figure></li><li><strong>机器学习示例</strong>：在深度学习中，不同的深度学习框架对数据的存储格式可能不同。例如，有些框架要求图像数据的格式为 <code>(channels, height, width)</code>，而我们的数据可能是 <code>(height, width, channels)</code> 格式，这时可以使用 <code>np.transpose</code> 进行转换。<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><br><span class="hljs-comment"># 模拟一张 28x28 的 RGB 图像，格式为 (height, width, channels)</span><br>image = np.random.rand(<span class="hljs-number">28</span>, <span class="hljs-number">28</span>, <span class="hljs-number">3</span>)<br><span class="hljs-comment"># 转换为 (channels, height, width) 格式</span><br>transposed_image = np.transpose(image, (<span class="hljs-number">2</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>))<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;原图像形状:&quot;</span>, image.shape)  <span class="hljs-comment"># 输出: (28, 28, 3)</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;转置后图像形状:&quot;</span>, transposed_image.shape)  <span class="hljs-comment"># 输出: (3, 28, 28)</span><br></code></pre></td></tr></table></figure></li></ul><h1 id="分解与组合"><a href="#分解与组合" class="headerlink" title="分解与组合"></a>分解与组合</h1><h2 id="切片和索引"><a href="#切片和索引" class="headerlink" title="切片和索引"></a>切片和索引</h2><p>总体上来说，切片的方式大致是</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs py">arr[row,col]<br></code></pre></td></tr></table></figure><p>逗号前对行操作，逗号后对列操作，我们先以行操作为例子。</p><table><thead><tr><th>索引或切片方式</th><th>代码示例</th><th>功能说明</th><th>是否返回视图</th></tr></thead><tbody><tr><td>取单行</td><td><code>arr[0]</code></td><td>取数组的第 0 行</td><td>是</td></tr><tr><td>取单元素</td><td><code>arr[0, 1]</code></td><td>取数组第 0 行第 1 列的元素</td><td>否（返回单个元素值）</td></tr><tr><td>连续行切片</td><td><code>arr[0:3]</code></td><td>取数组的第 1 - 3 行（索引 0 到 2）</td><td>是</td></tr><tr><td>离散行索引</td><td><code>arr[[0, 3]]</code></td><td>取数组的第 1 行和第 4 行（索引 0 和 3）</td><td>否（返回副本）</td></tr><tr><td>行从某行到最后</td><td><code>arr[3:]</code></td><td>从数组中提取第 4 行（索引为 3）开始直至最后一行的元素</td><td>视图</td></tr><tr><td>行从开始到某行（开）</td><td><code>arr[:3]</code></td><td>相当于<code>arr[0:3]</code></td><td>视图</td></tr><tr><td>行带步长切片</td><td><code>arr[1: 4: 2]</code></td><td>从数组中提取第 2 行至第 4 行（对应索引 1 到 3）的元素，按步长 2 选取，即选取第 2 行和第 4 行</td><td>视图</td></tr></tbody></table><p>想要结合列进行索引和切片，在逗号后进行列的操作即可</p><table><thead><tr><th>索引或切片类型</th><th>代码示例</th><th>功能详细说明</th><th>返回结果性质</th></tr></thead><tbody><tr><td>行和列连续切片</td><td><code>arr[1:3, 1]</code></td><td>从数组中提取第 2 行至第 3 行（对应索引 1 到 2）里第 2 列（索引为 1）的元素</td><td>视图</td></tr><tr><td>行和列离散索引</td><td><code>arr[[1,3], [0]]</code></td><td>从数组中提取第 2 行和第 4 行（对应索引 1 和 3）里第 1 列（索引为 0）的元素</td><td>副本</td></tr><tr><td>行和列连续范围切片</td><td><code>arr[:3, 1:3]</code></td><td>从数组中提取第 1 行至第 3 行（对应索引 0 到 2）里第 2 列至第 3 列（对应索引 1 到 2）的元素</td><td>视图</td></tr><tr><td>行和列带步长切片</td><td><code>arr[1:4:2, 0:3:2]</code></td><td>从数组中提取第 2 行至第 4 行（对应索引 1 到 3），按步长 2 选取；同时提取第 1 列至第 3 列（对应索引 0 到 2），按步长 2 选取相应元素</td><td>视图</td></tr><tr><td>冒号索引列</td><td><code>arr[:,1]</code></td><td>从数组中提取所有行里第 2 列（索引为 1）的元素</td><td>视图</td></tr></tbody></table><p>总体来说，涉及离散索引（如使用列表或数组指定不连续的索引）时通常返回副本，而连续切片操作大多返回视图。可以通过检查数组的 <code>base</code> 属性来判断返回的是视图还是副本，如果 <code>arr.base</code> 是原数组，则 <code>arr</code> 是视图；如果 <code>arr.base</code> 为 <code>None</code>，则 <code>arr</code> 是副本。</p><p>切片和索引在机器学习中用的是很多的,举几个常用例子</p><h3 id="数据集划分"><a href="#数据集划分" class="headerlink" title="数据集划分"></a>数据集划分</h3><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs py">train_size = <span class="hljs-built_in">int</span>(<span class="hljs-built_in">len</span>(data)*<span class="hljs-number">0.8</span>)<br>val_size = <span class="hljs-built_in">int</span>(<span class="hljs-built_in">len</span>(data)*<span class="hljs-number">0.1</span>)<br><br>train_data = data[:train_size]<br>val_data = data[train_size:train_size+val_size]<br>test_data = data[train_size+val_size:]<br></code></pre></td></tr></table></figure><h3 id="特征选择"><a href="#特征选择" class="headerlink" title="特征选择"></a>特征选择</h3><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs py">data = np.random.rand(<span class="hljs-number">100</span>,<span class="hljs-number">5</span>)<br>X = data[:,[<span class="hljs-number">0</span>,<span class="hljs-number">2</span>]]<br></code></pre></td></tr></table></figure><h3 id="批量训练"><a href="#批量训练" class="headerlink" title="批量训练"></a>批量训练</h3><p>使用批量梯度下降算法进行模型训练，需要将数据集划分为多个小批量。切片操作可以实现批量数据的提取。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-comment"># 批量大小</span><br>batch_size = <span class="hljs-number">10</span><br><br><span class="hljs-comment"># 遍历每个批量</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(data), batch_size):<br>    batch_data = data[i:i + batch_size]<br>    batch_labels = labels[i:i + batch_size]<br>    <span class="hljs-comment"># 这里可以进行模型训练操作</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;第 <span class="hljs-subst">&#123;i // batch_size + <span class="hljs-number">1</span>&#125;</span> 个批量的数据形状:&quot;</span>, batch_data.shape)<br></code></pre></td></tr></table></figure><h2 id="拼接"><a href="#拼接" class="headerlink" title="拼接"></a>拼接</h2><h3 id="维度不变：拼接"><a href="#维度不变：拼接" class="headerlink" title="维度不变：拼接"></a>维度不变：拼接</h3><p><code>np.concatenate</code> 函数用于沿着指定的轴将多个数组连接在一起，要求除了指定轴之外的其他轴的形状必须一致</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br>np.concatenate((arr1, arr2, ...), axis=<span class="hljs-number">0</span>)<br></code></pre></td></tr></table></figure><p><img src="https://www.freeimg.cn/i/2025/02/07/67a5c241995fd.webp" alt="1738916424602.jpg"></p><p>可以用于特征拼接或者数据集合并等操作</p><h3 id="维度增加：堆叠"><a href="#维度增加：堆叠" class="headerlink" title="维度增加：堆叠"></a>维度增加：堆叠</h3><p><code>np.stack</code> 函数用于沿着新的轴将多个数组堆叠在一起，要求所有输入数组的形状必须完全相同。<br><code>axis</code>用于指定新的，用于堆叠的轴的方向</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br>np.stack((a1, a2, ...), axis=<span class="hljs-number">0</span>)<br></code></pre></td></tr></table></figure><p>在计算机视觉中，有时需要将多个单通道的图像合并成多通道图像。例如，将红、绿、蓝三个单通道的图像合并成一个 RGB 图像。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><br><span class="hljs-comment"># 模拟三个单通道图像</span><br>red_channel = np.random.rand(<span class="hljs-number">256</span>, <span class="hljs-number">256</span>)<br>green_channel = np.random.rand(<span class="hljs-number">256</span>, <span class="hljs-number">256</span>)<br>blue_channel = np.random.rand(<span class="hljs-number">256</span>, <span class="hljs-number">256</span>)<br><br><span class="hljs-comment"># 沿着新的轴（第 2 轴）堆叠通道</span><br>rgb_image = np.stack((red_channel, green_channel, blue_channel), axis=<span class="hljs-number">2</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;合并后 RGB 图像的形状:&quot;</span>, rgb_image.shape)<br></code></pre></td></tr></table></figure><h1 id="筛选和过滤"><a href="#筛选和过滤" class="headerlink" title="筛选和过滤"></a>筛选和过滤</h1><h3 id="布尔数组直接筛选"><a href="#布尔数组直接筛选" class="headerlink" title="布尔数组直接筛选"></a>布尔数组直接筛选</h3><p>用numpy写比for循环快得多，NumPy 的布尔索引筛选耗时远远小于 for 循环筛选耗时，并且随着数组规模的增大，这种性能差距会更加明显。这是因为 NumPy 的向量化操作能够并行处理数组元素，而 for 循环是串行执行的，效率较低。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><br><span class="hljs-comment"># 创建一个示例数组</span><br>arr = np.array([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>])<br><br><span class="hljs-comment"># 创建布尔数组，筛选出大于 5 的元素</span><br>condition = arr &gt; <span class="hljs-number">5</span><br>filtered_arr = arr[condition]<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;原数组:&quot;</span>, arr)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;布尔数组:&quot;</span>, condition)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;筛选出大于 5 的元素:&quot;</span>, filtered_arr)<br><br></code></pre></td></tr></table></figure><h3 id="三参数np-where"><a href="#三参数np-where" class="headerlink" title="三参数np.where()"></a>三参数<code>np.where()</code></h3><p>三参数形式：<code>np.where(condition, x, y)</code><br>参数：</p><ul><li>condition：同样是一个布尔数组，用于指定筛选条件。</li><li>x 和 y：可以是数组或者标量。当 condition 中的元素为 True 时，结果数组中对应位置的值取自 x；当 condition 中的元素为 False 时，结果数组中对应位置的值取自 y。</li><li>返回值：返回一个新的数组，其形状与 condition 相同，数组中的元素根据条件从 x 或 y 中选取。<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-comment"># 不满足条件的赋值，将 &lt;=50 的替换为 -1</span><br>np.where(arr &gt; <span class="hljs-number">50</span>, arr, -<span class="hljs-number">1</span>)<br></code></pre></td></tr></table></figure>这一函数一般用于处理缺失值或者数据二值化</li></ul><p>数据集中可能存在缺失值（如 NaN），可以使用 np.where 将缺失值替换为特定的值</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs py">cleaned_data = np.where(np.isnan(data), mean_value, data)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;处理后的数据:&quot;</span>, cleaned_data)<br></code></pre></td></tr></table></figure><p>在某些分类任务中，需要将连续型数据转换为二值数据（0 或 1），可以根据特定的阈值使用 np.where 进行转换。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-comment"># 模拟特征数据</span><br>features = np.array([<span class="hljs-number">0.2</span>, <span class="hljs-number">0.7</span>, <span class="hljs-number">0.1</span>, <span class="hljs-number">0.9</span>, <span class="hljs-number">0.4</span>])<br><span class="hljs-comment"># 根据阈值 0.5 进行二值化</span><br>binary_features = np.where(features &gt; <span class="hljs-number">0.5</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;二值化后的特征:&quot;</span>, binary_features)<br></code></pre></td></tr></table></figure><h1 id="矩阵与运算"><a href="#矩阵与运算" class="headerlink" title="矩阵与运算"></a>矩阵与运算</h1><p>以下是两个表格，分别总结了 NumPy 常见运算和矩阵运算的用法：</p><h3 id="表格一：NumPy-常见运算总结"><a href="#表格一：NumPy-常见运算总结" class="headerlink" title="表格一：NumPy 常见运算总结"></a>表格一：NumPy 常见运算总结</h3><table><thead><tr><th>运算类型</th><th>函数&#x2F;操作符</th><th>功能描述</th><th>示例代码</th></tr></thead><tbody><tr><td>逐元素算术运算</td><td><code>+</code>、<code>-</code>、<code>*</code>、<code>/</code></td><td>对数组进行四则运算</td><td><code>arr * 2</code></td></tr><tr><td></td><td><code>**</code></td><td>对数组进行幂运算</td><td><code>arr ** 2</code></td></tr><tr><td></td><td><code>np.sqrt</code></td><td>对数组元素开方</td><td><code>np.sqrt(arr)</code></td></tr><tr><td></td><td><code>np.log</code></td><td>对数组元素求自然对数</td><td><code>np.log(arr)</code></td></tr><tr><td></td><td><code>np.mod</code></td><td>对数组元素取模，可指定多个被除数</td><td><code>np.mod(arr, 3)</code><br><code>np.mod(arr, arr - 5)</code></td></tr><tr><td>条件运算</td><td><code>np.minimum</code></td><td>将数组中超过指定值的元素替换为该值</td><td><code>np.minimum(arr, 5)</code></td></tr><tr><td></td><td><code>np.maximum</code></td><td>将数组中低于指定值的元素替换为该值</td><td><code>np.maximum(arr, 5)</code></td></tr><tr><td></td><td><code>np.round</code></td><td>对数组元素进行四舍五入</td><td><code>np.round(np.sqrt(arr), 2)</code></td></tr><tr><td></td><td><code>np.floor</code></td><td>对数组元素向下取整</td><td><code>np.floor(np.sqrt(arr))</code></td></tr><tr><td></td><td><code>np.ceil</code></td><td>对数组元素向上取整</td><td><code>np.ceil(np.sqrt(arr))</code></td></tr><tr><td>广播机制</td><td>操作符结合不同形状数组</td><td>较小数组在较大数组上广播以适配形状</td><td><code>a + [1, 2, 3, 4]</code><br><code>a + [[1], [2], [3]]</code><br><code>np.mod(a, [1, 2, 3, 4])</code></td></tr></tbody></table><h3 id="表格二：NumPy-矩阵运算总结"><a href="#表格二：NumPy-矩阵运算总结" class="headerlink" title="表格二：NumPy 矩阵运算总结"></a>表格二：NumPy 矩阵运算总结</h3><table><thead><tr><th>运算类型</th><th>函数&#x2F;操作符</th><th>功能描述</th><th>示例代码</th><th>高维差异说明</th></tr></thead><tbody><tr><td>矩阵乘法</td><td><code>np.dot</code></td><td>计算两个数组的点积，常用于矩阵乘法</td><td><code>np.dot(a, b)</code><br><code>a.dot(b)</code></td><td>处理高维数组时规则与 <code>matmul</code> 不同</td></tr><tr><td></td><td><code>np.matmul</code>、<code>@</code></td><td>计算两个数组的矩阵乘积</td><td><code>np.matmul(a, b)</code><br><code>a @ b</code></td><td>会将矩阵像元素一样堆叠在一起广播</td></tr><tr><td>点积</td><td><code>np.vdot</code></td><td>计算两个数组的点积</td><td><code>np.vdot(a, a)</code></td><td>等价于 <code>np.sum(a * a)</code></td></tr><tr><td>内积</td><td><code>np.inner</code></td><td>计算两个数组的内积</td><td><code>np.inner(a, a)</code></td><td>等价于 <code>a.dot(a.T)</code></td></tr><tr><td>行列式</td><td><code>np.linalg.det</code></td><td>计算方阵的行列式</td><td><code>np.linalg.det(c)</code></td><td>-</td></tr><tr><td>逆矩阵</td><td><code>np.linalg.inv</code></td><td>计算方阵的逆矩阵</td><td><code>np.linalg.inv(c)</code></td><td>-</td></tr></tbody></table><h3 id="关于维度的说明"><a href="#关于维度的说明" class="headerlink" title="关于维度的说明"></a>关于维度的说明</h3><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-comment"># 目标向量 y，形状为 (4, 1)</span><br>y = np.array([[<span class="hljs-number">3</span>], <br>              [<span class="hljs-number">7</span>], <br>              [<span class="hljs-number">11</span>], <br>              [<span class="hljs-number">15</span>]])<br><br><span class="hljs-comment"># 目标向量 y，形状为 (4,)</span><br>y = np.array([<span class="hljs-number">3</span>, <span class="hljs-number">7</span>, <span class="hljs-number">11</span>, <span class="hljs-number">15</span>])<br><br><br> 目标向量 y，形状为 (<span class="hljs-number">1</span>, <span class="hljs-number">4</span>)<br>y = np.array([[<span class="hljs-number">3</span>, <span class="hljs-number">7</span>, <span class="hljs-number">11</span>, <span class="hljs-number">15</span>]])<br><br></code></pre></td></tr></table></figure><p>一般而言使用中间的一维向量参与到矩阵运算中即可，不用特意定义好行向量或者列向量，因为广播机制会自动把一维向量赋予行向量或列向量的形式。最后的运算结果如果是向量则为（n，）如果是数值就是数值</p><p>如果使用1.3的定义方式也可，但是如果最后的计算结果为数值m的话，事实上会得到<code>[[m]]</code>的形式，需要手动取arr[0,0]获取数值参与其他只接受数值的运算！</p>]]></content>
    
    
    <categories>
      
      <category>编程语言</category>
      
    </categories>
    
    
    <tags>
      
      <tag>编程语言</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>matlab</title>
    <link href="/2025/03/21/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/MATLAB%E7%AC%94%E8%AE%B0/"/>
    <url>/2025/03/21/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/MATLAB%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="1-基本语法"><a href="#1-基本语法" class="headerlink" title="1 基本语法"></a>1 基本语法</h2><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs matlab"><span class="hljs-comment">%变量无需声明</span><br>x = <span class="hljs-number">5</span>;        <span class="hljs-comment">% 赋值一个标量  </span><br>y = [<span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span>];  <span class="hljs-comment">% 赋值一个行向量  </span><br>z = [<span class="hljs-number">1</span>; <span class="hljs-number">2</span>; <span class="hljs-number">3</span>]; <span class="hljs-comment">% 赋值一个列向量  </span><br>A = [<span class="hljs-number">1</span> <span class="hljs-number">2</span>; <span class="hljs-number">3</span> <span class="hljs-number">4</span>]; <span class="hljs-comment">% 赋值一个矩阵</span><br><span class="hljs-comment">%矩阵运算</span><br>B = A * [<span class="hljs-number">1</span> <span class="hljs-number">1</span>; <span class="hljs-number">0</span> <span class="hljs-number">1</span>]; <span class="hljs-comment">% 矩阵乘法  </span><br>C = A + A; <span class="hljs-comment">% 矩阵加法  </span><br>D = A .* A; <span class="hljs-comment">% 矩阵点乘（对应元素相乘）  </span><br>E = A&#x27;; <span class="hljs-comment">% 矩阵转置</span><br><span class="hljs-comment">% 用圆括号进行数组索引</span><br>element = A(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>); <span class="hljs-comment">% 获取矩阵A第一行第二列的元素  </span><br>A(<span class="hljs-number">2</span>, :) = [<span class="hljs-number">5</span> <span class="hljs-number">6</span>]; <span class="hljs-comment">% 替换矩阵A第二行的所有元素</span><br><span class="hljs-comment">%for循环</span><br><span class="hljs-keyword">for</span> <span class="hljs-built_in">i</span> = <span class="hljs-number">1</span>:<span class="hljs-number">3</span>  <br>    <span class="hljs-built_in">disp</span>(<span class="hljs-built_in">i</span>); <span class="hljs-comment">% 显示i的值  </span><br><span class="hljs-keyword">end</span><br><span class="hljs-comment">% 条件语句</span><br><span class="hljs-keyword">if</span> x &gt; <span class="hljs-number">0</span>  <br>    <span class="hljs-built_in">disp</span>(<span class="hljs-string">&#x27;x is positive&#x27;</span>);  <br><span class="hljs-keyword">elseif</span> x &lt; <span class="hljs-number">0</span>  <br>    <span class="hljs-built_in">disp</span>(<span class="hljs-string">&#x27;x is negative&#x27;</span>);  <br><span class="hljs-keyword">else</span>  <br>    <span class="hljs-built_in">disp</span>(<span class="hljs-string">&#x27;x is zero&#x27;</span>);  <br><span class="hljs-keyword">end</span><br>----------------------------------------------<br><span class="hljs-comment">%建立一个函数</span><br><span class="hljs-comment">%函数定义通常放在一个.m文件中，文件名与函数名相同。</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">y</span> = <span class="hljs-title">my_function</span><span class="hljs-params">(x)</span>  </span><br>    y = x^<span class="hljs-number">2</span> + <span class="hljs-number">3</span>*x + <span class="hljs-number">2</span>; <span class="hljs-comment">% 计算并返回结果  </span><br><span class="hljs-keyword">end</span><br>result = my_function(<span class="hljs-number">5</span>); <span class="hljs-comment">% 调用函数，传入参数5  </span><br><span class="hljs-built_in">disp</span>(result); <span class="hljs-comment">% 显示结果</span><br><span class="hljs-comment">% 绘制简单图形</span><br>x = <span class="hljs-number">0</span>:<span class="hljs-number">0.01</span>:<span class="hljs-number">10</span>; <span class="hljs-comment">% 创建一个从0到10的向量，步长为0.01  </span><br>y = <span class="hljs-built_in">sin</span>(x); <span class="hljs-comment">% 计算x中每个元素的正弦值  </span><br><span class="hljs-built_in">plot</span>(x, y); <span class="hljs-comment">% 绘制图形  </span><br>xlabel(<span class="hljs-string">&#x27;x&#x27;</span>); <span class="hljs-comment">% x轴标签  </span><br>ylabel(<span class="hljs-string">&#x27;sin(x)&#x27;</span>); <span class="hljs-comment">% y轴标签  </span><br>title(<span class="hljs-string">&#x27;Plot of sin(x)&#x27;</span>); <span class="hljs-comment">% 图表标题</span><br></code></pre></td></tr></table></figure><h2 id="线性代数运算"><a href="#线性代数运算" class="headerlink" title="线性代数运算"></a>线性代数运算</h2><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs matlab"><span class="hljs-comment">% 生成矩阵</span><br>    <span class="hljs-comment">% 直接法</span><br>        a = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>;<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>;<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>];<br>    <span class="hljs-comment">% 冒号一维矩阵 a = 开始：步长：结束，步长为1可省略</span><br>        b = <span class="hljs-number">1</span>:<span class="hljs-number">1</span>:<span class="hljs-number">10</span>;  <span class="hljs-comment">% 1,2,...10</span><br>        b = <span class="hljs-number">1</span>:<span class="hljs-number">10</span>;  <span class="hljs-comment">%与上一个等价</span><br>    <span class="hljs-comment">% 函数生成</span><br>        <span class="hljs-comment">% linspace(开始，结束，元素个数)，等差生成指定元素数的一维矩阵，省略个数则生成100个</span><br>            c = <span class="hljs-built_in">linspace</span>(<span class="hljs-number">0</span>,<span class="hljs-number">10</span>,<span class="hljs-number">5</span>);<br>        <span class="hljs-comment">% 特殊矩阵</span><br>            e = <span class="hljs-built_in">eye</span>(<span class="hljs-number">4</span>);  <span class="hljs-comment">% eye(维数)单位阵 对角全为 1</span><br>            z = <span class="hljs-built_in">zeros</span>(<span class="hljs-number">1</span>,<span class="hljs-number">4</span>);  <span class="hljs-comment">% zeros(维数)全零阵 1行4列</span><br>            o = <span class="hljs-built_in">ones</span>(<span class="hljs-number">4</span>,<span class="hljs-number">1</span>);  <span class="hljs-comment">% ones(维数)全1阵 4行1列</span><br>            r = <span class="hljs-built_in">rand</span>(<span class="hljs-number">4</span>);  <span class="hljs-comment">% rand(维数)0~1分布随机阵</span><br>            rn = <span class="hljs-built_in">randn</span>(<span class="hljs-number">4</span>);  <span class="hljs-comment">% randn(维数)0均值Gaussian分布随机阵</span><br></code></pre></td></tr></table></figure><h2 id="执行结构"><a href="#执行结构" class="headerlink" title="执行结构"></a>执行结构</h2><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs matlab"><span class="hljs-comment">%选择结构</span><br>    <span class="hljs-comment">%if-elseif-else-end</span><br>        <span class="hljs-keyword">if</span> a&gt;<span class="hljs-number">0</span><br>            <span class="hljs-built_in">disp</span>(x);<br>        <span class="hljs-keyword">elseif</span> a==<span class="hljs-number">0</span><br>            <span class="hljs-built_in">disp</span>(a);<br>        <span class="hljs-keyword">else</span><br>            <span class="hljs-built_in">disp</span>(a<span class="hljs-number">-1</span>);<br>        <span class="hljs-keyword">end</span><br>        <br>    <span class="hljs-comment">%switch-case-otherwise-end</span><br>        <span class="hljs-keyword">switch</span> a<br>            <span class="hljs-keyword">case</span> <span class="hljs-number">0</span><br>                <span class="hljs-built_in">disp</span>(a);<br>            <span class="hljs-keyword">case</span> <span class="hljs-number">1</span><br>                <span class="hljs-built_in">disp</span>(a+<span class="hljs-number">1</span>);<br>            <span class="hljs-keyword">otherwise</span><br>                <span class="hljs-built_in">disp</span>(<span class="hljs-string">&#x27;aaa&#x27;</span>);<br>        <span class="hljs-keyword">end</span><br>        <br>    <span class="hljs-comment">%try-catch</span><br>        <span class="hljs-keyword">try</span><br>            z = x*y;<br>        <span class="hljs-keyword">catch</span><br>            z = x.*y;  <span class="hljs-comment">% 若try出错，则执行</span><br>        <span class="hljs-keyword">end</span><br>        <span class="hljs-built_in">disp</span>(z);<br>--------------------------------------------------<br><span class="hljs-comment">% 循环结构</span><br>    <span class="hljs-comment">% for 循环变量=初值:步长:终值 - end</span><br>    <span class="hljs-keyword">for</span> <span class="hljs-built_in">i</span>=<span class="hljs-number">0</span>:<span class="hljs-number">1</span>:<span class="hljs-number">10</span>  <span class="hljs-comment">% 步长为负，则初值大于终值</span><br>        <span class="hljs-built_in">disp</span>(<span class="hljs-built_in">i</span>);  <span class="hljs-comment">% 循环体内不可对循环变量做修改</span><br>    <span class="hljs-keyword">end</span><br>    <br>    <span class="hljs-comment">% while-end</span><br>    <span class="hljs-keyword">while</span> a&gt;<span class="hljs-number">2</span><br>        <span class="hljs-built_in">disp</span>(a);<br>        a = a<span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">end</span><br>----------------------------------------------------<br><span class="hljs-comment">%程序控制</span><br>    <span class="hljs-comment">%continue 跳过当次循环剩下语句，进入下一循环</span><br>    <span class="hljs-comment">%break 跳出当前循环</span><br>    <span class="hljs-comment">%return 跳出程序并返回</span><br></code></pre></td></tr></table></figure><h2 id="m文件"><a href="#m文件" class="headerlink" title=".m文件"></a>.m文件</h2><p>matlab写出的文件后缀为.m,可以大致分为函数文件和命令文件，类似于头文件和main.c的关系。<br>使用示例：</p><p>假设你有一个名为addNumbers.m的函数文件，内容如下：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs matlab"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sum</span> = <span class="hljs-title">addNumbers</span><span class="hljs-params">(a, b)</span>  </span><br><span class="hljs-comment">% 这个函数将两个数字相加  </span><br>sum = a + b;  <br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p>可以在MATLAB命令窗口或其他.m文件中调用这个函数：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs matlab">result = addNumbers(<span class="hljs-number">3</span>, <span class="hljs-number">4</span>);  <span class="hljs-comment">% 返回7</span><br></code></pre></td></tr></table></figure><p>原理是在MATLAB中，函数的返回值并不是通过显式的 return 语句来实现的，而是通过将一个或多个输出变量赋值，然后在函数结束时自动返回这些变量的值。在你提供的代码中，sum 是被赋值为 a + b 的结果，当 addNumbers 函数执行到 end 关键字时，MATLAB 会自动返回 sum 变量的值。</p><p>当你在MATLAB中调用一个函数时，例如 result &#x3D; addNumbers(3, 4);，MATLAB 会执行该函数，并在函数结束时获取到所有在函数内部定义并赋值的输出变量（在这个例子中是 sum），并将这些变量的值返回给调用者。在这个例子中，result 将被赋值为 sum 的值，即 3 + 4 的结果，也就是 7。</p><p>简而言之，MATLAB 通过在函数结束时自动返回已赋值的输出变量来实现函数的返回值，而不需要显式的 return 语句。这是MATLAB语言的一个特性，使得编写函数更加简洁。</p><p>同时，需要指出的是，每个.m文件的变量是<strong>局部变量</strong>，生命周期也与函数执行的生命周期一致。      </p><h2 id="图像绘制"><a href="#图像绘制" class="headerlink" title="图像绘制"></a>图像绘制</h2><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs matlab"><span class="hljs-comment">%线图</span><br>x = <span class="hljs-number">0</span>:<span class="hljs-number">0.01</span>:<span class="hljs-number">2</span>*<span class="hljs-built_in">pi</span>; <span class="hljs-comment">% 创建一个x值的向量  </span><br>y = <span class="hljs-built_in">sin</span>(x); <span class="hljs-comment">% 对应的y值  </span><br><span class="hljs-built_in">plot</span>(x, y); <span class="hljs-comment">% 绘制线图  </span><br>title(<span class="hljs-string">&#x27;y = sin(x)&#x27;</span>); <span class="hljs-comment">% 添加标题  </span><br>xlabel(<span class="hljs-string">&#x27;x&#x27;</span>); <span class="hljs-comment">% x轴标签  </span><br>ylabel(<span class="hljs-string">&#x27;y&#x27;</span>); <span class="hljs-comment">% y轴标签  </span><br>grid on; <span class="hljs-comment">% 添加网格</span><br><span class="hljs-comment">%散点图</span><br>x = <span class="hljs-built_in">randn</span>(<span class="hljs-number">1</span>, <span class="hljs-number">100</span>); <span class="hljs-comment">% 随机生成100个x值  </span><br>y = <span class="hljs-built_in">randn</span>(<span class="hljs-number">1</span>, <span class="hljs-number">100</span>); <span class="hljs-comment">% 随机生成100个y值  </span><br><span class="hljs-built_in">scatter</span>(x, y); <span class="hljs-comment">% 绘制散点图  </span><br>title(<span class="hljs-string">&#x27;Scatter Plot of Random Points&#x27;</span>); <span class="hljs-comment">% 添加标题</span><br><span class="hljs-comment">%曲面图</span><br>[x, y] = <span class="hljs-built_in">meshgrid</span>(<span class="hljs-number">-10</span>:<span class="hljs-number">0.5</span>:<span class="hljs-number">10</span>, <span class="hljs-number">-10</span>:<span class="hljs-number">0.5</span>:<span class="hljs-number">10</span>); <span class="hljs-comment">% 创建网格  </span><br>z = <span class="hljs-built_in">sin</span>(<span class="hljs-built_in">sqrt</span>(x.^<span class="hljs-number">2</span> + y.^<span class="hljs-number">2</span>)); <span class="hljs-comment">% 计算z值  </span><br>surf(x, y, z); <span class="hljs-comment">% 绘制曲面图  </span><br>title(<span class="hljs-string">&#x27;3D Surface Plot&#x27;</span>); <span class="hljs-comment">% 添加标题  </span><br>xlabel(<span class="hljs-string">&#x27;x&#x27;</span>); <span class="hljs-comment">% x轴标签  </span><br>ylabel(<span class="hljs-string">&#x27;y&#x27;</span>); <span class="hljs-comment">% y轴标签  </span><br>zlabel(<span class="hljs-string">&#x27;z&#x27;</span>); <span class="hljs-comment">% z轴标签</span><br><span class="hljs-comment">%向量场图</span><br>[x, y] = <span class="hljs-built_in">meshgrid</span>(<span class="hljs-number">-2</span>:<span class="hljs-number">0.2</span>:<span class="hljs-number">2</span>, <span class="hljs-number">-2</span>:<span class="hljs-number">0.2</span>:<span class="hljs-number">0.2</span>); <span class="hljs-comment">% 创建网格  </span><br>u = y; <span class="hljs-comment">% x方向上的向量分量  </span><br>v = -x; <span class="hljs-comment">% y方向上的向量分量  </span><br>quiver(x, y, u, v); <span class="hljs-comment">% 绘制向量场图  </span><br>title(<span class="hljs-string">&#x27;Vector Field Plot&#x27;</span>); <span class="hljs-comment">% 添加标题  </span><br>xlabel(<span class="hljs-string">&#x27;x&#x27;</span>); <span class="hljs-comment">% x轴标签  </span><br>ylabel(<span class="hljs-string">&#x27;y&#x27;</span>); <span class="hljs-comment">% y轴标签</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>编程语言</category>
      
      <category>matlab</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>ng-多变量回归</title>
    <link href="/2025/03/21/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/ng%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0week2/"/>
    <url>/2025/03/21/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/ng%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0week2/</url>
    
    <content type="html"><![CDATA[<h2 id="多维情况下矢量化"><a href="#多维情况下矢量化" class="headerlink" title="多维情况下矢量化"></a>多维情况下矢量化</h2><p>在实际情境中，预测一个y值通常需要很多x值，因此上一节公式可以改写为<br>$$f_{\overrightarrow{w},b} (\overrightarrow{x} )&#x3D;w_{1} x_{1}+w_{2}x_{2}+···+w_{n}x_{n}+b $$<br>也即<br>$$ f_{\overrightarrow{w},b} (\overrightarrow{x} )&#x3D;\overrightarrow{w} ·\overrightarrow{x}+b $$<br>我们可以定义两个矢量</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br>w=np.array([<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>])<br>x=np.array([<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>])<br>b=<span class="hljs-number">2</span><br>f=np.dot(w,x)+b  <span class="hljs-comment"># 矢量点乘</span><br></code></pre></td></tr></table></figure><p>这个运算速度是比for循环要快得多的<br>自然地，我们需要考虑多维情况下如何实现迭代，一维式子改写为<br>$$w_{j} &#x3D;w_{j} -\alpha \frac{\partial }{\partial w_{j}}J(\overrightarrow{w},b) $$<br>$$  b &#x3D;b -\alpha \frac{\partial }{\partial b}J(\overrightarrow{w},b) $$<br>带入J求偏导项<br>$$ J(\overrightarrow{w},b)&#x3D;\frac{1}{2m} \sum_{i&#x3D;1}^{m} (f_{w,x}( \overrightarrow{x^{(i)}})-\overrightarrow{y}^{(i)}  )^{2 }$$<br>$$ \frac{\partial }{\partial w_{j}}J(\overrightarrow{w},b)&#x3D;\frac{1}{2m} \sum_{i&#x3D;1}^{m}2(f_{w,x}( \overrightarrow{x^{(i)}})-\overrightarrow{y}^{(i)}  )\frac{\partial }{\partial w_{j}} f_{w,x}( \overrightarrow{x^{(i)}})$$<br>$$&#x3D; \frac{1}{2m} \sum_{i&#x3D;1}^{m}2(f_{w,x}( \overrightarrow{x^{(i)}})-\overrightarrow{y}^{(i)}  )\frac{\partial }{\partial w_{j}}(\overrightarrow{w} ·\overrightarrow{x^{(i)}}+b) $$<br>$$&#x3D; \frac{1}{m} \sum_{i&#x3D;1}^{m}(f_{w,x}( \overrightarrow{x^{(i)}})-\overrightarrow{y}^{(i)}  )x_{j} ^{(i)}  $$<br>最终得出<br>$$ w_{j} &#x3D;w_{j} -\alpha \frac{1}{m} \sum_{i&#x3D;1}^{m}(f_{w,x}( \overrightarrow{x^{(i)}})-\overrightarrow{y}^{(i)}  )x_{j} ^{(i)}$$<br>同理可得<br>$$ b &#x3D;b -\alpha \frac{1}{m} \sum_{i&#x3D;1}^{m}(f_{w,x}( \overrightarrow{x^{(i)}})-\overrightarrow{y}^{(i)}  ) $$</p><h2 id="特征缩放"><a href="#特征缩放" class="headerlink" title="特征缩放"></a>特征缩放</h2><p>换坐标（归一化），在物理中经常引入无量纲常数缩放方法，机器学习中的特征缩放就是这一思想，这通常会使得随机梯度下降收敛的更快，同时避免了因为某些过于尖锐的峰处多次震荡才收敛的情况</p><h2 id="多变量回归的矩阵表示"><a href="#多变量回归的矩阵表示" class="headerlink" title="多变量回归的矩阵表示"></a>多变量回归的矩阵表示</h2><p>对于m组数据，每组数据有n个表示维度的情况，我们可以用下面的矩阵表示数据集</p><p>$$ \mathbf{X}&#x3D;\left(\begin{array}{cccc}<br>x_{0}^{(0)} &amp; x_{1}^{(0)} &amp; \cdots &amp; x_{n-1}^{(0)} \<br>x_{0}^{(1)} &amp; x_{1}^{(1)} &amp; \cdots &amp; x_{n-1}^{(1)} \<br>\cdots &amp; &amp; &amp; \<br>x_{0}^{(m-1)} &amp; x_{1}^{(m-1)} &amp; \cdots &amp; x_{n-1}^{(m-1)}<br>\end{array}\right) $$<br>因此式子<br>$$ f_{\mathbf{w},b}(\mathbf{x})&#x3D;w_0x_0+w_1x_1+\ldots+w_{n-1}x_{n-1}+b  $$<br>可以改写为<br>$$f_{\mathbf{w},b}(\mathbf{x})&#x3D;\mathbf{w}\cdot\mathbf{x}+b $$</p><h2 id="作业实现"><a href="#作业实现" class="headerlink" title="作业实现"></a>作业实现</h2><h3 id="作业1"><a href="#作业1" class="headerlink" title="作业1"></a>作业1</h3><p> 描述：You will use the motivating example of housing price prediction. The training dataset contains three examples with four features (size, bedrooms, floors and, age) shown in the table below. Note that, unlike the earlier labs, size is in sqft rather than 1000 sqft. This causes an issue, which you will solve in the next lab!<br>github地址：<a href="https://github.com/kaieye/2022-Machine-Learning-Specialization/blob/main/Supervised%20Machine%20Learning%20Regression%20and%20Classification/week2/1.Multiple%20linear%20regression/C1_W2_Lab02_Multiple_Variable_Soln.ipynb">https://github.com/kaieye/2022-Machine-Learning-Specialization/blob/main/Supervised%20Machine%20Learning%20Regression%20and%20Classification/week2/1.Multiple%20linear%20regression/C1_W2_Lab02_Multiple_Variable_Soln.ipynb</a><br>基本思路就是用pandas读取数据，然后用sklearn库实现多变量回归。<br>调库</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> sklearn.model_selection <span class="hljs-keyword">import</span> train_test_split  <br><span class="hljs-keyword">from</span> sklearn.linear_model <span class="hljs-keyword">import</span> SGDRegressor <br><span class="hljs-keyword">from</span> sklearn.metrics <span class="hljs-keyword">import</span> mean_squared_error, r2_score<br><span class="hljs-keyword">import</span> pandas <span class="hljs-keyword">as</span> pd  <br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br></code></pre></td></tr></table></figure><p><code>from sklearn.model_selection import train_test_split</code><br>调用方式：<br>train_test_split 函数用于将数据集拆分为训练集和测试集。它通常的调用方式如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=<span class="hljs-number">0.2</span>, random_state=<span class="hljs-number">42</span>)<br><br></code></pre></td></tr></table></figure><p>X 和 y 分别是特征和标签数据。<br>test_size 参数指定了用作测试集的数据比例（在这个例子中是20%）。<br>random_state 参数用于确保每次拆分时都能得到相同的结果，以便于重现实验。<br>我门现在读取并划分数据</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 加载数据  </span><br>data_path=<br>data = pd.read_csv(<span class="hljs-string">&#x27;&#x27;</span>)  <br>  <br><span class="hljs-comment"># 假设列名是这样的（根据你的实际数据进行调整）  </span><br>features = [<span class="hljs-string">&#x27;Number of Bedrooms&#x27;</span>, <span class="hljs-string">&#x27;Number of Floors&#x27;</span>, <span class="hljs-string">&#x27;Age of Home&#x27;</span>]  <br>target = [<span class="hljs-string">&#x27;Price&#x27;</span>]  <br>  <br><span class="hljs-comment"># 分离特征和目标变量  </span><br>x = data[features]  <br>y = data[target].values.ravel()  <span class="hljs-comment"># ravel将DataFrame转换为一维数组  </span><br>  <br><span class="hljs-comment"># 划分训练集和测试集  </span><br>x_train, x_test, y_train, y_test = train_test_split(x, y, test_size=<span class="hljs-number">0.2</span>, random_state=<span class="hljs-number">42</span>)  <br></code></pre></td></tr></table></figure><p>然后训练</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 实例化并拟合模型</span><br>sgd_reg = SGDRegressor(max_iter=<span class="hljs-number">1000</span>, tol=<span class="hljs-number">1e-3</span>)<br>sgd_reg.fit(x_train, y_train)<br><br><span class="hljs-comment"># 输出系数和截距</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;系数向量:&quot;</span>, sgd_reg.coef_)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;截距向量:&quot;</span>, sgd_reg.intercept_)<br></code></pre></td></tr></table></figure><h3 id="作业2-选择合适坐标（特征化）"><a href="#作业2-选择合适坐标（特征化）" class="headerlink" title="作业2 选择合适坐标（特征化）"></a>作业2 选择合适坐标（特征化）</h3><p>关键的库</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> sklearn.preprocessing <span class="hljs-keyword">import</span> StandardScaler <br><span class="hljs-comment"># 准备特征化数据</span><br>scaler = StandardScaler()<br>x_scaler=scaler.fit_transform(x)<br><span class="hljs-comment"># 在训练数据上调用 fit 方法，StandardScaler 会计算每个特征的均值和标准差，并存储这些值，以便稍后在相同的数据集或其他数据集（如测试集）上进行转换。</span><br></code></pre></td></tr></table></figure><p>最终代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> sklearn.model_selection <span class="hljs-keyword">import</span> train_test_split<br><span class="hljs-keyword">from</span> sklearn.linear_model <span class="hljs-keyword">import</span> SGDRegressor<br><span class="hljs-keyword">import</span> pandas <span class="hljs-keyword">as</span> pd<br><span class="hljs-keyword">from</span> sklearn.preprocessing <span class="hljs-keyword">import</span> StandardScaler<br><span class="hljs-comment"># 加载数据</span><br>data_path=<span class="hljs-string">&#x27;data/week2ex2data.txt&#x27;</span><br>data = pd.read_csv(data_path)<br><br>features = [<span class="hljs-string">&#x27;space&#x27;</span>,<span class="hljs-string">&#x27;number&#x27;</span>]<br>target = [<span class="hljs-string">&#x27;price&#x27;</span>]<br><span class="hljs-comment"># 分离特征和目标变量</span><br>x = data[features]<br>y = data[target].values.ravel()  <span class="hljs-comment"># ravel将DataFrame转换为一维数组</span><br><span class="hljs-comment"># 准备特征化数据</span><br>scaler = StandardScaler()<br>x_scaler=scaler.fit_transform(x)<br><span class="hljs-comment"># 划分训练集和测试集</span><br>x_train, x_test, y_train, y_test = train_test_split(x_scaler, y, test_size=<span class="hljs-number">0.2</span>,random_state=<span class="hljs-number">42</span>)<br><span class="hljs-comment"># 实例化并拟合模型</span><br>sgd_reg = SGDRegressor(max_iter=<span class="hljs-number">1000</span>, tol=<span class="hljs-number">1e-3</span>)<br>sgd_reg.fit(x_train, y_train)<br><br><span class="hljs-comment"># 输出系数和截距</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;系数向量:&quot;</span>, sgd_reg.coef_)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;截距向量:&quot;</span>, sgd_reg.intercept_)<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>机器学习</category>
      
      <category>ng机器学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>机器学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>pytorch</title>
    <link href="/2025/03/21/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/pytorch/"/>
    <url>/2025/03/21/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/pytorch/</url>
    
    <content type="html"><![CDATA[<p>前言：把某个环境引入jupyter的方法<br><a href="https://blog.csdn.net/leoound/article/details/137928032">跳转</a></p><p><a href="https://blog.csdn.net/Ever_____/article/details/136596213">https://blog.csdn.net/Ever_____&#x2F;article&#x2F;details&#x2F;136596213</a></p><h1 id="加载数据"><a href="#加载数据" class="headerlink" title="加载数据"></a>加载数据</h1><h2 id="Dataset类"><a href="#Dataset类" class="headerlink" title="Dataset类"></a>Dataset类</h2><p>把文件转化为torch的数据集对象，类似于写一个脚本</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">from</span> torch.utils.data <span class="hljs-keyword">import</span> Dataset<br><span class="hljs-keyword">import</span> os<br><span class="hljs-keyword">from</span> PIL <span class="hljs-keyword">import</span> Image<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyDataset</span>(<span class="hljs-title class_ inherited__">Dataset</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self,root_dir,label_dir</span>):<br>       <span class="hljs-variable language_">self</span>.root_dir = root_dir<br>       <span class="hljs-variable language_">self</span>.label_dir = label_dir<br>       <span class="hljs-variable language_">self</span>.path = os.path.join(<span class="hljs-variable language_">self</span>.root_dir,<span class="hljs-variable language_">self</span>.label_dir)<br>       <span class="hljs-comment">#返回的是文件和子文件夹的名字列表。</span><br>       <span class="hljs-variable language_">self</span>.img_list = os.listdir(<span class="hljs-variable language_">self</span>.path)<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__getitem__</span>(<span class="hljs-params">self,idx</span>):<br>         img_name = <span class="hljs-variable language_">self</span>.img_list[idx]<br>         img_item_path = os.path.join(<span class="hljs-variable language_">self</span>.root_dir,<span class="hljs-variable language_">self</span>.label_dir,img_name)<br>         img = Image.<span class="hljs-built_in">open</span>(img_item_path)<br>         label = <span class="hljs-variable language_">self</span>.label_dir<br>         <span class="hljs-keyword">return</span> img, label<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__len__</span>(<span class="hljs-params">self</span>):<br>       <span class="hljs-keyword">return</span> <span class="hljs-built_in">len</span>(<span class="hljs-variable language_">self</span>.img_list)<br>   <br>root_dir = <span class="hljs-string">&#x27;dataset/train&#x27;</span><br>ants_lavel_dir = <span class="hljs-string">&#x27;ants&#x27;</span><br>bees_label_dir = <span class="hljs-string">&#x27;bees&#x27;</span><br>ants_dataset = MyDataset(root_dir,ants_lavel_dir)<br>bees_dataset = MyDataset(root_dir,bees_label_dir)<br></code></pre></td></tr></table></figure><h2 id="Dataloader类"><a href="#Dataloader类" class="headerlink" title="Dataloader类"></a>Dataloader类</h2><h1 id="搭建模型"><a href="#搭建模型" class="headerlink" title="搭建模型"></a>搭建模型</h1><h2 id="nn-Module类"><a href="#nn-Module类" class="headerlink" title="nn.Module类"></a>nn.Module类</h2><p>常用的的包torch.nn<br>神经网络的基类Module，定义的模型都需要集成该类nn.Module<br>自己定义的模型需要实现__init__和forward函数  </p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">import</span> torch<br><span class="hljs-keyword">from</span> torch <span class="hljs-keyword">import</span> nn<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Mynet</span>(nn.Module):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">super</span>().__init__()<br>        <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">forward</span>(<span class="hljs-params">self, <span class="hljs-built_in">input</span></span>):<br>        output = <span class="hljs-built_in">input</span> +<span class="hljs-number">1</span><br>        <span class="hljs-keyword">return</span> output<br>net = Mynet()<br>x = torch.tensor(<span class="hljs-number">1.0</span>)<br>myout = net(x)<br><span class="hljs-built_in">print</span>(myout)<br></code></pre></td></tr></table></figure><h2 id="网络设计"><a href="#网络设计" class="headerlink" title="网络设计"></a>网络设计</h2><h3 id="线性连接层"><a href="#线性连接层" class="headerlink" title="线性连接层"></a>线性连接层</h3><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Mynet</span>(nn.Module):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-comment"># 调用父类初始化方法</span><br>        <span class="hljs-built_in">super</span>(Mynet,<span class="hljs-variable language_">self</span>).__init__()<br>        <span class="hljs-comment"># 定义一个全连接层，将输入的 196608 个特征映射到 10 个输出特征</span><br>        <span class="hljs-variable language_">self</span>.linear1 = Linear(<span class="hljs-number">196608</span>,<span class="hljs-number">10</span>)<br>    <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">forward</span>(<span class="hljs-params">self,<span class="hljs-built_in">input</span></span>):<br>        output = <span class="hljs-variable language_">self</span>.linear1(<span class="hljs-built_in">input</span>)<br>        <span class="hljs-keyword">return</span> output<br></code></pre></td></tr></table></figure><h3 id="flatten"><a href="#flatten" class="headerlink" title="flatten"></a>flatten</h3><h3 id="卷积层"><a href="#卷积层" class="headerlink" title="卷积层"></a>卷积层</h3><h3 id="池化层"><a href="#池化层" class="headerlink" title="池化层"></a>池化层</h3><h2 id="损失函数"><a href="#损失函数" class="headerlink" title="损失函数"></a>损失函数</h2><h2 id="传播"><a href="#传播" class="headerlink" title="传播"></a>传播</h2>]]></content>
    
    
    <categories>
      
      <category>编程语言</category>
      
      <category>c++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>c++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>c++课堂笔记</title>
    <link href="/2025/03/21/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/c++%E7%AC%94%E8%AE%B0/"/>
    <url>/2025/03/21/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/c++%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<p>写在前面：这是针对2024春cau《面向对象的程序设计》以及我个人的学习积累整理的笔记，其中大纲的整理受到了<a href="https://blog.csdn.net/chenlong_cxy/article/details/127166206">https://blog.csdn.net/chenlong_cxy/article/details/127166206</a> 的启发</p><h1 id="一-c-基础"><a href="#一-c-基础" class="headerlink" title="(一)c++基础"></a>(一)c++基础</h1><h2 id="1-1数据类型"><a href="#1-1数据类型" class="headerlink" title="1.1数据类型"></a>1.1数据类型</h2><p>相比于c多了一个bool（基本数据类型）</p><h2 id="1-2命名空间"><a href="#1-2命名空间" class="headerlink" title="1.2命名空间"></a>1.2命名空间</h2><p> 在C++编程中，命名空间是一种特性，用于将代码进行逻辑分组，以避免命名冲突和组织代码。命名空间可以被看作是一个容器，它封装了一组相关的类、函数、变量等，为它们提供了一个独立的命名空间域，从而可以避免在全局命名空间中因名称重复而导致的冲突。</p><p>命名空间的作用：<br>避免命名冲突：在大型项目中，不同的库或模块可能使用相同的函数名或变量名。通过将这些名称放在不同的命名空间中，可以确保它们不会发生冲突。</p><p>代码组织：命名空间有助于将相关的代码组织在一起，使得代码结构更清晰，更易于维护。</p><p>提高可读性：通过使用有意义的命名空间名称，可以使得代码更加易于理解。例如，一个名为MathFunctions的命名空间可能包含与数学计算相关的函数。</p><p>我们常用的库称为c++标准库（stl）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span>  </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span>  </span><br>  <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;  <br>    std::vector&lt;<span class="hljs-type">int</span>&gt; numbers = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;;  <br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> num : numbers) &#123;  <br>        std::cout &lt;&lt; num &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;  <br>    &#125;  <br>    std::cout &lt;&lt; std::endl;  <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;  <br>&#125;<br>--------------------------------<br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span>  </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span>  </span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std; <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;  <br>    std::vector&lt;<span class="hljs-type">int</span>&gt; numbers = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;;  <br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> num : numbers) &#123;  <br>        std::cout &lt;&lt; num &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;  <br>    &#125;  <br>    cout &lt;&lt; std::endl;  <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;  <br>&#125;<br></code></pre></td></tr></table></figure><p>同样的，你也可以自己创建命名空间</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">namespace</span> MyNamespace &#123;  <br>    <span class="hljs-type">int</span> myVariable = <span class="hljs-number">10</span>;  <br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">myFunction</span><span class="hljs-params">()</span> </span>&#123;  <br>        <span class="hljs-comment">// 函数实现  </span><br>    &#125;  <br>&#125;<br><span class="hljs-keyword">using</span> MyNamespace::myFunction;  <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;  <br>    <span class="hljs-built_in">myFunction</span>();  <span class="hljs-comment">// 直接调用函数  </span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;  <br>&#125;<br>----------------------------------------------------<br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span>  </span><br><span class="hljs-keyword">namespace</span> MyMath &#123;  <br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> </span>&#123;  <br>        <span class="hljs-keyword">return</span> a + b;  <br>    &#125;  <br>&#125;  <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;  <br>    <span class="hljs-comment">// 使用完全限定名调用函数  </span><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Sum: &quot;</span> &lt;&lt; MyMath::<span class="hljs-built_in">add</span>(<span class="hljs-number">5</span>, <span class="hljs-number">7</span>) &lt;&lt; std::endl;  <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;  <br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="1-3缺省参数"><a href="#1-3缺省参数" class="headerlink" title="1.3缺省参数"></a>1.3缺省参数</h2><p>c++中，定义函数的时候可以让<strong>最右边的连续若干个参数</strong>有缺省值，在调用函数的时候，如果不写相应位置的参数，则调用的参数就为缺省值。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">fun</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b = <span class="hljs-number">1</span>, <span class="hljs-type">int</span> c = <span class="hljs-number">2</span>)</span> </span>&#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;a=&quot;</span> &lt;&lt; a &lt;&lt; <span class="hljs-string">&quot;\tb=&quot;</span> &lt;&lt; b &lt;&lt; <span class="hljs-string">&quot;\tc=&quot;</span> &lt;&lt; c &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure><p>调用时，如果参数b和c的参数没有给出，则默认为缺省值。<br>不过函数的赋值是从左到右的</p><h2 id="1-4函数重载"><a href="#1-4函数重载" class="headerlink" title="1.4函数重载"></a>1.4函数重载</h2><p>所谓函数重载，就是说同一个函数名，如果接收参数不同，那么就不属于命名冲突，调用时会自动判断传入的参数来决定使用哪一个函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c++"><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br> <br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br> <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">sumOfSquare</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span></span>;<br> <br><span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">sumOfSquare</span><span class="hljs-params">(<span class="hljs-type">double</span> x, <span class="hljs-type">double</span> y)</span></span>;<br> <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> x1, y1;<br><span class="hljs-type">double</span> x2, y2;<br>cout&lt;&lt;<span class="hljs-string">&quot;Enter two integer:&quot;</span>&lt;&lt;endl;<br>cin&gt;&gt;x1&gt;&gt;y1;<br>cout&lt;&lt;<span class="hljs-string">&quot;Their sum of square = &quot;</span>&lt;&lt;<span class="hljs-built_in">sumOfSquare</span>(x1, y1)&lt;&lt;endl;<br>cout&lt;&lt;<span class="hljs-string">&quot;Enter two Real Number:&quot;</span>&lt;&lt;endl;<br>cin&gt;&gt;x2&gt;&gt;y2;<br>cout&lt;&lt;<span class="hljs-string">&quot;Their sum of square = &quot;</span>&lt;&lt;<span class="hljs-built_in">sumOfSquare</span>(x2, y2)&lt;&lt;endl;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">sumOfSquare</span><span class="hljs-params">(<span class="hljs-type">int</span> x1, <span class="hljs-type">int</span> y1)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">return</span> (x1*x1+y1*y1);<br>&#125;<br><span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">sumOfSquare</span><span class="hljs-params">(<span class="hljs-type">double</span> x2, <span class="hljs-type">double</span> y2)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">return</span> (x2*x2+y2*y2);<br>&#125;<br></code></pre></td></tr></table></figure><p>ati:参数的默认值必须在函数声明中指定!!!</p><h2 id="1-5引用"><a href="#1-5引用" class="headerlink" title="1.5引用"></a>1.5引用</h2><h3 id="1-5-1引用的定义："><a href="#1-5-1引用的定义：" class="headerlink" title="1.5.1引用的定义："></a>1.5.1引用的定义：</h3><p>1引用是一个变量的别名，也就是说，它是某个已存在变量的另一个名字。<br>2一旦把引用初始化为某个变量，就可以使用该引用名称或变量名称来指向变量。   </p><h3 id="1-5-2引用与指针的区别："><a href="#1-5-2引用与指针的区别：" class="headerlink" title="1.5.2引用与指针的区别："></a>1.5.2引用与指针的区别：</h3><p>1不存在空引用。引用必须连接到一块合法的内存。一旦引用被初始化为一个对象，就不能被指向到另一个对象，指针可以在任何时候指向到另一个对象。(引用自带const属性)<br>C++ 标准不允许引用重新指向其他对象，这相当于引用具有内置的 const 属性（但不是指引用的对象本身是 const，而是指引用的指向是 const）。 </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;  <br>    <span class="hljs-type">int</span> x = <span class="hljs-number">5</span>;  <br>    <span class="hljs-type">int</span> &amp;ref = x; <span class="hljs-comment">// 引用被初始化为x，连接到x所占用的合法内存  </span><br>  <br>    <span class="hljs-comment">// ref现在引用x，且不能改变其引用的对象  </span><br>    <span class="hljs-comment">// 以下代码是非法的，因为C++中的引用不能在创建后改变其指向的对象  </span><br>    <span class="hljs-comment">// int y = 10;  </span><br>    <span class="hljs-comment">// ref = y; // 错误！C++中的引用不能在创建后重新指向其他对象  </span><br>  <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;  <br>&#125;<br></code></pre></td></tr></table></figure><p>2引用必须在创建时被初始化，而指针可以在任何时间被初始化。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;  <br>    <span class="hljs-type">int</span> x = <span class="hljs-number">5</span>;  <br>    <span class="hljs-type">int</span> *ptr; <span class="hljs-comment">// 指针声明，尚未初始化  </span><br>  <br>    <span class="hljs-comment">// 可以在后面的代码中任何时候初始化指针  </span><br>    ptr = &amp;x; <span class="hljs-comment">// 指针现在指向x  </span><br>  <br>    <span class="hljs-type">int</span> &amp;ref = x; <span class="hljs-comment">// 引用必须在声明时初始化  </span><br>    <span class="hljs-comment">// int &amp;anotherRef; // 错误！引用在声明时必须被初始化  </span><br>  <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;  <br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="1-5-3创建引用："><a href="#1-5-3创建引用：" class="headerlink" title="1.5.3创建引用："></a>1.5.3创建引用：</h3><p>假设变量名称是变量附属在内存位置中的标签，我们可以把引用当成是变量附属在内存位置中的第二个标签。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> i = <span class="hljs-number">17</span>;<br><span class="hljs-type">int</span>&amp; r = i; <span class="hljs-comment">// 创建一个整型引用 r，它是 i 的别名</span><br><br>r = <span class="hljs-number">42</span>; <span class="hljs-comment">// 修改 r，实际上也修改了 i</span><br>cout &lt;&lt; <span class="hljs-string">&quot;i 的值：&quot;</span> &lt;&lt; i &lt;&lt; endl; <span class="hljs-comment">// 输出 42</span><br><br><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-comment">// 交换两个整数的值</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">swapIntegers</span><span class="hljs-params">(<span class="hljs-type">int</span>&amp; x, <span class="hljs-type">int</span>&amp; y)</span> </span>&#123;<br>    <span class="hljs-type">int</span> temp = x;<br>    x = y;<br>    y = temp;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> a = <span class="hljs-number">10</span>, b = <span class="hljs-number">20</span>;<br>    cout &lt;&lt; <span class="hljs-string">&quot;Before swapping: a = &quot;</span> &lt;&lt; a &lt;&lt; <span class="hljs-string">&quot;, b = &quot;</span> &lt;&lt; b &lt;&lt; endl;<br>    <span class="hljs-built_in">swapIntegers</span>(a, b);<br>    cout &lt;&lt; <span class="hljs-string">&quot;After swapping: a = &quot;</span> &lt;&lt; a &lt;&lt; <span class="hljs-string">&quot;, b = &quot;</span> &lt;&lt; b &lt;&lt; endl;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="1-5-4常量引用和值传递的内存分析"><a href="#1-5-4常量引用和值传递的内存分析" class="headerlink" title="1.5.4常量引用和值传递的内存分析"></a>1.5.4常量引用和值传递的内存分析</h3><p>值传递（Pass by Value）和常量引用（Constant Reference）是编程中参数传递的两种方式，它们在内存中的表现和行为有所不同。下面我将结合内存来详细解释这两种概念。</p><h4 id="值传递（Pass-by-Value）"><a href="#值传递（Pass-by-Value）" class="headerlink" title="值传递（Pass by Value）"></a>值传递（Pass by Value）</h4><p>在值传递中，函数的参数是通过复制实际参数的值来创建的。这意味着在内存中会为这些参数分配新的空间，并将实际参数的值复制到这些新分配的空间中。因此，函数内部对参数的任何修改都不会影响到实际参数。<br>以C++为例，如果你有一个函数void func(int x)，并且在调用这个函数时传入了一个整数变量int a &#x3D; 5; func(a);，那么在调用func时，会在栈上为新变量x分配空间，并将a的值（即5）复制到x中。如果函数func修改了x的值，这个修改不会反映到a上，因为x和a是两个不同的内存位置中的值。</p><h4 id="常量引用（Constant-Reference）"><a href="#常量引用（Constant-Reference）" class="headerlink" title="常量引用（Constant Reference）"></a>常量引用（Constant Reference）</h4><p>常量引用是一种特殊的引用类型，它允许你通过引用来传递参数，但不允许在函数内部修改引用的值。在内存中，常量引用并不创建参数的副本，而是直接使用了实际参数的内存地址。这意味着常量引用提供了一种效率更高的参数传递方式，因为它避免了复制数据。</p><p>继续上面的例子，如果你将函数改为void func(const int&amp; x)并使用相同的调用方式func(a)，那么在调用func时，不会为x分配新的内存空间。相反，x会直接引用a的内存地址。由于x是一个常量引用，所以你不能在func内部修改x的值（尝试这样做会导致编译错误）。但是，你可以读取x的值，它将是a的值（即5）。</p><p>常量引用的好处之一是它可以避免不必要的复制操作，特别是当处理大型对象或数据结构时，这可以显著提高性能。另一个好处是它可以处理不可修改的数据或需要保护的数据，确保这些数据在函数内部不会被意外修改。</p><p>总的来说，值传递和常量引用在内存中的表现和行为有所不同。值传递会创建参数的副本并分配新的内存空间，而常量引用则直接使用实际参数的内存地址并禁止修改引用的值。选择哪种传递方式取决于你的具体需求和程序的上下文。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span>  </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span>  </span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-comment">// 定义一个Person类  </span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;  <br><span class="hljs-keyword">private</span>:  <br>    string name; <span class="hljs-comment">// 私有数据成员：姓名  </span><br>    <span class="hljs-type">int</span> age;          <span class="hljs-comment">// 私有数据成员：年龄  </span><br>  <br><span class="hljs-keyword">public</span>:  <br>    <span class="hljs-comment">// 公共成员函数：构造函数，用于初始化对象  </span><br>    <span class="hljs-built_in">Person</span>(<span class="hljs-type">const</span> string&amp; n, <span class="hljs-type">int</span> a) : <span class="hljs-built_in">name</span>(n), <span class="hljs-built_in">age</span>(a) &#123;&#125;<br>    <span class="hljs-comment">// 也可以采用值传递</span><br>    <span class="hljs-comment">// Person(string n,int a) : name(n),age(a) &#123;&#125;</span><br>&#125;<br></code></pre></td></tr></table></figure><h1 id="（二）类和对象"><a href="#（二）类和对象" class="headerlink" title="（二）类和对象"></a>（二）类和对象</h1><h2 id="2-1类的基本概念"><a href="#2-1类的基本概念" class="headerlink" title="2.1类的基本概念"></a>2.1类的基本概念</h2><h3 id="2-1-1类的定义"><a href="#2-1-1类的定义" class="headerlink" title="2.1.1类的定义"></a>2.1.1类的定义</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> &#123;  <br><span class="hljs-keyword">public</span>:  <br>    <span class="hljs-type">int</span> myVariable;  <br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">myFunction</span><span class="hljs-params">()</span> </span>&#123;  <br>        <span class="hljs-comment">// 类成员函数的实现  </span><br>    &#125;  <br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="2-1-2类的封装"><a href="#2-1-2类的封装" class="headerlink" title="2.1.2类的封装"></a>2.1.2类的封装</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">EncapsulatedClass</span> &#123;  <br><span class="hljs-keyword">private</span>:  <br>    <span class="hljs-type">int</span> hiddenVariable;  <br>  <br><span class="hljs-keyword">public</span>:  <br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setValue</span><span class="hljs-params">(<span class="hljs-type">int</span> value)</span> </span>&#123;  <br>        hiddenVariable = value;  <br>    &#125;  <br>  <br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getValue</span><span class="hljs-params">()</span> </span>&#123;  <br>        <span class="hljs-keyword">return</span> hiddenVariable;  <br>    &#125;  <br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="2-1-3this指针"><a href="#2-1-3this指针" class="headerlink" title="2.1.3this指针"></a>2.1.3this指针</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ThisPointerExample</span> &#123;  <br><span class="hljs-keyword">private</span>:  <br>    <span class="hljs-type">int</span> value;  <br>  <br><span class="hljs-keyword">public</span>:  <br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setValue</span><span class="hljs-params">(<span class="hljs-type">int</span> newValue)</span> </span>&#123;  <br>        <span class="hljs-keyword">this</span>-&gt;value = newValue; <span class="hljs-comment">// 使用this指针明确指定当前对象的成员变量  </span><br>    &#125;  <br>  <br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getValue</span><span class="hljs-params">()</span> </span>&#123;  <br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>-&gt;value; <span class="hljs-comment">// 使用this指针明确指定当前对象的成员变量  </span><br>    &#125;  <br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="2-1-4类的初始化列表"><a href="#2-1-4类的初始化列表" class="headerlink" title="2.1.4类的初始化列表"></a>2.1.4类的初始化列表</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ScopedClass</span> &#123;  <br><span class="hljs-keyword">private</span>:  <br>    <span class="hljs-type">int</span> x, y;  <br>  <br><span class="hljs-keyword">public</span>:  <br>    <span class="hljs-comment">// 构造函数初始化列表  </span><br>    <span class="hljs-built_in">ScopedClass</span>(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b) : <span class="hljs-built_in">x</span>(a), <span class="hljs-built_in">y</span>(b) &#123;&#125;  <br>  <br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printValues</span><span class="hljs-params">()</span> </span>&#123;  <br>        <span class="hljs-comment">// 在类的作用域内访问成员变量  </span><br>        std::cout &lt;&lt; <span class="hljs-string">&quot;x: &quot;</span> &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot;, y: &quot;</span> &lt;&lt; y &lt;&lt; std::endl;  <br>    &#125;  <br>&#125;;  <br>  <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;  <br>    <span class="hljs-function">ScopedClass <span class="hljs-title">obj</span><span class="hljs-params">(<span class="hljs-number">10</span>, <span class="hljs-number">20</span>)</span></span>; <span class="hljs-comment">// 使用初始化列表进行实例化  </span><br>    obj.<span class="hljs-built_in">printValues</span>(); <span class="hljs-comment">// 输出：x: 10, y: 20  </span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;  <br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2-2构造函数与析构函数"><a href="#2-2构造函数与析构函数" class="headerlink" title="2.2构造函数与析构函数"></a>2.2构造函数与析构函数</h2><h3 id="2-2-1构造函数"><a href="#2-2-1构造函数" class="headerlink" title="2.2.1构造函数"></a>2.2.1构造函数</h3><p>构造函数是一种特殊的成员函数，它在创建类的对象时被自动调用，用于初始化对象的状态。构造函数的名字与类的名称相同，且没有返回类型，甚至连void也没有。它的主要任务是初始化对象的成员变量或执行一些在创建对象时需要进行的操作。</p><p>构造函数可以根据需要设置参数，这些参数用于初始化对象的状态。当创建类的对象时，可以通过构造函数传递参数来初始化对象的属性。如果没有提供显式的构造函数，编译器会自动生成一个默认的无参构造函数。但是，如果类中定义了任何一个构造函数（无论是有参还是无参），编译器就不会自动生成默认构造函数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Teacher</span>&#123;<br><span class="hljs-keyword">private</span>:<br>string name;<br><span class="hljs-type">int</span> age;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">Teacher</span>()&#123;<br>name=<span class="hljs-string">&quot;张三&quot;</span>; <br>age=<span class="hljs-number">18</span>;<br>cout &lt;&lt; <span class="hljs-string">&quot;自定义无参构造函数&quot;</span> &lt;&lt; std::endl; <br>&#125;<br><span class="hljs-built_in">Teacher</span>(string name1,<span class="hljs-type">int</span> age1)<br>&#123;<br>name=name1;<br>age=age1;<br>cout &lt;&lt; <span class="hljs-string">&quot;自定义有参构造函数&quot;</span> &lt;&lt; std::endl; <br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setname</span><span class="hljs-params">(string name1)</span> </span>&#123;  <br>        name = name1;  <br>    &#125;  <br>  <br>    <span class="hljs-comment">// 获取姓名  </span><br>    <span class="hljs-function">string <span class="hljs-title">getname</span><span class="hljs-params">()</span> </span>&#123;  <br>        <span class="hljs-keyword">return</span> name;  <br>    &#125;  <br>  <br>    <span class="hljs-comment">// 设置年龄  </span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setage</span><span class="hljs-params">(<span class="hljs-type">int</span> age1)</span> </span>&#123;  <br>        age = age1;  <br>    &#125;  <br>  <br>    <span class="hljs-comment">// 获取年龄  </span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getage</span><span class="hljs-params">()</span> </span>&#123;  <br>        <span class="hljs-keyword">return</span> age;  <br>    &#125;  <br><br><br>&#125;;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>Teacher t1;   <span class="hljs-comment">//这里不带括号   初始化为 张三 18</span><br><span class="hljs-function">Teacher <span class="hljs-title">t2</span><span class="hljs-params">(<span class="hljs-string">&quot;jam&quot;</span>,<span class="hljs-number">18</span>)</span></span>;<br>cout&lt;&lt;t<span class="hljs-number">1.</span><span class="hljs-built_in">getname</span>()&lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;t<span class="hljs-number">1.</span><span class="hljs-built_in">getage</span>()&lt;&lt;endl;<br>cout&lt;&lt;t<span class="hljs-number">2.</span><span class="hljs-built_in">getname</span>()&lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;t<span class="hljs-number">2.</span><span class="hljs-built_in">getage</span>()&lt;&lt;endl;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;   <br><br></code></pre></td></tr></table></figure><h3 id="2-2-2析构函数"><a href="#2-2-2析构函数" class="headerlink" title="2.2.2析构函数"></a>2.2.2析构函数</h3><p>在C++中，~B() 通常表示类 B 的析构函数的声明。析构函数是一个特殊的成员函数，当对象的生命周期结束时，它会被自动调用，用于释放对象可能持有的资源（如内存、文件句柄等）。</p><p>析构函数的名称与类名相同，但前面要加一个波浪符（~），并且没有返回类型，也没有参数。例如，如果有一个类名为 B，那么它的析构函数就会声明为 ~B()。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span> &#123;  <br><span class="hljs-keyword">public</span>:  <br>    <span class="hljs-comment">// 构造函数  </span><br>    <span class="hljs-built_in">B</span>() &#123;  <br>        <span class="hljs-comment">// 初始化代码，例如分配内存或打开文件等  </span><br>    &#125;  <br>      <br>    <span class="hljs-comment">// 析构函数  </span><br>    ~<span class="hljs-built_in">B</span>() &#123;  <br>        <span class="hljs-comment">// 清理代码，例如释放内存或关闭文件等  </span><br>    &#125;  <br>&#125;;  <br>  <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;  <br>    B b; <span class="hljs-comment">// 创建B类对象，构造函数被调用  </span><br>    <span class="hljs-comment">// 当b离开作用域时，析构函数~B()会被自动调用  </span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;  <br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2-3对象的复制-引用-指针创建"><a href="#2-3对象的复制-引用-指针创建" class="headerlink" title="2.3对象的复制,引用,指针创建"></a>2.3对象的复制,引用,指针创建</h2><h3 id="2-3-2浅拷贝与深拷贝"><a href="#2-3-2浅拷贝与深拷贝" class="headerlink" title="2.3.2浅拷贝与深拷贝"></a>2.3.2浅拷贝与深拷贝</h3><h2 id="2-4const关键字与类"><a href="#2-4const关键字与类" class="headerlink" title="2.4const关键字与类"></a>2.4const关键字与类</h2><p>const是一种声明，对于const声明的变量&#x2F;函数&#x2F;对象等，我们不可以改变其数值（等），否则编译器会报错。</p><h3 id="常量变量-指针"><a href="#常量变量-指针" class="headerlink" title="常量变量&#x2F;指针"></a>常量变量&#x2F;指针</h3><p>使用const声明的变量必须在声明时就赋值，且其值在程序运行期间不能再被修改</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">const</span> <span class="hljs-type">int</span> a = <span class="hljs-number">10</span>; <span class="hljs-comment">// a 是一个常量，其值不能被修改  </span><br><span class="hljs-comment">// a = 20; // 错误！不能修改常量a的值</span><br><br><br><span class="hljs-type">int</span> x = <span class="hljs-number">10</span>;  <br><span class="hljs-type">int</span> *<span class="hljs-type">const</span> ptr = &amp;x; <span class="hljs-comment">// 常指针，指向x的地址，但ptr的值不能被改变  </span><br>*ptr = <span class="hljs-number">20</span>; <span class="hljs-comment">// 合法，因为可以修改指针所指向的内容  </span><br><span class="hljs-comment">// ptr++; // 非法，因为ptr是常指针，其值不能改变</span><br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> x = <span class="hljs-number">10</span>;  <br><span class="hljs-type">const</span> <span class="hljs-type">int</span> *ptr = &amp;x; <span class="hljs-comment">// 指向常量的指针，不能通过ptr修改x的值  </span><br><span class="hljs-comment">// *ptr = 20; // 非法，因为ptr指向的内容是常量  </span><br><span class="hljs-type">int</span> y = <span class="hljs-number">20</span>;  <br>ptr = &amp;y; <span class="hljs-comment">// 合法，因为可以改变ptr的值</span><br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> x = <span class="hljs-number">10</span>;  <br><span class="hljs-type">const</span> <span class="hljs-type">int</span> *<span class="hljs-type">const</span> ptr = &amp;x; <span class="hljs-comment">// 指向常量的常指针  </span><br><span class="hljs-comment">// *ptr = 20; // 非法，因为ptr指向的内容是常量  </span><br><span class="hljs-comment">// ptr++; // 非法，因为ptr是常指针，其值不能改变</span><br><br></code></pre></td></tr></table></figure><h3 id="const函数参数"><a href="#const函数参数" class="headerlink" title="const函数参数"></a>const函数参数</h3><p>使用const修饰函数参数，可以保证在函数体内不会修改该参数的值。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printLength</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; str)</span> </span>&#123;  <br>    std::cout &lt;&lt; <span class="hljs-string">&quot;String length: &quot;</span> &lt;&lt; str.<span class="hljs-built_in">length</span>() &lt;&lt; std::endl;  <br>    <span class="hljs-comment">// str = &quot;another string&quot;; // 错误！不能在函数体内修改const参数  </span><br>&#125;<br><span class="hljs-comment">//注意</span><br><span class="hljs-comment">// 按引用传递，更高效  </span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printLengthByRef</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; str)</span> </span>&#123;    <br>    std::cout &lt;&lt; <span class="hljs-string">&quot;String length (by reference): &quot;</span> &lt;&lt; str.<span class="hljs-built_in">length</span>() &lt;&lt; std::endl;  <br>&#125;  <br>  <br><span class="hljs-comment">// 按值传递，会复制字符串  </span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printLengthByValue</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string str)</span> </span>&#123;    <br>    std::cout &lt;&lt; <span class="hljs-string">&quot;String length (by value): &quot;</span> &lt;&lt; str.<span class="hljs-built_in">length</span>() &lt;&lt; std::endl;  <br>&#125;<br><span class="hljs-comment">//但是二者都不允许更改string！</span><br></code></pre></td></tr></table></figure><p>简单地说，&amp;是高效传参的手段，但是不具有const性质，我们选择在参数传递前面加上const，提高代码的可读性，又保证了const引用。</p><h3 id="const成员函数"><a href="#const成员函数" class="headerlink" title="const成员函数"></a>const成员函数</h3><p>在成员函数中，const关键字表示该成员函数不会修改类的任何成员变量（除了被声明为mutable的成员）。这通常用于确保某些成员函数不会意外地修改对象的状态。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> &#123;  <br><span class="hljs-keyword">private</span>:  <br>    <span class="hljs-type">int</span> value;  <br><span class="hljs-keyword">public</span>:  <br>    <span class="hljs-built_in">MyClass</span>(<span class="hljs-type">int</span> v) : <span class="hljs-built_in">value</span>(v) &#123;&#125;  <br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getValue</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> value; &#125; <span class="hljs-comment">// 常量成员函数，不能修改类的任何成员变量  </span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setValue</span><span class="hljs-params">(<span class="hljs-type">int</span> v)</span> </span>&#123; value = v; &#125; <span class="hljs-comment">// 可以修改类的成员变量  </span><br>&#125;;<br><span class="hljs-comment">// void setValue(int v) const &#123; value = v; &#125; // 错误！不能在常成员函数中修改成员变量</span><br></code></pre></td></tr></table></figure><h3 id="常对象（const-Object）"><a href="#常对象（const-Object）" class="headerlink" title="常对象（const Object）"></a>常对象（const Object）</h3><p>常对象是用const关键字声明的对象。一旦一个对象被声明为const，就不能调用该对象的任何非const成员函数（因为这些函数可能会修改对象的状态），只能调用const成员函数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">const</span> MyClass <span class="hljs-title">obj</span><span class="hljs-params">(<span class="hljs-number">10</span>)</span></span>; <span class="hljs-comment">// 常对象  </span><br><span class="hljs-comment">// obj.setValue(20); // 错误！不能调用非const成员函数来修改const对象  </span><br><span class="hljs-type">int</span> val = obj.<span class="hljs-built_in">getValue</span>(); <span class="hljs-comment">// 正确！可以调用const成员函数</span><br></code></pre></td></tr></table></figure><h3 id="常对象成员（Members-of-a-const-Object）"><a href="#常对象成员（Members-of-a-const-Object）" class="headerlink" title="常对象成员（Members of a const Object）"></a>常对象成员（Members of a const Object）</h3><p>当一个对象是const时，它的所有成员变量也都被视为const，即不能被修改。这意味着你不能在常对象内部修改任何成员变量的值。但是，你可以通过const成员函数来访问这些成员变量的值。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> &#123;  <br><span class="hljs-keyword">public</span>:  <br>    <span class="hljs-type">int</span> x;  <br>    <span class="hljs-built_in">MyClass</span>(<span class="hljs-type">int</span> val) : <span class="hljs-built_in">x</span>(val) &#123;&#125;  <br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">showX</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-comment">// 常成员函数可以访问常对象的成员  </span><br>        std::cout &lt;&lt; x &lt;&lt; std::endl;  <br>    &#125;  <br>    <span class="hljs-comment">// void modifyX(int newVal) const &#123; x = newVal; &#125; // 错误！不能在const成员函数中修改成员  </span><br>&#125;;  <br>  <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;  <br>    <span class="hljs-function"><span class="hljs-type">const</span> MyClass <span class="hljs-title">myConstObj</span><span class="hljs-params">(<span class="hljs-number">5</span>)</span></span>; <span class="hljs-comment">// 常对象  </span><br>    myConstObj.<span class="hljs-built_in">showX</span>(); <span class="hljs-comment">// 可以调用const成员函数来访问成员  </span><br>    <span class="hljs-comment">// myConstObj.x = 10; // 错误！不能修改const对象的成员  </span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;  <br>&#125;<br></code></pre></td></tr></table></figure><h3 id="几种写法对比"><a href="#几种写法对比" class="headerlink" title="几种写法对比"></a>几种写法对比</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Point</span> &#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">Point</span>(<span class="hljs-type">int</span> x = <span class="hljs-number">0</span>, <span class="hljs-type">int</span> y = <span class="hljs-number">0</span>) : <span class="hljs-built_in">x</span>(x), <span class="hljs-built_in">y</span>(y) &#123; &#125;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getX</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>-&gt;x; &#125;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getY</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>-&gt;y; &#125;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> x, y;<br>&#125;;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-function">Point <span class="hljs-title">a</span><span class="hljs-params">(<span class="hljs-number">4</span>, <span class="hljs-number">5</span>)</span></span>; <span class="hljs-comment">//普通对象</span><br>    <span class="hljs-function">Point <span class="hljs-type">const</span> <span class="hljs-title">b</span><span class="hljs-params">(<span class="hljs-number">6</span>,<span class="hljs-number">7</span>)</span></span>; <span class="hljs-comment">//常对象</span><br>    Point* pa = &amp;a; <span class="hljs-comment">//定义对象指针，用a的地址初始化</span><br>    <span class="hljs-type">const</span> Point* pb= &amp;b; <span class="hljs-comment">//定义指向常对象的指针，用常对象b的地址初始化</span><br>    <span class="hljs-type">const</span> Point&amp; rb=  b; <span class="hljs-comment">//定义常引用rb（对于常对象的引用），常对象b的别名</span><br>    cout &lt;&lt; pa-&gt;<span class="hljs-built_in">getX</span>() &lt;&lt; endl;<span class="hljs-comment">//用指针访问对象成员</span><br>    cout&lt;&lt; a.<span class="hljs-built_in">getY</span>() &lt;&lt;endl;<br>    cout &lt;&lt; (*pb).<span class="hljs-built_in">getY</span>() &lt;&lt; endl; <span class="hljs-comment">//用指针求内容运算符访问对象成员</span><br>    cout &lt;&lt; rb.<span class="hljs-built_in">getX</span>() &lt;&lt; endl; <span class="hljs-comment">//用常引用来访问对象成员</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>注意：在 C++ 中，Point&amp; const rb &#x3D; b; 这样的写法实际上是不合法的。原因在于，引用本身在初始化后就不能改变其所绑定的对象，因此将引用本身声明为 const 是没有意义的。换句话说，引用本质上就是常量，一旦它绑定到了一个对象，就不能再被重新绑定到另一个对象。</p><p>所以，Point&amp; const rb &#x3D; b; 这样的声明是多余的，因为 rb 作为一个引用，本身就是不可变的。正确的声明应该只是 Point&amp; rb &#x3D; b;，表示 rb 是对 b 的一个引用。</p><h2 id="2-5static-成员"><a href="#2-5static-成员" class="headerlink" title="2.5static 成员"></a>2.5static 成员</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//当你在函数内部声明一个 static 局部变量时，比如:</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">function</span><span class="hljs-params">()</span> </span>&#123;  <br>    <span class="hljs-type">static</span> <span class="hljs-type">int</span> calls = <span class="hljs-number">0</span>;  <br>    calls++;  <br>    <span class="hljs-comment">// ...  </span><br>&#125;<br></code></pre></td></tr></table></figure><p>这里的 calls 变量有以下几个特点：</p><p>生命周期：calls 的生命周期贯穿整个程序的执行期间，与全局变量的生命周期相同。这意味着，<strong>即使 function 函数返回后，calls 也不会被销毁</strong>，它的值会保留到下一次调用 function。</p><p>初始化：calls 只在程序第一次执行到该变量定义时被初始化一次，之后的函数调用中不会再次初始化。</p><p>作用域：与全局变量不同的是，calls 的作用域仅限于定义它的函数内部。这意味着，只有在 function 函数内部才能访问和修改 calls。在函数外部是无法直接访问这个变量的。</p><p>存储类别：static 局部变量存储在静态存储区，而不是栈内存。</p><p>因此，虽然 static int calls &#x3D; 0; 在函数内部给 calls 赋予了类似全局变量的生命周期和存储类别，但它的作用域仍然是局部的，仅限于定义它的函数内。这与全局变量（在整个程序中都可见）是有所不同的。</p><p>注意：<strong>初始化静态成员变量必须在类外定义</strong></p><h2 id="2-6类的组合"><a href="#2-6类的组合" class="headerlink" title="2.6类的组合"></a>2.6类的组合</h2><p>在C++中，类的组合指的是在一个类中使用其他类的对象作为成员。这种技术允许我们构建更复杂的类，这些类由更简单的组件类组成。下面是一个简单的代码实例，展示了如何在C++中使用类的组合。</p><p>假设我们有一个Student类和一个Address类。每个学生都有一个地址，因此我们可以将Address类的对象作为Student类的一个成员。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span>  </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span>  </span><br>  <br><span class="hljs-comment">// Address类  </span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Address</span> &#123;  <br><span class="hljs-keyword">public</span>:  <br>    <span class="hljs-built_in">Address</span>(<span class="hljs-type">const</span> std::string&amp; street, <span class="hljs-type">const</span> std::string&amp; city, <span class="hljs-type">const</span> std::string&amp; country)  <br>        : <span class="hljs-built_in">street_</span>(street), <span class="hljs-built_in">city_</span>(city), <span class="hljs-built_in">country_</span>(country) &#123;&#125;  <br>  <br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Print</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;  <br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Street: &quot;</span> &lt;&lt; street_ &lt;&lt; <span class="hljs-string">&quot;, City: &quot;</span> &lt;&lt; city_ &lt;&lt; <span class="hljs-string">&quot;, Country: &quot;</span> &lt;&lt; country_ &lt;&lt; std::endl;  <br>    &#125;  <br>  <br><span class="hljs-keyword">private</span>:  <br>    std::string street_;  <br>    std::string city_;  <br>    std::string country_;  <br>&#125;;  <br>  <br><span class="hljs-comment">// Student类，它组合了一个Address对象  </span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> &#123;  <br><span class="hljs-keyword">public</span>:  <br>    <span class="hljs-built_in">Student</span>(<span class="hljs-type">const</span> std::string&amp; name, <span class="hljs-type">const</span> Address&amp; address)  <br>        : <span class="hljs-built_in">name_</span>(name), <span class="hljs-built_in">address_</span>(address) &#123;&#125;  <br>  <br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Introduce</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;  <br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Hello, my name is &quot;</span> &lt;&lt; name_ &lt;&lt; <span class="hljs-string">&quot;. I live at: &quot;</span>;  <br>        address_.<span class="hljs-built_in">Print</span>();  <br>    &#125;  <br>  <br><span class="hljs-keyword">private</span>:  <br>    std::string name_;  <br>    Address address_;  <span class="hljs-comment">// 组合了一个Address对象  </span><br>&#125;;  <br>  <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;  <br>    <span class="hljs-comment">// 创建一个Address对象  </span><br>    <span class="hljs-function">Address <span class="hljs-title">address</span><span class="hljs-params">(<span class="hljs-string">&quot;Main Street&quot;</span>, <span class="hljs-string">&quot;Smallville&quot;</span>, <span class="hljs-string">&quot;Country X&quot;</span>)</span></span>;  <br>    <span class="hljs-comment">// 创建一个Student对象，并传入Address对象作为组合成员  </span><br>    <span class="hljs-function">Student <span class="hljs-title">student</span><span class="hljs-params">(<span class="hljs-string">&quot;John Doe&quot;</span>, address)</span></span>;  <br>    <span class="hljs-comment">// 学生介绍自己，包括姓名和地址信息  </span><br>    student.<span class="hljs-built_in">Introduce</span>();  <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;  <br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2-7友元"><a href="#2-7友元" class="headerlink" title="2.7友元"></a>2.7友元</h2><p>C++中的“友元”（friend）是一个特殊的声明，它允许一个或多个非成员函数或另一个类访问类的私有和保护成员。这是一种<strong>突破数据封装</strong>的方式，通常应当谨慎使用，但在某些情况下，它可以提供很大的便利，特别是在操作符重载和实现某些设计模式时。</p><p><strong>注意事项</strong></p><p>1 过度使用友元可能会破坏封装性，因此应谨慎使用。<br>2 友元关系不是对称的，也不是传递的。即，如果类A是类B的友元，这并不意味着类B也是类A的友元；同样，如果类A是类B的友元，类B是类C的友元，这并不意味着类A是类C的友元。<br>3 友元可以是全局函数、其他类的成员函数或整个类。在类定义中，使用friend关键字声明友元。<br>友元可以是一个函数，也可以是另一个类。下面，我将分别给出这两种情况的代码示例。    </p><h3 id="友元函数"><a href="#友元函数" class="headerlink" title="友元函数"></a>友元函数</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span>  </span><br>  <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> &#123;  <br><span class="hljs-keyword">private</span>:  <br>    <span class="hljs-type">int</span> privateVar;  <br>  <br><span class="hljs-keyword">public</span>:  <br>    <span class="hljs-built_in">MyClass</span>(<span class="hljs-type">int</span> var) : <span class="hljs-built_in">privateVar</span>(var) &#123;&#125;  <br>  <br>    <span class="hljs-comment">// 声明 printMyClass 为友元函数  </span><br>    <span class="hljs-function"><span class="hljs-keyword">friend</span> <span class="hljs-type">void</span> <span class="hljs-title">printMyClass</span><span class="hljs-params">(<span class="hljs-type">const</span> MyClass&amp; obj)</span></span>;  <br>&#125;;  <br>  <br><span class="hljs-comment">// 由于 printMyClass 是 MyClass 的友元函数，所以它可以访问 MyClass 的私有成员  </span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printMyClass</span><span class="hljs-params">(<span class="hljs-type">const</span> MyClass&amp; obj)</span> </span>&#123;  <br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Private variable is: &quot;</span> &lt;&lt; obj.privateVar &lt;&lt; std::endl;  <br>&#125;  <br>  <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;  <br>    <span class="hljs-function">MyClass <span class="hljs-title">obj</span><span class="hljs-params">(<span class="hljs-number">42</span>)</span></span>;  <br>    <span class="hljs-built_in">printMyClass</span>(obj);  <span class="hljs-comment">// 输出: Private variable is: 42  </span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;  <br>&#125;<br></code></pre></td></tr></table></figure><p>当然，如果如果我把<code>void printMyClass(const MyClass&amp; obj) &#123;       std::cout &lt;&lt; &quot;Private variable is: &quot; &lt;&lt; obj.privateVar &lt;&lt; std::endl;   &#125;  </code>放进class的定义里面就不需要使用友元,因为成员函数可以直接访问类的所有成员，包括私有成员。</p><h3 id="友元类"><a href="#友元类" class="headerlink" title="友元类"></a>友元类</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span>  </span><br>  <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> &#123;  <br><span class="hljs-keyword">private</span>:  <br>    <span class="hljs-type">int</span> privateVar;  <br>  <br><span class="hljs-keyword">public</span>:  <br>    <span class="hljs-built_in">MyClass</span>(<span class="hljs-type">int</span> var) : <span class="hljs-built_in">privateVar</span>(var) &#123;&#125;  <br>  <br>    <span class="hljs-comment">// 声明 AnotherClass 为友元类  </span><br>    <span class="hljs-keyword">friend</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AnotherClass</span>;  <br>&#125;;  <br>  <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">AnotherClass</span> &#123;  <br><span class="hljs-keyword">public</span>:  <br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printMyClassPrivateVar</span><span class="hljs-params">(<span class="hljs-type">const</span> MyClass&amp; obj)</span> </span>&#123;  <br>        std::cout &lt;&lt; <span class="hljs-string">&quot;MyClass&#x27;s private variable is: &quot;</span> &lt;&lt; obj.privateVar &lt;&lt; std::endl;  <br>    &#125;  <br>&#125;;  <br>  <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;  <br>    <span class="hljs-function">MyClass <span class="hljs-title">obj</span><span class="hljs-params">(<span class="hljs-number">42</span>)</span></span>;  <br>    AnotherClass anotherObj;  <br>    anotherObj.<span class="hljs-built_in">printMyClassPrivateVar</span>(obj);  <span class="hljs-comment">// 输出: MyClass&#x27;s private variable is: 42  </span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;  <br>&#125;<br><br></code></pre></td></tr></table></figure><h1 id="（三）多态与继承"><a href="#（三）多态与继承" class="headerlink" title="（三）多态与继承"></a>（三）多态与继承</h1><h2 id="3-1-运算符重载"><a href="#3-1-运算符重载" class="headerlink" title="3.1 运算符重载"></a>3.1 运算符重载</h2><p>重载，就是赋予新的含义。函数重载（Function Overloading）可以让一个函数名有多种功能，在不同情况下进行不同的操作。运算符重载（Operator Overloading）也是一个道理，同一个运算符可以有不同的功能。</p><h3 id="3-1-1运算符重载"><a href="#3-1-1运算符重载" class="headerlink" title="3.1.1运算符重载"></a>3.1.1运算符重载</h3><p>举个例子：复数的加法</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span>    </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span>    </span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;  <br>  <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Cmycomplex</span> &#123;    <br><span class="hljs-keyword">private</span>:    <br>    <span class="hljs-type">double</span> real;    <br>    <span class="hljs-type">double</span> imag;    <br><span class="hljs-keyword">public</span>:    <br>    <span class="hljs-built_in">Cmycomplex</span>(<span class="hljs-type">double</span> r = <span class="hljs-number">0.0</span>, <span class="hljs-type">double</span> i = <span class="hljs-number">0.0</span>) : <span class="hljs-built_in">real</span>(r), <span class="hljs-built_in">imag</span>(i) &#123;&#125;    <br>    <span class="hljs-comment">//加法运算实现</span><br>    <span class="hljs-function">Cmycomplex <span class="hljs-title">Add</span><span class="hljs-params">(<span class="hljs-type">const</span> Cmycomplex&amp; oz)</span>  </span>&#123;  <br>        Cmycomplex t;  <br>        t.real = real + oz.real;  <br>        t.imag = imag + oz.imag;  <br>        <span class="hljs-keyword">return</span> t;  <br>    &#125;  <br>    <span class="hljs-comment">// 重载 + 运算符，作为成员函数  </span><br>    Cmycomplex <span class="hljs-keyword">operator</span>+(<span class="hljs-type">const</span> Cmycomplex&amp; oz)  &#123;  <br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">Add</span>(oz);  <br>    &#125;  <br>&#125;;  <br>  <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;  <br>    <span class="hljs-function">Cmycomplex <span class="hljs-title">z1</span><span class="hljs-params">(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>)</span>, z2, <span class="hljs-title">z3</span><span class="hljs-params">(<span class="hljs-number">3</span>)</span></span>;  <br>    z2 = z1 + z3;  <span class="hljs-comment">// 使用重载的 + 运算符  </span><br>    z<span class="hljs-number">2.</span><span class="hljs-built_in">Show</span>();    <span class="hljs-comment">// 输出: (5+3i) 或者 (5+3i) 根据虚部的正负  </span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;  <br>&#125;<br></code></pre></td></tr></table></figure><p>格式即</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp">返回值类型 <span class="hljs-keyword">operator</span> 运算符名称 (形参表列)&#123;<br>    <span class="hljs-comment">//<span class="hljs-doctag">TODO:</span></span><br>&#125;<br></code></pre></td></tr></table></figure><p>在C++中，当你使用c1 + c2这样的表达式时，实际上是调用了c1对象的operator+成员函数，并将c2作为参数传递进去。因此，c1是隐式传递的，因为它是调用该成员函数的对象。</p><p>这里是详细的过程：</p><p>1.当你写c1 + c2时，编译器会查找Cmycomplex类中是否定义了operator+成员函数。</p><p>2.编译器发现Cmycomplex类中确实定义了这样一个成员函数，于是它开始准备调用这个函数。</p><p>3.由于operator+是一个成员函数，它会自动地绑定到调用它的对象上，即c1。因此，c1本身就是函数的调用者（或称为接收者），不需要显式传递。</p><p>4.编译器将c2作为参数传递给c1.operator+(const Cmycomplex&amp; oz)函数。在这个上下文中，oz就是c2的引用。</p><p>5.函数执行加法操作，并返回一个新的Cmycomplex对象，这个对象表示c1和c2的和。</p><p>6.所以，虽然看起来你只传递了一个参数（即c2），但实际上c1也参与了操作，因为它是调用operator+函数的对象。这就是为什么在成员函数内部可以通过this指针来访问调用对象的成员，因为成员函数隐式地与调用它的对象绑定。</p><p>简而言之，c1是通过成员函数调用的隐式绑定机制传入的，而c2是作为参数显式传入的。</p><p><strong>那么如何重载”3+z1”这样的式子呢？</strong></p><p>为了支持 3 + z1 这样的表达式，我们需要为 Cmycomplex 类提供一个非成员函数（友元函数）来重载 operator+，使其能够接受一个 double（或 int）作为第一个参数，和一个 Cmycomplex 对象作为第二个参数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span>  </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span>  </span><br><span class="hljs-comment">//规范小驼峰命名从我做起 </span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Cmycomplex</span> &#123;  <br><span class="hljs-keyword">private</span>:  <br>    <span class="hljs-type">double</span> real;  <br>    <span class="hljs-type">double</span> imag;  <br><span class="hljs-keyword">public</span>:  <br>    <span class="hljs-built_in">Cmycomplex</span>(<span class="hljs-type">double</span> r = <span class="hljs-number">3.0</span>, <span class="hljs-type">double</span> i = <span class="hljs-number">0.0</span>) : <span class="hljs-built_in">real</span>(r), <span class="hljs-built_in">imag</span>(i) &#123;&#125;  <br><span class="hljs-comment">//运算实现</span><br><span class="hljs-function">Cmycomplex <span class="hljs-title">Add</span><span class="hljs-params">(<span class="hljs-type">const</span> Cmycomplex&amp; oz)</span></span><br><span class="hljs-function"></span>&#123;<br>Cmycomplex t;<br>t.real=real+oz.real;<br>t.imag=imag+oz.imag;<br><span class="hljs-keyword">return</span> t;<br>&#125;<br><span class="hljs-comment">//运算符重载</span><br>Cmycomplex <span class="hljs-keyword">operator</span>+(<span class="hljs-type">const</span> Cmycomplex&amp; oz) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">Add</span>(oz);<br>&#125;<br><span class="hljs-comment">//后缀求和 </span><br><span class="hljs-keyword">friend</span> Cmycomplex <span class="hljs-keyword">operator</span>+(<span class="hljs-type">double</span> n, <span class="hljs-type">const</span> Cmycomplex &amp;oz) &#123;<br>             Cmycomplex t;<br>            t.real=n+oz.real;<br>t.imag=oz.imag; <br>            <span class="hljs-keyword">return</span> t;<br>        &#125;<br>&#125;;  <br></code></pre></td></tr></table></figure><p>这在语法上是可行的，但是我们通常不把友元函数的功能在class内部实现，规范的代码应当将定义放在类外以保持代码的清晰和封装性。这样做也有助于将类的接口（即公共成员函数和变量）与其实现细节（即私有和保护成员）分离开来。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span>  </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span>  </span><br><span class="hljs-comment">//规范小驼峰命名从我做起 </span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Cmycomplex</span> &#123;  <br><span class="hljs-keyword">private</span>:  <br>    <span class="hljs-type">double</span> real;  <br>    <span class="hljs-type">double</span> imag;  <br><span class="hljs-keyword">public</span>:  <br>    <span class="hljs-built_in">Cmycomplex</span>(<span class="hljs-type">double</span> r = <span class="hljs-number">3.0</span>, <span class="hljs-type">double</span> i = <span class="hljs-number">0.0</span>) : <span class="hljs-built_in">real</span>(r), <span class="hljs-built_in">imag</span>(i) &#123;&#125;  <br><span class="hljs-comment">//运算实现</span><br><span class="hljs-function">Cmycomplex <span class="hljs-title">Add</span><span class="hljs-params">(<span class="hljs-type">const</span> Cmycomplex&amp; oz)</span></span><br><span class="hljs-function"></span>&#123;<br>Cmycomplex t;<br>t.real=real+oz.real;<br>t.imag=imag+oz.imag;<br><span class="hljs-keyword">return</span> t;<br>&#125;<br><span class="hljs-comment">//运算符重载</span><br>Cmycomplex <span class="hljs-keyword">operator</span>+(<span class="hljs-type">const</span> Cmycomplex&amp; oz) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">Add</span>(oz);<br>&#125;<br><span class="hljs-comment">//后缀求和 </span><br><span class="hljs-keyword">friend</span> Cmycomplex <span class="hljs-keyword">operator</span>+(<span class="hljs-type">double</span> , <span class="hljs-type">const</span> Cmycomplex &amp;) ;<br>        <br>&#125;;  <br>Cmycomplex <span class="hljs-keyword">operator</span>+(<span class="hljs-type">double</span> n, <span class="hljs-type">const</span> Cmycomplex &amp;oz) &#123;<br>             Cmycomplex t;<br>            t.real=n+oz.real;<br>t.imag=oz.imag; <br>            <span class="hljs-keyword">return</span> t;<br>        &#125;<br></code></pre></td></tr></table></figure><h3 id="3-1-2流运算符重载"><a href="#3-1-2流运算符重载" class="headerlink" title="3.1.2流运算符重载"></a>3.1.2流运算符重载</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span>  </span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std<br>  <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Complex</span> &#123;  <br><span class="hljs-keyword">public</span>:  <br>    <span class="hljs-keyword">friend</span> ostream&amp; <span class="hljs-keyword">operator</span>&lt;&lt;(ostream&amp; out, <span class="hljs-type">const</span> Complex&amp; c);  <br>    <span class="hljs-keyword">friend</span> istream&amp; <span class="hljs-keyword">operator</span>&gt;&gt;(istream&amp; in, Complex&amp; c);  <br>  <br><span class="hljs-keyword">private</span>:  <br>    <span class="hljs-type">double</span> real, imag;  <br>&#125;;  <br>  <br><span class="hljs-comment">// 实现输出运算符重载  </span><br>ostream&amp; <span class="hljs-keyword">operator</span>&lt;&lt;(ostream&amp; out, <span class="hljs-type">const</span> Complex&amp; c) &#123;  <br>    out &lt;&lt; <span class="hljs-string">&quot;(&quot;</span> &lt;&lt; c.real &lt;&lt; <span class="hljs-string">&quot;+&quot;</span> &lt;&lt; c.imag &lt;&lt; <span class="hljs-string">&quot;i)&quot;</span>;  <br>    <span class="hljs-keyword">return</span> out;  <br>&#125;  <br>  <br><span class="hljs-comment">// 实现输入运算符重载  </span><br>istream&amp; <span class="hljs-keyword">operator</span>&gt;&gt;(istream&amp; in, Complex&amp; c) &#123;  <br>    in &gt;&gt; c.real &gt;&gt; c.imag;  <br>    <span class="hljs-keyword">return</span> in;  <br>&#125;  <br></code></pre></td></tr></table></figure><p><strong>注意istream&amp; operator&gt;&gt;(istream&amp; in, Complex&amp; c)无const,因为要改变c的内部状态了！！！</strong></p><h3 id="3-1-3自增和自减运算符重载"><a href="#3-1-3自增和自减运算符重载" class="headerlink" title="3.1.3自增和自减运算符重载"></a>3.1.3自增和自减运算符重载</h3><p>这个功能只能在类内实现。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Time</span> &#123;  <br><span class="hljs-keyword">private</span>:  <br>    <span class="hljs-type">int</span> hour, minute, second;  <br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">normalizeTime</span><span class="hljs-params">()</span> </span>&#123;  <span class="hljs-comment">//用这个时间进位初始化 </span><br>        <span class="hljs-comment">//******</span><br>    &#125;  <br><span class="hljs-keyword">public</span>:  <br>    <span class="hljs-comment">//******</span><br>      <br>    Time&amp; <span class="hljs-keyword">operator</span>--() &#123;   <span class="hljs-comment">//前缀 </span><br>        second--;  <br>        <span class="hljs-built_in">normalizeTime</span>();  <br>        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;  <br>    &#125;  <br>    Time <span class="hljs-keyword">operator</span>--(<span class="hljs-type">int</span>)&#123;  <span class="hljs-comment">//后缀</span><br>    Time temp=*<span class="hljs-keyword">this</span>;<br>    second--;<br>    <span class="hljs-keyword">return</span> temp;<br>&#125;  <br>    <span class="hljs-keyword">friend</span> Time <span class="hljs-keyword">operator</span>+(<span class="hljs-type">int</span> ,<span class="hljs-type">const</span> Time&amp;) ;<br>      <br>    <span class="hljs-comment">//*****</span><br>&#125;;<br>Time <span class="hljs-keyword">operator</span>+(<span class="hljs-type">int</span> increase,<span class="hljs-type">const</span> Time&amp; t) &#123;  <br>    <span class="hljs-function">Time <span class="hljs-title">result</span><span class="hljs-params">(t)</span></span>; <span class="hljs-comment">// Make a copy of t  </span><br>    result.second += increase;  <br>    result.<span class="hljs-built_in">normalizeTime</span>();  <br>    <span class="hljs-keyword">return</span> result;  <br>&#125;    <br></code></pre></td></tr></table></figure><h2 id="3-2继承"><a href="#3-2继承" class="headerlink" title="3.2继承"></a>3.2继承</h2><p>保持已有类的特性而构造新类的过程称为继承(inheritance)。      </p><p>在已有类的基础上新增自己的特性而产生新类的过程称为派生。   </p><p>被继承的已有类称为基类(based class)（或父类）。   </p><p>派生出的新类称为派生类(derived class)（或子类）   </p><p>继承的目的：实现代码重用。</p><p>派生的目的：实现代码的可扩充性。当新的问题出现，原有程序无法解决（或不能完全解决）时，需要对原有程序进行改造。</p><p>继承的真正魅力在于<strong>能够添加基类所没有的特点以及取代和改进从基类继承来的特点。</strong></p><p><img src="https://www.freeimg.cn/i/2024/05/09/663cb010b9c3f.png"></p><h3 id="3-2-1子类父类"><a href="#3-2-1子类父类" class="headerlink" title="3.2.1子类父类"></a>3.2.1子类父类</h3><p><strong>关于protected和private的区别:</strong>                </p><p>简而言之，友元类既可以访问private也可以访问protected，但是派生类(子类)只能访问父类的protected</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span>  </span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;  <br>  <br><span class="hljs-comment">// 基类（父类）  </span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Animal</span> &#123;  <br><span class="hljs-keyword">public</span>:  <br>    <span class="hljs-built_in">Animal</span>(string name) : <span class="hljs-built_in">name</span>(name) &#123;&#125;  <br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">eat</span><span class="hljs-params">()</span> </span>&#123;  <br>        cout &lt;&lt; name &lt;&lt; <span class="hljs-string">&quot; is eating.&quot;</span> &lt;&lt; endl;  <br>    &#125;  <br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">sleep</span><span class="hljs-params">()</span> </span>&#123;  <br>        cout &lt;&lt; name &lt;&lt; <span class="hljs-string">&quot; is sleeping.&quot;</span> &lt;&lt; endl;  <br>    &#125;  <br><span class="hljs-keyword">protected</span>:  <span class="hljs-comment">//改为private则子类Dog不可访问</span><br>    string name; <span class="hljs-comment">// 受保护的成员变量，子类可以访问  </span><br>&#125;;  <br>  <br><span class="hljs-comment">// 派生类（子类）  </span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Dog</span> : <span class="hljs-keyword">public</span> Animal &#123; <span class="hljs-comment">// 使用 public 继承  </span><br><span class="hljs-keyword">public</span>:  <br>    <span class="hljs-built_in">Dog</span>(string name) : <span class="hljs-built_in">Animal</span>(name) &#123;&#125; <span class="hljs-comment">// 调用基类的构造函数  </span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">bark</span><span class="hljs-params">()</span> </span>&#123;  <br>        cout &lt;&lt; name &lt;&lt; <span class="hljs-string">&quot; is barking.&quot;</span> &lt;&lt; endl;  <br>    &#125;  <br>&#125;;  <br>  <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;  <br>    <span class="hljs-function">Dog <span class="hljs-title">myDog</span><span class="hljs-params">(<span class="hljs-string">&quot;Rex&quot;</span>)</span></span>; <span class="hljs-comment">// 创建一个 Dog 对象  </span><br>    myDog.<span class="hljs-built_in">eat</span>();     <span class="hljs-comment">// 调用从 Animal 继承的方法  </span><br>    myDog.<span class="hljs-built_in">sleep</span>();   <span class="hljs-comment">// 调用从 Animal 继承的方法  </span><br>    myDog.<span class="hljs-built_in">bark</span>();    <span class="hljs-comment">// 调用 Dog 特有的方法  </span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;  <br>&#125;<br><br><br></code></pre></td></tr></table></figure><p>在这个示例中，我们定义了一个基类 Animal，它包含两个方法：eat() 和 sleep()，以及一个受保护的成员变量 name。然后，我们定义了一个派生类 Dog，它继承自 Animal 类。在 Dog 类中，我们添加了一个新的方法 bark()。</p><p>在 main() 函数中，我们创建了一个 Dog 类的对象 myDog，并调用了它的方法。注意，由于 Dog 继承自 Animal，所以 myDog 可以调用 Animal 类中定义的方法（eat() 和 sleep()），也可以调用 Dog 类中特有的方法（bark()）。</p><p><strong>关于public继承和private继承的区别</strong></p><p><strong>public继承</strong><br>基类的public成员在派生类中仍然是public的。<br>基类的protected成员在派生类中仍然是protected的。<br>派生类外部的代码可以访问派生类中继承自基类的public和protected成员（如果派生类提供了访问这些成员的接口）。<br><strong>private继承</strong><br>基类的public和protected成员在派生类中都变成了private的。<br>派生类外部的代码无法直接访问派生类中继承自基类的任何成员。   </p><p>在C++中，当派生类中存在与基类同名的成员变量或成员函数时，编译器需要一种机制来区分它们。这种情况通常发生在派生类重写（override）基类的成员函数，或者在派生类中声明了与基类同名的成员变量。</p><p><strong>同名成员变量</strong><br>对于成员变量，如果派生类中声明了与基类同名的成员变量，编译器会选择派生类中的变量。这意味着，如果你在派生类的方法中直接使用这个成员变量名，那么编译器将默认使用派生类中的变量，而不是基类中的。</p><p>如果你需要在派生类中访问基类中的同名成员变量，你可以使用作用域解析运算符（::）来明确指定基类的成员变量。例如：</p><p><strong>同名成员函数（非虚函数）对于非虚成员函数，如果你在派生类中定义了一个与基类同名的成员函数（即没有使用 virtual 关键字），这个函数将隐藏基类中的同名函数，而不是重写它。这意味着，如果你通过派生类对象调用这个函数，将执行派生类中的版本。如果你有一个基类指针或引用指向派生类对象，并且调用了这个函数，那么将执行基类中的版本，因为这不是多态行为</strong></p><h3 id="3-2-2多继承"><a href="#3-2-2多继承" class="headerlink" title="3.2.2多继承"></a>3.2.2多继承</h3><p>多继承是指一个类可以同时继承多个基类。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//多继承：</span><br><span class="hljs-keyword">class</span> 派生类名：继承方式  基类名<span class="hljs-number">1</span>，继承方式  基类名<span class="hljs-number">2</span>，......<br>&#123;<br>        成员声明；<br>&#125;;<br>-----------------------------------------------<br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span>  </span><br>  <br><span class="hljs-comment">// 第一个基类：Animal  </span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Animal</span> &#123;  <br><span class="hljs-keyword">public</span>:  <br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">eat</span><span class="hljs-params">()</span> </span>&#123;  <br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Animal eats.&quot;</span> &lt;&lt; std::endl;  <br>    &#125;  <br>&#125;;  <br>  <br><span class="hljs-comment">// 第二个基类：Flyable  </span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Flyable</span> &#123;  <br><span class="hljs-keyword">public</span>:  <br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">fly</span><span class="hljs-params">()</span> </span>&#123;  <br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Flying high in the sky.&quot;</span> &lt;&lt; std::endl;  <br>    &#125;  <br>&#125;;  <br>  <br><span class="hljs-comment">// 派生类：Bird，它继承了Animal和Flyable  </span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Bird</span> : <span class="hljs-keyword">public</span> Animal, <span class="hljs-keyword">public</span> Flyable &#123;  <br><span class="hljs-keyword">public</span>:  <br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">sing</span><span class="hljs-params">()</span> </span>&#123;  <br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Bird sings a beautiful song.&quot;</span> &lt;&lt; std::endl;  <br>    &#125;  <br>&#125;;  <br>  <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;  <br>    Bird bird;  <br>    bird.<span class="hljs-built_in">eat</span>();    <span class="hljs-comment">// 调用继承自Animal的方法  </span><br>    bird.<span class="hljs-built_in">fly</span>();    <span class="hljs-comment">// 调用继承自Flyable的方法  </span><br>    bird.<span class="hljs-built_in">sing</span>();   <span class="hljs-comment">// Bird自己的方法  </span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;  <br>&#125;<br><br></code></pre></td></tr></table></figure><p>在这个例子中，我们有两个基类：Animal 和 Flyable。Animal 类有一个 eat 方法，而 Flyable 类有一个 fly 方法。然后，我们定义了一个派生类 Bird，它同时继承了 Animal 和 Flyable。Bird 类还定义了自己的 sing 方法。</p><p>在 main 函数中，我们创建了一个 Bird 对象，并调用了它的 eat、fly 和 sing 方法。由于 Bird 继承了 Animal 和 Flyable，因此它可以访问这两个基类的方法。</p><p>然而，多继承也可能导致一些问题，特别是菱形继承问题（也称为钻石继承或死亡钻石），这通常发生在当一个类从多个路径继承同一个基类时。这可能导致基类的多个实例在派生类中存在，从而引发歧义和浪费内存。这个问题可以通过虚继承（virtual inheritance）来解决，它确保在继承层次结构中只有一个共享的基类实例。</p><h3 id="3-2-3继承时的构造函数"><a href="#3-2-3继承时的构造函数" class="headerlink" title="3.2.3继承时的构造函数"></a>3.2.3继承时的构造函数</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span>  </span><br>  <br><span class="hljs-comment">// 基类  </span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Vehicle</span> &#123;  <br><span class="hljs-keyword">protected</span>:  <br>    <span class="hljs-type">int</span> wheels;  <br>    <span class="hljs-type">float</span> enginePower;  <br>  <br><span class="hljs-keyword">public</span>:  <br>    <span class="hljs-comment">// 基类的构造函数  </span><br>    <span class="hljs-built_in">Vehicle</span>(<span class="hljs-type">int</span> w, <span class="hljs-type">float</span> p) : <span class="hljs-built_in">wheels</span>(w), <span class="hljs-built_in">enginePower</span>(p) &#123;  <br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Vehicle constructor called with &quot;</span> &lt;&lt; wheels &lt;&lt; <span class="hljs-string">&quot; wheels and &quot;</span> &lt;&lt; enginePower &lt;&lt; <span class="hljs-string">&quot; power.&quot;</span> &lt;&lt; std::endl;  <br>    &#125;  <br>  <br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">displayVehicleInfo</span><span class="hljs-params">()</span> </span>&#123;  <br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Vehicle has &quot;</span> &lt;&lt; wheels &lt;&lt; <span class="hljs-string">&quot; wheels and &quot;</span> &lt;&lt; enginePower &lt;&lt; <span class="hljs-string">&quot; engine power.&quot;</span> &lt;&lt; std::endl;  <br>    &#125;  <br>&#125;;  <br>  <br><span class="hljs-comment">// 派生类  </span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Car</span> : <span class="hljs-keyword">public</span> Vehicle &#123;  <br><span class="hljs-keyword">private</span>:  <br>    <span class="hljs-type">int</span> doors;  <br>  <br><span class="hljs-keyword">public</span>:  <br>    <span class="hljs-comment">// 派生类的构造函数  </span><br>    <span class="hljs-built_in">Car</span>(<span class="hljs-type">int</span> w, <span class="hljs-type">float</span> p, <span class="hljs-type">int</span> d) : <span class="hljs-built_in">Vehicle</span>(w, p), <span class="hljs-built_in">doors</span>(d) &#123;  <br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Car constructor called with &quot;</span> &lt;&lt; doors &lt;&lt; <span class="hljs-string">&quot; doors.&quot;</span> &lt;&lt; std::endl;  <br>    &#125;  <br>  <br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">displayCarInfo</span><span class="hljs-params">()</span> </span>&#123;  <br>        <span class="hljs-built_in">displayVehicleInfo</span>(); <span class="hljs-comment">// 调用基类的成员函数  </span><br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Car has &quot;</span> &lt;&lt; doors &lt;&lt; <span class="hljs-string">&quot; doors.&quot;</span> &lt;&lt; std::endl;  <br>    &#125;  <br>&#125;;  <br>  <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;  <br>    <span class="hljs-function">Car <span class="hljs-title">myCar</span><span class="hljs-params">(<span class="hljs-number">4</span>, <span class="hljs-number">150.0f</span>, <span class="hljs-number">5</span>)</span></span>; <span class="hljs-comment">// 创建一个Car对象，该对象会先调用Vehicle的构造函数，然后调用Car的构造函数  </span><br>    myCar.<span class="hljs-built_in">displayCarInfo</span>(); <span class="hljs-comment">// 显示汽车的信息，包括车轮数量、发动机功率和车门数量  </span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;  <br>&#125;<br></code></pre></td></tr></table></figure><p>在上面的示例中，我们有一个基类Vehicle和一个派生类Car。Vehicle类有一个受保护的成员变量wheels和enginePower，以及一个公共的构造函数来初始化这些变量。Car类继承自Vehicle，并添加了一个新的私有成员变量doors。</p><p>在Car类的构造函数中，我们通过成员初始化列表来调用Vehicle的构造函数，以初始化从Vehicle继承的成员变量。这是通过: Vehicle(w, p)部分完成的，其中w和p是传递给Car构造函数的参数。然后，Car的构造函数继续初始化其自己的成员变量doors。</p><p>在main函数中，我们创建了一个Car对象，并传递了车轮数量、发动机功率和车门数量作为参数。这将依次调用Vehicle和Car的构造函数。最后，我们调用displayCarInfo函数来显示汽车的信息，该函数内部调用了基类的displayVehicleInfo函数来显示车轮数量和发动机功率的信息。</p><h3 id="3-2-4虚函数"><a href="#3-2-4虚函数" class="headerlink" title="3.2.4虚函数"></a>3.2.4虚函数</h3><p>定义了一个基类Animal和两个派生类Dog和Cat。基类Animal中有一个虚函数makeSound()，它在派生类中被重写以提供不同的实现。在main()函数中，我们使用基类指针来调用不同派生类的makeSound()函数，展示了多态性的效果。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span>  </span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;  <br>  <br><span class="hljs-comment">// 基类Animal  </span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Animal</span> &#123;  <br><span class="hljs-keyword">public</span>:  <br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">makeSound</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-comment">// 虚函数声明  </span><br>        cout &lt;&lt; <span class="hljs-string">&quot;Animal makes a sound&quot;</span> &lt;&lt; endl;  <br>    &#125;  <br>&#125;;  <br>  <br><span class="hljs-comment">// 派生类Dog  </span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Dog</span> : <span class="hljs-keyword">public</span> Animal &#123;  <br><span class="hljs-keyword">public</span>:  <br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">makeSound</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span> </span>&#123; <span class="hljs-comment">// 虚函数重写  </span><br>        cout &lt;&lt; <span class="hljs-string">&quot;Dog barks&quot;</span> &lt;&lt; endl;  <br>    &#125;  <br>&#125;;  <br>  <br><span class="hljs-comment">// 派生类Cat  </span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Cat</span> : <span class="hljs-keyword">public</span> Animal &#123;  <br><span class="hljs-keyword">public</span>:  <br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">makeSound</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span> </span>&#123; <span class="hljs-comment">// 虚函数重写  </span><br>        cout &lt;&lt; <span class="hljs-string">&quot;Cat meows&quot;</span> &lt;&lt; endl;  <br>    &#125;  <br>&#125;;  <br>  <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;  <br>    Animal* animalPtr; <span class="hljs-comment">// 基类指针  </span><br>    Dog dog;  <br>    Cat cat;  <br>      <br>    <span class="hljs-comment">// 使用基类指针指向Dog对象，并调用其虚函数  </span><br>    animalPtr = &amp;dog;  <br>    animalPtr-&gt;<span class="hljs-built_in">makeSound</span>(); <span class="hljs-comment">// 输出: Dog barks  </span><br>      <br>    <span class="hljs-comment">// 使用基类指针指向Cat对象，并调用其虚函数  </span><br>    animalPtr = &amp;cat;  <br>    animalPtr-&gt;<span class="hljs-built_in">makeSound</span>(); <span class="hljs-comment">// 输出: Cat meows  </span><br>      <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;  <br>&#125;<br></code></pre></td></tr></table></figure><p>多态性就体现在指针类型是基类*指针，但是却可以指向他的所有派生类并调用所有的重写后的虚函数</p><p>如果一个类中的虚函数没有实现（即函数体为空），则这个函数被称为纯虚函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">AbstractBase</span> &#123;  <br><span class="hljs-keyword">public</span>:  <br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">pureFunc</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>; <span class="hljs-comment">// 纯虚函数声明  </span><br>&#125;;<br><br></code></pre></td></tr></table></figure><h3 id="3-2-5虚析构函数"><a href="#3-2-5虚析构函数" class="headerlink" title="3.2.5虚析构函数"></a>3.2.5虚析构函数</h3><p>对比几段代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//创建子类对象b，然后删除</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span>  </span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;  <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> &#123;  <br><span class="hljs-keyword">public</span>:  <br>     ~<span class="hljs-built_in">A</span>() &#123;  <br>        cout &lt;&lt;<span class="hljs-string">&quot;destructor A\n&quot;</span>;  <br>    &#125;  <br>&#125;; <br><span class="hljs-comment">/*或者写为</span><br><span class="hljs-comment">public:  </span><br><span class="hljs-comment">     virtual ~A() &#123;  </span><br><span class="hljs-comment">        cout &lt;&lt;&quot;destructor A\n&quot;;  </span><br><span class="hljs-comment">    &#125;  </span><br><span class="hljs-comment">&#125;;  </span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span> : <span class="hljs-keyword">public</span> A &#123;  <br><span class="hljs-keyword">public</span>:  <br>    ~<span class="hljs-built_in">B</span>() &#123;  <br>        cout &lt;&lt;<span class="hljs-string">&quot;destructor B\n&quot;</span>;  <br>    &#125;  <br>&#125;;  <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    B* b= <span class="hljs-keyword">new</span> <span class="hljs-built_in">B</span>();<br><span class="hljs-keyword">delete</span> b;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; <br><br>&#125;  <br><span class="hljs-comment">/*</span><br><span class="hljs-comment">运行结果</span><br><span class="hljs-comment">destructor B</span><br><span class="hljs-comment">destructor A</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><p>创建A*指针指向子类对象，一个指向派生类的指针可以隐式地转换为一个指向其基类的指针，这是类型安全的向上转型（upcasting）。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span>  </span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;  <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> &#123;  <br><span class="hljs-keyword">public</span>:  <br>      ~<span class="hljs-built_in">A</span>() &#123;  <br>        cout &lt;&lt;<span class="hljs-string">&quot;destructor A\n&quot;</span>;  <br>    &#125;  <br>&#125;;  <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span> : <span class="hljs-keyword">public</span> A &#123;  <br><span class="hljs-keyword">public</span>:  <br>    ~<span class="hljs-built_in">B</span>() &#123;  <br>        cout &lt;&lt;<span class="hljs-string">&quot;destructor B\n&quot;</span>;  <br>    &#125;  <br>&#125;;  <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    A* pa=<span class="hljs-keyword">new</span> <span class="hljs-built_in">B</span>();<br>    <span class="hljs-keyword">delete</span> pa;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>&#125;  <br><span class="hljs-comment">/*</span><br><span class="hljs-comment">destructor A</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><p>如果改成</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span>  </span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;  <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> &#123;  <br><span class="hljs-keyword">public</span>:  <br>      <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">A</span>() &#123;  <br>        cout &lt;&lt;<span class="hljs-string">&quot;destructor A\n&quot;</span>;  <br>    &#125;  <br>&#125;;  <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span> : <span class="hljs-keyword">public</span> A &#123;  <br><span class="hljs-keyword">public</span>:  <br>    ~<span class="hljs-built_in">B</span>() &#123;  <br>        cout &lt;&lt;<span class="hljs-string">&quot;destructor B\n&quot;</span>;  <br>    &#125;  <br>&#125;;  <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    A* pa=<span class="hljs-keyword">new</span> <span class="hljs-built_in">B</span>();<br>    <span class="hljs-keyword">delete</span> pa;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>&#125;  <br><span class="hljs-comment">/*</span><br><span class="hljs-comment">destructor B</span><br><span class="hljs-comment">destructor A</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><p>这是因为当 delete pa; 被执行时，由于 pa 实际上指向的是一个 B 类的对象，所以需要调用 B 的析构函数来释放 B 部分的资源。<br>由于 B 是从 A 继承的，并且在 A 中定义了虚析构函数，所以在 B 的析构函数执行完毕后，会自动调用基类 A 的析构函数来释放 A 部分的资源。<br>重要的是，基类 A 的析构函数被声明为 virtual。这是非常关键的，因为如果基类析构函数不是虚的，那么在删除派生类对象时就不会调用派生类的析构函数，编译器会根据删除指针的类型调用需要的函数。</p><h3 id="3-2-6-虚继承"><a href="#3-2-6-虚继承" class="headerlink" title="3.2.6 虚继承"></a>3.2.6 虚继承</h3><p>虚继承是面向对象编程中为了解决多重继承时的数据成员重复问题而引入的一种技术。<br>当一个指定的基类在继承体系中被多次继承时，虚继承可以确保这个基类的成员数据在派生类中只存在一份实例。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span>  </span><br>  <br><span class="hljs-comment">// 一个共同的基类  </span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">CommonBase</span> &#123;  <br><span class="hljs-keyword">public</span>:  <br>    <span class="hljs-type">int</span> commonData;  <br>    <span class="hljs-built_in">CommonBase</span>() : <span class="hljs-built_in">commonData</span>(<span class="hljs-number">100</span>) &#123;&#125;  <br>&#125;;  <br>  <br><span class="hljs-comment">// 两个基类，都继承自CommonBase  </span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base1</span> : <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">public</span> CommonBase &#123; <span class="hljs-comment">// 虚继承  </span><br><span class="hljs-keyword">public</span>:  <br>    <span class="hljs-type">int</span> base1Data;  <br>    <span class="hljs-built_in">Base1</span>() : <span class="hljs-built_in">base1Data</span>(<span class="hljs-number">1</span>) &#123;&#125;  <br>&#125;;  <br>  <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base2</span> : <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">public</span> CommonBase &#123; <span class="hljs-comment">// 虚继承  </span><br><span class="hljs-keyword">public</span>:  <br>    <span class="hljs-type">int</span> base2Data;  <br>    <span class="hljs-built_in">Base2</span>() : <span class="hljs-built_in">base2Data</span>(<span class="hljs-number">2</span>) &#123;&#125;  <br>&#125;;  <br>  <br><span class="hljs-comment">// 派生类，多重继承自Base1和Base2  </span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Derived</span> : <span class="hljs-keyword">public</span> Base1, <span class="hljs-keyword">public</span> Base2 &#123;  <br><span class="hljs-keyword">public</span>:  <br>    <span class="hljs-type">int</span> derivedData;  <br>    <span class="hljs-built_in">Derived</span>() : <span class="hljs-built_in">derivedData</span>(<span class="hljs-number">3</span>) &#123;&#125;  <br>&#125;;  <br>  <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;  <br>    Derived d;  <br>      <br>    <span class="hljs-comment">// 如果不使用虚继承，CommonBase的数据成员在Derived中会有两份  </span><br>    <span class="hljs-comment">// 使用虚继承后，Derived中CommonBase的数据成员只有一份  </span><br>    d.commonData = <span class="hljs-number">50</span>; <span class="hljs-comment">// 只有一份commonData，不会有二义性  </span><br>  <br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Derived commonData: &quot;</span> &lt;&lt; d.commonData &lt;&lt; std::endl;  <br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Derived base1Data: &quot;</span> &lt;&lt; d.base1Data &lt;&lt; std::endl;  <br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Derived base2Data: &quot;</span> &lt;&lt; d.base2Data &lt;&lt; std::endl;  <br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Derived derivedData: &quot;</span> &lt;&lt; d.derivedData &lt;&lt; std::endl;  <br>  <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;  <br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="子类父类相互赋值"><a href="#子类父类相互赋值" class="headerlink" title="子类父类相互赋值"></a>子类父类相互赋值</h3><p>父类对象不能直接赋值给子类对象，因为子类可能包含父类没有的额外成员。但是，子类对象可以赋值给父类对象,即只保留子类对象中父类的部分。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span>  </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span>  </span><br>  <br><span class="hljs-comment">// 父类（基类）  </span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Animal</span> &#123;  <br><span class="hljs-keyword">public</span>:  <br>    std::string name;  <br>    <span class="hljs-built_in">Animal</span>(<span class="hljs-type">const</span> std::string&amp; n) : <span class="hljs-built_in">name</span>(n) &#123;&#125;  <br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">speak</span><span class="hljs-params">()</span> </span>&#123;  <br>        std::cout &lt;&lt; <span class="hljs-string">&quot;I&#x27;m an animal named &quot;</span> &lt;&lt; name &lt;&lt; std::endl;  <br>    &#125;  <br>&#125;;  <br>  <br><span class="hljs-comment">// 子类（派生类）  </span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Dog</span> : <span class="hljs-keyword">public</span> Animal &#123;  <br><span class="hljs-keyword">public</span>:  <br>    std::string breed;  <br>    <span class="hljs-built_in">Dog</span>(<span class="hljs-type">const</span> std::string&amp; n, <span class="hljs-type">const</span> std::string&amp; b) : <span class="hljs-built_in">Animal</span>(n), <span class="hljs-built_in">breed</span>(b) &#123;&#125;  <br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">speak</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span> </span>&#123;  <br>        std::cout &lt;&lt; <span class="hljs-string">&quot;I&#x27;m a dog named &quot;</span> &lt;&lt; name &lt;&lt; <span class="hljs-string">&quot; of breed &quot;</span> &lt;&lt; breed &lt;&lt; std::endl;  <br>    &#125;  <br>&#125;;  <br>  <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;  <br>    <span class="hljs-comment">// 创建一个Dog对象  </span><br>    <span class="hljs-function">Dog <span class="hljs-title">myDog</span><span class="hljs-params">(<span class="hljs-string">&quot;Rex&quot;</span>, <span class="hljs-string">&quot;Bulldog&quot;</span>)</span></span>;  <br>    myDog.<span class="hljs-built_in">speak</span>();  <span class="hljs-comment">// 输出: I&#x27;m a dog named Rex of breed Bulldog  </span><br>  <br>    <span class="hljs-comment">// 将Dog对象赋值给Animal对象（切片）  </span><br>    Animal myAnimal = myDog;  <span class="hljs-comment">// 切片发生在这里，只有Animal部分被复制  </span><br>    myAnimal.<span class="hljs-built_in">speak</span>();  <span class="hljs-comment">// 输出: I&#x27;m an animal named Rex  </span><br>  <br>    <span class="hljs-comment">// 注意：以下代码是非法的，因为不能将父类对象赋值给子类对象  </span><br>    <span class="hljs-comment">// Dog anotherDog = myAnimal;  // 编译错误！  </span><br>  <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;  <br>&#125;<br></code></pre></td></tr></table></figure><p>利用指针进行子类父类赋值      </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++">Animal* animalPtr = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Dog</span>(<span class="hljs-string">&quot;Rex&quot;</span>, <span class="hljs-string">&quot;Bulldog&quot;</span>);  <br>animalPtr-&gt;<span class="hljs-built_in">speak</span>();  <span class="hljs-comment">// 如果speak是虚函数，则会调用Dog类的speak实现</span><br><br></code></pre></td></tr></table></figure><p>利用引用进行子类父类赋值<br>与使用指针类似，我们也可以使用引用来实现多态性。引用允许我们直接通过基类引用来访问派生类对象，同时保持多态行为。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">Dog <span class="hljs-title">myDog</span><span class="hljs-params">(<span class="hljs-string">&quot;Rex&quot;</span>, <span class="hljs-string">&quot;Bulldog&quot;</span>)</span></span>;  <br>Animal&amp; animalRef = myDog;  <br>animalRef.<span class="hljs-built_in">speak</span>();  <span class="hljs-comment">// 如果speak是虚函数，则会调用Dog类的speak实现</span><br></code></pre></td></tr></table></figure><h2 id="3-3-理解“绑定”"><a href="#3-3-理解“绑定”" class="headerlink" title="3.3 理解“绑定”"></a>3.3 理解“绑定”</h2><p>在C++中，”绑定”通常指的是将函数调用与具体的函数实现关联起来的过程。根据绑定的时机，我们可以将其分为静态绑定（Static Binding）和动态绑定（Dynamic Binding）。</p><p><strong>静态绑定（Static Binding）</strong></p><p>静态绑定，也称为早期绑定（Early Binding），是指在编译时期就确定函数调用与具体实现的关联。在C++中，非虚函数的调用通常采用静态绑定。编译器在编译时会根据函数名和签名直接解析到具体的函数实现。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span>  </span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;  <br>  <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base</span> &#123;  <br><span class="hljs-keyword">public</span>:  <br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">staticFunc</span><span class="hljs-params">()</span> </span>&#123;  <br>        cout &lt;&lt; <span class="hljs-string">&quot;Base::staticFunc()&quot;</span> &lt;&lt; endl;  <br>    &#125;  <br>&#125;;  <br>  <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Derived</span> : <span class="hljs-keyword">public</span> Base &#123;  <br><span class="hljs-keyword">public</span>:  <br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">staticFunc</span><span class="hljs-params">()</span> </span>&#123;  <br>        cout &lt;&lt; <span class="hljs-string">&quot;Derived::staticFunc()&quot;</span> &lt;&lt; endl;  <br>    &#125;  <br>&#125;;  <br>  <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;  <br>    Base base;  <br>    Derived derived;  <br>  <br>    base.<span class="hljs-built_in">staticFunc</span>();      <span class="hljs-comment">// 输出: Base::staticFunc()  </span><br>    derived.<span class="hljs-built_in">staticFunc</span>();   <span class="hljs-comment">// 输出: Derived::staticFunc()，但这并不是多态，而是隐藏（shadowing）  </span><br>  <br>    Base* basePtr = &amp;derived;  <br>    basePtr-&gt;<span class="hljs-built_in">staticFunc</span>();  <span class="hljs-comment">// 输出: Base::staticFunc()，静态绑定到Base类的函数  </span><br>  <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;  <br>&#125;<br></code></pre></td></tr></table></figure><p>staticFunc 是一个非虚函数，因此它的调用在编译时期就已经确定。即使我们通过基类指针指向派生类对象，并尝试调用 staticFunc，也仍然会调用基类版本的函数。</p><p><strong>动态绑定</strong></p><p>动态绑定，也称为晚期绑定（Late Binding），是指在运行时才确定函数调用与具体实现的关联。在C++中，这通常通过虚函数来实现。当使用基类指针或引用调用虚函数时，实际调用的函数版本会根据指针或引用实际指向的对象类型动态确定。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span>  </span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;  <br>  <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base</span> &#123;  <br><span class="hljs-keyword">public</span>:  <br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">dynamicFunc</span><span class="hljs-params">()</span> </span>&#123;  <br>        cout &lt;&lt; <span class="hljs-string">&quot;Base::dynamicFunc()&quot;</span> &lt;&lt; endl;  <br>    &#125;  <br>&#125;;  <br>  <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Derived</span> : <span class="hljs-keyword">public</span> Base &#123;  <br><span class="hljs-keyword">public</span>:  <br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dynamicFunc</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span> </span>&#123;  <br>        cout &lt;&lt; <span class="hljs-string">&quot;Derived::dynamicFunc()&quot;</span> &lt;&lt; endl;  <br>    &#125;  <br>&#125;;  <br>  <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;  <br>    Base base;  <br>    Derived derived;  <br>    Base* basePtr;  <br>  <br>    base.<span class="hljs-built_in">dynamicFunc</span>();      <span class="hljs-comment">// 输出: Base::dynamicFunc()  </span><br>    derived.<span class="hljs-built_in">dynamicFunc</span>();   <span class="hljs-comment">// 输出: Derived::dynamicFunc()  </span><br>  <br>    basePtr = &amp;base;  <br>    basePtr-&gt;<span class="hljs-built_in">dynamicFunc</span>();  <span class="hljs-comment">// 输出: Base::dynamicFunc()  </span><br>  <br>    basePtr = &amp;derived;  <br>    basePtr-&gt;<span class="hljs-built_in">dynamicFunc</span>();  <span class="hljs-comment">// 输出: Derived::dynamicFunc()，动态绑定到派生类的函数  </span><br>  <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;  <br>&#125;<br></code></pre></td></tr></table></figure><p>dynamicFunc 是一个虚函数。当我们通过基类指针调用它时，实际调用的函数版本会根据指针指向的对象类型动态确定。这就是动态绑定的特点，它允许在运行时实现多态行为。</p><p>总结：</p><p>静态绑定在编译时期确定函数调用，而动态绑定在运行时确定。<br>静态绑定通常与非虚函数相关，而动态绑定则与虚函数相关。<br>动态绑定是实现多态性的关键机制之一。        </p><h1 id="4-c-模版"><a href="#4-c-模版" class="headerlink" title="4.c++模版"></a>4.c++模版</h1><h2 id="4-1函数模版"><a href="#4-1函数模版" class="headerlink" title="4.1函数模版"></a>4.1函数模版</h2><h3 id="函数模版定义与调用"><a href="#函数模版定义与调用" class="headerlink" title="函数模版定义与调用"></a>函数模版定义与调用</h3><p>定义一个函数模板之后，没有指定类型，编译器会实现参数类型的自动推导。考虑单一类型T的场景</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;   <span class="hljs-comment">//开始泛型编程，由于历史原因，typename也可以写成class</span><br><span class="hljs-function">T <span class="hljs-title">Max</span><span class="hljs-params">(<span class="hljs-type">const</span> T&amp; a,<span class="hljs-type">const</span> T&amp; b)</span> </span>&#123;<br><span class="hljs-keyword">return</span> a &gt; b ? a : b;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><br><span class="hljs-type">int</span>  n = <span class="hljs-number">1</span>;<br><span class="hljs-type">int</span> m = <span class="hljs-number">2</span>;<br>cout &lt;&lt; <span class="hljs-string">&quot;max(1, 2) = &quot;</span> &lt;&lt; <span class="hljs-built_in">Max</span>(n, m) &lt;&lt; endl;<br><br><span class="hljs-type">float</span> a = <span class="hljs-number">2.0</span>;<br><span class="hljs-type">float</span> b = <span class="hljs-number">3.0</span>;<br>cout &lt;&lt; <span class="hljs-string">&quot;max(2.0, 3.0) = &quot;</span> &lt;&lt; <span class="hljs-built_in">Max</span>(a, b) &lt;&lt; endl;<br><br><span class="hljs-type">char</span> i = <span class="hljs-string">&#x27;a&#x27;</span>;<br><span class="hljs-type">char</span> j = <span class="hljs-string">&#x27;b&#x27;</span>;<br>cout &lt;&lt; <span class="hljs-string">&quot;max(&#x27;a&#x27;, &#x27;b&#x27;) = &quot;</span> &lt;&lt; <span class="hljs-built_in">Max</span>(i, j) &lt;&lt; endl;<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>也可引入多个类型<br><code>template &lt;typename T, typename T2&gt; </code><br>注意T，T2必须在下文函数中使用，否则编译器会报错。尽管在下面的函数中，T,T2是允许被推导为同一个类型的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">Max</span>&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt;(a, b); <span class="hljs-comment">//显式类型调用</span><br><span class="hljs-built_in">Max</span>(a, b); <span class="hljs-comment">//自动数据类型推导</span><br></code></pre></td></tr></table></figure><h3 id="函数模版与普通函数并存"><a href="#函数模版与普通函数并存" class="headerlink" title="函数模版与普通函数并存"></a>函数模版与普通函数并存</h3><p>当函数模版和普通函数并存的时候：<br>如果函数模板会产生更好的匹配，使用函数模板；<br>其他情况调用普通函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Test</span><span class="hljs-params">(T&amp; a, T&amp; b)</span> </span>&#123;<br>T c;<br>c = a;<br>a = b;<br>b = c;<br><br>cout &lt;&lt; <span class="hljs-string">&quot;Test 函数模板被调用了..&quot;</span> &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Test</span><span class="hljs-params">(<span class="hljs-type">int</span>&amp; a, <span class="hljs-type">int</span>&amp; b)</span> </span>&#123;<br><span class="hljs-type">int</span> c;<br>c = a;<br>a = b;<br>b = c;<br><br>cout &lt;&lt; <span class="hljs-string">&quot;Test 普通函数被调用..&quot;</span> &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure><p>对于这个函数模版      </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> </span>&#123;<br><span class="hljs-type">int</span> n = <span class="hljs-number">99</span>;<br><span class="hljs-type">int</span> m = <span class="hljs-number">65</span>;<br><br><span class="hljs-built_in">Test</span>(n, m);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;   <span class="hljs-comment">//调用普通函数</span><br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> </span>&#123;<br><span class="hljs-type">int</span> n = <span class="hljs-number">99</span>;<br><span class="hljs-type">int</span> m = <span class="hljs-number">65</span>;<br><br>Test&lt;&gt;(n, m);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;   <span class="hljs-comment">//调用函数模版</span><br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> </span>&#123;<br><span class="hljs-type">double</span> n = <span class="hljs-number">99.1</span>;<br><span class="hljs-type">double</span> m = <span class="hljs-number">65.1</span>;<br><br><span class="hljs-built_in">Test</span>(n, m);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    <span class="hljs-comment">//调用函数模版</span><br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> n=<span class="hljs-number">1</span>;<br><span class="hljs-type">char</span> m=<span class="hljs-string">&#x27;c&#x27;</span>;<br><span class="hljs-comment">//报错</span><br></code></pre></td></tr></table></figure><p>函数模版必须严格匹配，函数模板不允许自动类型转化！</p><h3 id="嵌套使用"><a href="#嵌套使用" class="headerlink" title="嵌套使用"></a>嵌套使用</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span><br><span class="hljs-function">T <span class="hljs-title">Max</span><span class="hljs-params">(T a, T b)</span></span><br><span class="hljs-function"></span>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;调用 T Max(T a, T b)&quot;</span> &lt;&lt; endl;<br><span class="hljs-keyword">return</span> a &gt; b ? a : b;<br>&#125;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-function">T <span class="hljs-title">Max</span><span class="hljs-params">(T a, T b, T c)</span> </span>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;调用 T Max(T a, T b, T c)&quot;</span> &lt;&lt; endl;<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">Max</span>(<span class="hljs-built_in">Max</span>(a, b), c);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> </span>&#123;<br><span class="hljs-type">int</span> a = <span class="hljs-number">1</span>;<br><span class="hljs-type">int</span> b = <span class="hljs-number">2</span>;<br><span class="hljs-type">int</span> c = <span class="hljs-number">3</span>;<br><br><span class="hljs-built_in">Max</span>(a, b, c);<br><br><span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>注意每一个函数模版都需要写自己的 template,如果你试图只写一个 template 声明，然后定义两个函数体，那么编译器将无法识别你的意图，并且会报错。每个模板函数都需要它自己的 template 声明。</p><h2 id="4-2类模版"><a href="#4-2类模版" class="headerlink" title="4.2类模版"></a>4.2类模版</h2><h3 id="模版类的定义"><a href="#模版类的定义" class="headerlink" title="模版类的定义"></a>模版类的定义</h3><p>模板类（也称为类模板）提供了一种泛型编程的机制，它允许用户为类定义一个蓝图，这个蓝图可以适应不同的数据类型或参数。<br>模版类的含义就是提供一组可以泛型编程的变量给下面定义的类使用        </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;  <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Array</span> &#123;  <br><span class="hljs-keyword">private</span>:  <br>    T* data;  <br>    <span class="hljs-type">int</span> size;  <br><span class="hljs-keyword">public</span>:  <br>    <span class="hljs-built_in">Array</span>(<span class="hljs-type">int</span> s) : <span class="hljs-built_in">size</span>(s) &#123;  <br>        data = <span class="hljs-keyword">new</span> T[size];  <br>    &#125;  <br>      <br>    ~<span class="hljs-built_in">Array</span>() &#123;  <br>        <span class="hljs-keyword">delete</span>[] data;  <br>    &#125;  <br>  <br>    T&amp; <span class="hljs-keyword">operator</span>[](<span class="hljs-type">int</span> index) &#123;  <br>        <span class="hljs-keyword">return</span> data[index];  <br>    &#125;  <br>  <br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getSize</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;  <br>        <span class="hljs-keyword">return</span> size;  <br>    &#125;  <br>&#125;;<br></code></pre></td></tr></table></figure><p>使用模版类的时候，需要提供具体的数据&#x2F;数据类型实例化这个类</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">Array&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">intArray</span><span class="hljs-params">(<span class="hljs-number">10</span>)</span></span>;    <span class="hljs-comment">// 创建一个存储整数的数组  </span><br><span class="hljs-function">Array&lt;<span class="hljs-type">double</span>&gt; <span class="hljs-title">doubleArray</span><span class="hljs-params">(<span class="hljs-number">5</span>)</span></span>; <span class="hljs-comment">// 创建一个存储双精度浮点数的数组</span><br><br></code></pre></td></tr></table></figure><p>含有常量的实例化</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span>  </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cassert&gt;</span>  </span><br>  <br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-type">int</span> N&gt;  <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">FixedArray</span> &#123;  <br><span class="hljs-keyword">private</span>:  <br>    T data[N];  <br>  <br><span class="hljs-keyword">public</span>:  <br>    <span class="hljs-comment">// 默认构造函数  </span><br>    <span class="hljs-built_in">FixedArray</span>() &#123;&#125;  <br>  <br>    <span class="hljs-comment">// 获取数组大小  </span><br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title">size</span><span class="hljs-params">()</span> </span>&#123;  <br>        <span class="hljs-keyword">return</span> N;  <br>    &#125;  <br>  <br>    <span class="hljs-comment">// 索引操作符重载  </span><br>    T&amp; <span class="hljs-keyword">operator</span>[](<span class="hljs-type">int</span> index) &#123;  <br>        <span class="hljs-built_in">assert</span>(index &gt;= <span class="hljs-number">0</span> &amp;&amp; index &lt; N);  <br>        <span class="hljs-keyword">return</span> data[index];  <br>    &#125;  <br>  <br>    <span class="hljs-comment">// 常量索引操作符重载  </span><br>    <span class="hljs-type">const</span> T&amp; <span class="hljs-keyword">operator</span>[](<span class="hljs-type">int</span> index) <span class="hljs-type">const</span> &#123;  <br>        <span class="hljs-built_in">assert</span>(index &gt;= <span class="hljs-number">0</span> &amp;&amp; index &lt; N);  <br>        <span class="hljs-keyword">return</span> data[index];  <br>    &#125;  <br>&#125;;  <br>  <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;  <br>    <span class="hljs-comment">// 创建一个包含5个整数的FixedArray  </span><br>    FixedArray&lt;<span class="hljs-type">int</span>, <span class="hljs-number">5</span>&gt; intArray;  <br>  <br>    <span class="hljs-comment">// 赋值和访问数组元素  </span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; intArray.<span class="hljs-built_in">size</span>(); ++i) &#123;  <br>        intArray[i] = i * <span class="hljs-number">2</span>;  <br>        std::cout &lt;&lt; intArray[i] &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span>;  <br>    &#125;  <br>    std::cout &lt;&lt; std::endl;  <br>  <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;  <br>&#125;<br></code></pre></td></tr></table></figure><h3 id="模版类的偏特化与全特化"><a href="#模版类的偏特化与全特化" class="headerlink" title="模版类的偏特化与全特化"></a>模版类的偏特化与全特化</h3><p>所谓特化。就是说我们有时候并不想泛化所有模版，我们希望有些类型的模版实现特殊的泛化，为此：      </p><p><strong>全特化（Full Specialization）</strong>     </p><p>全特化是指针对模板类的所有模板参数都提供具体的类型。下面是一个模板类及其全特化的示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 通用模板类  </span><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;  <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> &#123;  <br><span class="hljs-keyword">public</span>:  <br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">()</span> </span>&#123;  <br>        std::cout &lt;&lt; <span class="hljs-string">&quot;General template for type: &quot;</span> &lt;&lt; <span class="hljs-built_in">typeid</span>(T).<span class="hljs-built_in">name</span>() &lt;&lt; std::endl;  <br>    &#125;  <br>&#125;;  <br>  <br><span class="hljs-comment">// 针对int类型的全特化  </span><br><span class="hljs-keyword">template</span>&lt;&gt;    <span class="hljs-comment">//依然需要写一个空的模版参数列表</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span>&lt;<span class="hljs-type">int</span>&gt; &#123;  <br><span class="hljs-keyword">public</span>:  <br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">()</span> </span>&#123;  <br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Specialized template for int&quot;</span> &lt;&lt; std::endl;  <br>    &#125;  <br>&#125;;  <br>  <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;  <br>    MyClass&lt;<span class="hljs-type">double</span>&gt; obj1;  <br>    obj<span class="hljs-number">1.</span><span class="hljs-built_in">print</span>(); <span class="hljs-comment">// 输出: General template for type: d  </span><br>  <br>    MyClass&lt;<span class="hljs-type">int</span>&gt; obj2;  <br>    obj<span class="hljs-number">2.</span><span class="hljs-built_in">print</span>(); <span class="hljs-comment">// 输出: Specialized template for int  </span><br>  <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;  <br>&#125;<br></code></pre></td></tr></table></figure><p><strong>偏特化（Partial Specialization）</strong><br>偏特化是指只针对模板类的部分模板参数提供具体的类型。这通常用于模板类有多个类型参数的情况。下面是一个模板类及其偏特化的示例：  </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 通用模板类，有两个类型参数  </span><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T1, <span class="hljs-keyword">typename</span> T2&gt;  <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyPair</span> &#123;  <br><span class="hljs-keyword">public</span>:  <br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">()</span> </span>&#123;  <br>        std::cout &lt;&lt; <span class="hljs-string">&quot;General template for types: &quot;</span> &lt;&lt; <span class="hljs-built_in">typeid</span>(T1).<span class="hljs-built_in">name</span>() &lt;&lt; <span class="hljs-string">&quot; and &quot;</span> &lt;&lt; <span class="hljs-built_in">typeid</span>(T2).<span class="hljs-built_in">name</span>() &lt;&lt; std::endl;  <br>    &#125;  <br>&#125;;    <br><span class="hljs-comment">// 针对T2为int类型的偏特化  </span><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T1&gt;  <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyPair</span>&lt;T1, <span class="hljs-type">int</span>&gt; &#123;  <br><span class="hljs-keyword">public</span>:  <br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">()</span> </span>&#123;  <br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Partially specialized template for int as the second type&quot;</span> &lt;&lt; std::endl;  <br>    &#125;  <br>&#125;;    <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;  <br>    MyPair&lt;<span class="hljs-type">double</span>, std::string&gt; obj1;  <br>    obj<span class="hljs-number">1.</span><span class="hljs-built_in">print</span>(); <span class="hljs-comment">// 输出: General template for types: d and NSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE  </span><br>  <br>    MyPair&lt;std::string, <span class="hljs-type">int</span>&gt; obj2;  <br>    obj<span class="hljs-number">2.</span><span class="hljs-built_in">print</span>(); <span class="hljs-comment">// 输出: Partially specialized template for int as the second type  </span><br>  <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;  <br>&#125;<br></code></pre></td></tr></table></figure><h1 id="5-异常处理"><a href="#5-异常处理" class="headerlink" title="5.异常处理"></a>5.异常处理</h1><p>给出一段三角形相关的异常处理</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cmath&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">triangle</span><span class="hljs-params">(<span class="hljs-type">double</span> a,<span class="hljs-type">double</span> b,<span class="hljs-type">double</span> c)</span><span class="hljs-comment">//计算三角形面积的函数</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">if</span>(a+b&lt;=c||a+c&lt;=b||b+c&lt;=a)  <span class="hljs-comment">//无法构成三角形则丢出异常</span><br>&#123;<br>string s=<span class="hljs-string">&quot;that is not a triangle!&quot;</span>;<br><span class="hljs-keyword">throw</span> s;<br>&#125;<br>    <span class="hljs-type">double</span> s=(a+b+c)/<span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">sqrt</span>(s*(s-a)*(s-b)*(s-c));<br><br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>       <span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">triangle</span><span class="hljs-params">(<span class="hljs-type">double</span>,<span class="hljs-type">double</span>,<span class="hljs-type">double</span>)</span></span>;<br>       <span class="hljs-type">double</span> a,b,c;<br>       cin&gt;&gt;a&gt;&gt;b&gt;&gt;c;<br>              <span class="hljs-keyword">if</span>(a&gt;<span class="hljs-number">0</span>&amp;&amp;b&gt;<span class="hljs-number">0</span>&amp;&amp;c&gt;<span class="hljs-number">0</span>)<br>              &#123;<br>                     <span class="hljs-keyword">try</span>&#123;     <br>                     cout&lt;&lt;<span class="hljs-built_in">triangle</span>(a,b,c)&lt;&lt;endl;<br> &#125;<br> <span class="hljs-built_in">catch</span>(string&amp; s)&#123;<br> cout&lt;&lt;<span class="hljs-string">&quot;a=&quot;</span>&lt;&lt;a&lt;&lt;<span class="hljs-string">&quot;,b=&quot;</span>&lt;&lt;b&lt;&lt;<span class="hljs-string">&quot;,c=&quot;</span>&lt;&lt;c&lt;&lt;<span class="hljs-string">&quot;,&quot;</span>&lt;&lt;s;<br> &#125;<br> <br>                     cin&gt;&gt;a&gt;&gt;b&gt;&gt;c;<br>              &#125;<br>       &#125;<br></code></pre></td></tr></table></figure><p>实现的核心就在于前面throw出异常，后面try并且catch的过程。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">try</span>&#123;<br>  <span class="hljs-comment">// 可能抛出异常的代码块</span><br>&#125; <span class="hljs-built_in">catch</span>(...) &#123;<br>  <span class="hljs-comment">// 处理异常1</span><br>&#125; <span class="hljs-built_in">catch</span>(···)&#123;<br>  <span class="hljs-comment">// 处理异常2</span><br>&#125;finally &#123;<br>  <span class="hljs-comment">// 无论有无异常都执行</span><br>&#125;<br></code></pre></td></tr></table></figure><p>需要注意的是，这个写法是简化的，并不标准（可以正常运行），规范的代码throw后面有给定的异常类。<br>给出一个除以0的例子    </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span>  </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdexcept&gt;</span> <span class="hljs-comment">// 包含标准异常库  </span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;  <br>  <br><span class="hljs-comment">/**  </span><br><span class="hljs-comment"> * 定义函数division  </span><br><span class="hljs-comment"> * 参数整型dividend、整型divisor  </span><br><span class="hljs-comment"> */</span>  <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">division</span><span class="hljs-params">(<span class="hljs-type">int</span> dividend, <span class="hljs-type">int</span> divisor)</span>  </span><br><span class="hljs-function"></span>&#123;  <br>    <span class="hljs-keyword">if</span> (divisor == <span class="hljs-number">0</span>)  <br>    &#123;  <br>        <span class="hljs-comment">// 抛出异常，因为除数为0  </span><br>        <span class="hljs-keyword">throw</span> <span class="hljs-built_in">invalid_argument</span>(<span class="hljs-string">&quot;除数不能为0&quot;</span>);  <br>    &#125;  <br>    <span class="hljs-keyword">else</span>  <br>    &#123;  <br>        <span class="hljs-keyword">return</span> dividend / divisor;  <br>    &#125;  <br>&#125;  <br>  <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>  </span><br><span class="hljs-function"></span>&#123;  <br>    <span class="hljs-type">int</span> d1 = <span class="hljs-number">0</span>, d2 = <span class="hljs-number">0</span>, r = <span class="hljs-number">0</span>;  <br>    cin &gt;&gt; d1;  <br>    cin &gt;&gt; d2;  <br>  <br>    <span class="hljs-comment">// 使用try...catch...捕获异常  </span><br>    <span class="hljs-keyword">try</span>  <br>    &#123;  <br>        r = <span class="hljs-built_in">division</span>(d1, d2);  <br>        cout &lt;&lt; <span class="hljs-string">&quot;结果是: &quot;</span> &lt;&lt; r &lt;&lt; endl;  <br>    &#125;  <br>    <span class="hljs-built_in">catch</span> (<span class="hljs-type">const</span> invalid_argument&amp; e)  <br>    &#123;  <br>        <span class="hljs-comment">// 显示异常信息  </span><br>        cout &lt;&lt; <span class="hljs-string">&quot;捕获到异常: &quot;</span> &lt;&lt; e.<span class="hljs-built_in">what</span>() &lt;&lt; endl;  <br>    &#125;  <br>  <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;  <br>&#125;<br><br><br></code></pre></td></tr></table></figure><p>以下是一些C++标准库中常见的异常类：     </p><p>std::logic_error：这是所有逻辑错误的基类。逻辑错误通常指的是程序员的错误，例如无效的参数。      </p><p><strong>std::logic_error的直接派生类包括：</strong><br>std::invalid_argument：表示函数接收到了无效的参数。<br>std::domain_error：表示参数的值域不正确，即参数的值不在预期的范围内。<br>std::length_error：试图创建一个超过其最大尺寸的容器时抛出。<br>std::out_of_range：试图访问容器的一个不存在的元素时抛出。  </p><p>std::runtime_error：这是所有运行时错误的基类。运行时错误指的是那些在运行时才能检测到的错误，如资源不足。     </p><p><strong>std::runtime_error的直接派生类包括：</strong><br>std::range_error：表示一个值不在其预期的范围之内时抛出。<br>std::overflow_error：表示算术运算的结果太大，无法用给定的类型表示时抛出。<br>std::underflow_error：表示算术运算的结果太小，无法用给定的类型表示时抛出。<br>std::bad_alloc：当内存分配失败时，如使用new关键字时内存不足，会抛出此异常。<br>std::bad_cast：当进行不安全的类型转换，如dynamic_cast到一个不合适的类型时，会抛出此异常。<br>std::bad_typeid：当typeid操作符被用于一个空指针时，会抛出此异常。<br>std::ios_base::failure：输入输出流错误时会抛出此异常，它是std::exception的派生类，但通常与IO操作关联。<br>除了上述的标准异常外，C++还允许程序员定义自己的异常类。当你需要表示特定的错误条件时，可以创建从std::exception派生的新类。                       </p><h1 id="6-c-文件操作"><a href="#6-c-文件操作" class="headerlink" title="6.c++文件操作"></a>6.c++文件操作</h1><h2 id="写入文件"><a href="#写入文件" class="headerlink" title="写入文件"></a>写入文件</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fstream&gt;</span>  </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span>  </span><br>  <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;  <br>    <span class="hljs-comment">// 创建一个ofstream对象，以写入模式打开文件  </span><br>    <span class="hljs-function">std::ofstream <span class="hljs-title">outfile</span><span class="hljs-params">(<span class="hljs-string">&quot;example.txt&quot;</span>)</span></span>;  <br>  <br>    <span class="hljs-comment">// 检查文件是否成功打开  </span><br>    <span class="hljs-keyword">if</span> (!outfile.<span class="hljs-built_in">is_open</span>()) &#123;  <br>        std::cerr &lt;&lt; <span class="hljs-string">&quot;无法打开文件&quot;</span> &lt;&lt; std::endl;  <br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;  <br>    &#125;  <br>  <br>    <span class="hljs-comment">// 向文件中写入内容  </span><br>    outfile &lt;&lt; <span class="hljs-string">&quot;Hello, World!&quot;</span> &lt;&lt; std::endl;  <br>    outfile &lt;&lt; <span class="hljs-string">&quot;这是一个文件写入示例。&quot;</span> &lt;&lt; std::endl;  <br>  <br>    <span class="hljs-comment">// 关闭文件  </span><br>    outfile.<span class="hljs-built_in">close</span>();  <br>  <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;  <br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="读取文件"><a href="#读取文件" class="headerlink" title="读取文件"></a>读取文件</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fstream&gt;</span>  </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span>  </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span>  </span><br>  <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;  <br>    <span class="hljs-comment">// 创建一个ifstream对象，以读取模式打开文件  </span><br>    <span class="hljs-function">std::ifstream <span class="hljs-title">infile</span><span class="hljs-params">(<span class="hljs-string">&quot;example.txt&quot;</span>)</span></span>;  <br>  <br>    <span class="hljs-comment">// 检查文件是否成功打开  </span><br>    <span class="hljs-keyword">if</span> (!infile.<span class="hljs-built_in">is_open</span>()) &#123;  <br>        std::cerr &lt;&lt; <span class="hljs-string">&quot;无法打开文件&quot;</span> &lt;&lt; std::endl;  <br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;  <br>    &#125;  <br>  <br>    <span class="hljs-comment">// 从文件中读取内容  </span><br>    std::string line;  <br>    <span class="hljs-keyword">while</span> (std::<span class="hljs-built_in">getline</span>(infile, line)) &#123;  <br>        std::cout &lt;&lt; line &lt;&lt; std::endl;  <br>    &#125;  <br>  <br>    <span class="hljs-comment">// 关闭文件  </span><br>    infile.<span class="hljs-built_in">close</span>();  <br>  <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;  <br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>编程语言</category>
      
      <category>c++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>c++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>python面向对象</title>
    <link href="/2025/03/21/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/python%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    <url>/2025/03/21/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/python%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/</url>
    
    <content type="html"><![CDATA[<h1 id="顺序与运算"><a href="#顺序与运算" class="headerlink" title="顺序与运算"></a>顺序与运算</h1><h2 id="内置数据类型"><a href="#内置数据类型" class="headerlink" title="内置数据类型"></a>内置数据类型</h2><table><thead><tr><th>类型</th><th>描述</th><th>举例</th></tr></thead><tbody><tr><td>int</td><td>整数</td><td>123</td></tr><tr><td>float</td><td>浮点数</td><td>1.23, 1.24e5</td></tr><tr><td>str</td><td>字符串</td><td>“python”, ‘acwing’</td></tr><tr><td>bool</td><td>布尔值</td><td>True, False</td></tr><tr><td>list</td><td>列表</td><td>[1, 2, 3]</td></tr><tr><td>tuple</td><td>元组</td><td>(1, 2, 3)</td></tr><tr><td>set</td><td>集合</td><td>{1, 2, 3}</td></tr><tr><td>dict</td><td>字典</td><td>{1: “python”, “acwing”: 2, 3: 4.0}</td></tr></tbody></table><p>注意int 支持高精度</p><h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2><table><thead><tr><th>类别</th><th>运算符</th><th>描述</th><th>示例</th><th>结果</th></tr></thead><tbody><tr><td><strong>算术运算符</strong></td><td><code>+</code></td><td>加法</td><td><code>5 + 3</code></td><td><code>8</code></td></tr><tr><td></td><td><code>-</code></td><td>减法</td><td><code>10 - 2</code></td><td><code>8</code></td></tr><tr><td></td><td><code>*</code></td><td>乘法</td><td><code>3 * 4</code></td><td><code>12</code></td></tr><tr><td></td><td><code>/</code></td><td>除法</td><td><code>10 / 3</code></td><td><code>3.333...</code></td></tr><tr><td></td><td><code>%</code></td><td>取模</td><td><code>10 % 3</code></td><td><code>1</code></td></tr><tr><td></td><td><code>**</code></td><td>幂运算</td><td><code>2 ** 3</code></td><td><code>8</code></td></tr><tr><td></td><td><code>//</code></td><td>整除</td><td><code>10 // 3</code></td><td><code>3</code></td></tr><tr><td><strong>比较运算符</strong></td><td><code>==</code></td><td>等于</td><td><code>5 == 5</code></td><td><code>True</code></td></tr><tr><td></td><td><code>!=</code></td><td>不等于</td><td><code>5 != 3</code></td><td><code>True</code></td></tr><tr><td></td><td><code>&gt;</code></td><td>大于</td><td><code>5 &gt; 3</code></td><td><code>True</code></td></tr><tr><td></td><td><code>&lt;</code></td><td>小于</td><td><code>5 &lt; 3</code></td><td><code>False</code></td></tr><tr><td></td><td><code>&gt;=</code></td><td>大于等于</td><td><code>5 &gt;= 5</code></td><td><code>True</code></td></tr><tr><td></td><td><code>&lt;=</code></td><td>小于等于</td><td><code>5 &lt;= 3</code></td><td><code>False</code></td></tr><tr><td><strong>逻辑运算符</strong></td><td><code>and</code></td><td>逻辑与</td><td><code>True and False</code></td><td><code>False</code></td></tr><tr><td></td><td><code>or</code></td><td>逻辑或</td><td><code>True or False</code></td><td><code>True</code></td></tr><tr><td></td><td><code>not</code></td><td>逻辑非</td><td><code>not True</code></td><td><code>False</code></td></tr><tr><td><strong>赋值运算符</strong></td><td><code>=</code></td><td>赋值</td><td><code>x = 5</code></td><td><code>x = 5</code></td></tr><tr><td></td><td><code>+=</code></td><td>加法赋值</td><td><code>x += 2</code>（等价于<code>x = x + 2</code>）</td><td><code>x = 7</code></td></tr><tr><td></td><td><code>-=</code></td><td>减法赋值</td><td><code>x -= 3</code></td><td><code>x = 4</code></td></tr><tr><td></td><td><code>*=</code></td><td>乘法赋值</td><td><code>x *= 2</code></td><td><code>x = 8</code></td></tr><tr><td></td><td><code>/=</code></td><td>除法赋值</td><td><code>x /= 4</code></td><td><code>x = 2.0</code></td></tr><tr><td></td><td><code>//=</code></td><td>整除赋值</td><td><code>x //= 3</code></td><td><code>x = 2</code></td></tr><tr><td></td><td><code>%=</code></td><td>取模赋值</td><td><code>x %= 3</code></td><td><code>x = 1</code></td></tr><tr><td></td><td><code>**=</code></td><td>幂赋值</td><td><code>x **= 2</code></td><td><code>x = 4</code></td></tr><tr><td><strong>位运算符</strong></td><td><code>&amp;</code></td><td>按位与</td><td><code>0b1010 &amp; 0b1100</code></td><td><code>0b1000</code>（8）</td></tr><tr><td></td><td><code>|</code></td><td>按位或</td><td><code>0b1010 | 0b1100</code></td><td><code>0b1110</code>（14）</td></tr><tr><td></td><td><code>^</code></td><td>按位异或</td><td><code>0b1010 ^ 0b1100</code></td><td><code>0b0110</code>（6）</td></tr><tr><td></td><td><code>~</code></td><td>按位取反</td><td><code>~0b1010</code></td><td><code>-0b1011</code>（-11）</td></tr><tr><td></td><td><code>&lt;&lt;</code></td><td>左移</td><td><code>0b1010 &lt;&lt; 2</code></td><td><code>0b101000</code>（40）</td></tr><tr><td></td><td><code>&gt;&gt;</code></td><td>右移</td><td><code>0b1010 &gt;&gt; 2</code></td><td><code>0b10</code>（2）</td></tr><tr><td><strong>成员运算符</strong></td><td><code>in</code></td><td>检查是否包含</td><td><code>3 in [1, 2, 3]</code></td><td><code>True</code></td></tr><tr><td></td><td><code>not in</code></td><td>检查是否不包含</td><td><code>4 not in &#123;1, 2, 3&#125;</code></td><td><code>True</code></td></tr><tr><td><strong>身份运算符</strong></td><td><code>is</code></td><td>判断是否为同一对象</td><td><code>a = [1]; b = a; a is b</code></td><td><code>True</code></td></tr><tr><td></td><td><code>is not</code></td><td>判断是否不为同一对象</td><td><code>a = [1]; b = [1]; a is not b</code></td><td><code>True</code></td></tr></tbody></table><h2 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h2><p>浮点数和整数之间的隐式类型转换是合法的，整数会转换为浮点数。但在绝大部分情况下，Python 不能进行隐式数据类型转换。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python">a = <span class="hljs-number">5</span><br>b = <span class="hljs-number">2.5</span><br>c = a + b  <span class="hljs-comment"># 这里a会被隐式转换为浮点数，结果为7.5</span><br><br>a = <span class="hljs-number">5</span><br>b = <span class="hljs-string">&quot;10&quot;</span><br>c = a + b  <span class="hljs-comment"># 这会导致 TypeError</span><br><br><span class="hljs-comment"># 使用print()函数输出时，Python 会自动将各种类型的数据转换为字符串进行输出</span><br></code></pre></td></tr></table></figure><p>也可以运用int()、float()、str()等函数强制转换类型。例如：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs py">s = <span class="hljs-string">&quot;123.0&quot;</span><br>a = <span class="hljs-built_in">float</span>(s)<br>b = <span class="hljs-built_in">int</span>(a)<br>s2 = <span class="hljs-string">&quot;The value is &quot;</span> + <span class="hljs-built_in">str</span>(b)<br><br><span class="hljs-built_in">print</span>(s, a, b, s2) <span class="hljs-comment"># 123.0 123.0 123 The value is 123</span><br></code></pre></td></tr></table></figure><h2 id="输入输出"><a href="#输入输出" class="headerlink" title="输入输出"></a>输入输出</h2><h3 id="input-函数"><a href="#input-函数" class="headerlink" title="input() 函数"></a><code>input()</code> 函数</h3><p><code>input()</code> 函数用于从标准输入读取用户输入的数据，它会暂停程序的执行，等待用户输入内容，直到用户按下回车键。函数返回一个字符串类型的值，包含用户输入的所有内容。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">name = <span class="hljs-built_in">input</span>(<span class="hljs-string">&quot;请输入你的名字：&quot;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;你好，<span class="hljs-subst">&#123;name&#125;</span>！&quot;</span>)<br></code></pre></td></tr></table></figure><p>在上述代码中，<code>input()</code> 函数会先显示提示信息 <code>&quot;请输入你的名字：&quot;</code>，然后等待用户输入。用户输入完成并按下回车键后，输入的内容会被赋值给变量 <code>name</code>，最后通过 <code>print()</code> 函数输出问候语。</p><h3 id="2-输入数据类型处理"><a href="#2-输入数据类型处理" class="headerlink" title="2. 输入数据类型处理"></a>2. 输入数据类型处理</h3><p>由于 <code>input()</code> 函数返回的是字符串类型，如果需要使用其他数据类型，需要进行显式类型转换。</p><h4 id="转换为整数"><a href="#转换为整数" class="headerlink" title="转换为整数"></a>转换为整数</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">age = <span class="hljs-built_in">int</span>(<span class="hljs-built_in">input</span>(<span class="hljs-string">&quot;请输入你的年龄：&quot;</span>))<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;你的年龄是 <span class="hljs-subst">&#123;age&#125;</span> 岁。&quot;</span>)<br></code></pre></td></tr></table></figure><p>注意：如果用户输入的内容不能转换为整数，会抛出 <code>ValueError</code> 异常。</p><h4 id="转换为浮点数"><a href="#转换为浮点数" class="headerlink" title="转换为浮点数"></a>转换为浮点数</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">height = <span class="hljs-built_in">float</span>(<span class="hljs-built_in">input</span>(<span class="hljs-string">&quot;请输入你的身高（米）：&quot;</span>))<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;你的身高是 <span class="hljs-subst">&#123;height&#125;</span> 米。&quot;</span>)<br></code></pre></td></tr></table></figure><h3 id="3-处理多个输入"><a href="#3-处理多个输入" class="headerlink" title="3. 处理多个输入"></a>3. 处理多个输入</h3><p>可以通过字符串的分割方法处理多个输入，例如输入多个用空格分隔的数字。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 输入两个空格隔开的整数a,b</span><br><span class="hljs-comment"># 获取用户输入，提示用户输入多个用逗号分隔的数字</span><br>nums = <span class="hljs-built_in">input</span>().split()  <span class="hljs-comment"># 按照空格隔开的要求进行输入，得到一个字符串列表</span><br>a,b = <span class="hljs-built_in">map</span>(<span class="hljs-built_in">int</span>,nums)     <span class="hljs-comment"># 字符串列表转化为只可迭代一次的字符串迭代器，</span><br><span class="hljs-built_in">print</span>(a+b)              <span class="hljs-comment"># 序列解包，给a,b赋值</span><br><br>nums = <span class="hljs-built_in">input</span>().split(<span class="hljs-string">&#x27;,&#x27;</span>) <span class="hljs-comment"># 如果是按照逗号隔开</span><br><br></code></pre></td></tr></table></figure><h3 id="print-函数"><a href="#print-函数" class="headerlink" title="print() 函数"></a><code>print()</code> 函数</h3><p><code>print()</code> 函数用于将对象的字符串表示形式输出到标准输出（通常是控制台）。可以接受一个或多个参数，参数之间用逗号分隔，输出时会用空格分隔各个参数。</p><h4 id="f-string-格式化（Python-3-6-）"><a href="#f-string-格式化（Python-3-6-）" class="headerlink" title="f-string 格式化（Python 3.6+）"></a>f-string 格式化（Python 3.6+）</h4><p>f-string 是一种简洁、直观的字符串格式化方法，在字符串前加上 <code>f</code> 或 <code>F</code>，并在字符串中使用 <code>&#123;&#125;</code> 包含变量名。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">name = <span class="hljs-string">&quot;Charlie&quot;</span><br>age = <span class="hljs-number">35</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;我的名字是 <span class="hljs-subst">&#123;name&#125;</span>，年龄是 <span class="hljs-subst">&#123;age&#125;</span> 岁。&quot;</span>)<br></code></pre></td></tr></table></figure><p>还可以在 <code>&#123;&#125;</code> 中使用表达式：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">radius = <span class="hljs-number">5</span><br>area = <span class="hljs-number">3.14</span> * radius ** <span class="hljs-number">2</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;半径为 <span class="hljs-subst">&#123;radius&#125;</span> 的圆的面积是 <span class="hljs-subst">&#123;area:<span class="hljs-number">.2</span>f&#125;</span>。&quot;</span>)<br><span class="hljs-comment"># :.2f 表示保留两位小数</span><br></code></pre></td></tr></table></figure><p>默认回车结尾，如果想不以换行结尾，可以用如下表达式</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;<span class="hljs-subst">&#123;a&#125;</span>&quot;</span>,end=<span class="hljs-string">&quot; &quot;</span>)<br></code></pre></td></tr></table></figure><h1 id="判断与逻辑"><a href="#判断与逻辑" class="headerlink" title="判断与逻辑"></a>判断与逻辑</h1><ul><li>if和else后需要加上冒号:</li><li>if语句的代码块需要缩进统一长度，规范写法是缩进4个空格。</li><li>注意：else if要写成elif</li><li>pass 语句不执行任何动作。</li></ul><p>if语句内部的变量，可以在语句外访问。例如：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs py">a, b = <span class="hljs-built_in">map</span>(<span class="hljs-built_in">int</span>, <span class="hljs-built_in">input</span>().split())<br><br><span class="hljs-keyword">if</span> a &gt; b:<br>    max_value = a<br><span class="hljs-keyword">else</span>:<br>    max_value = b<br><br><span class="hljs-built_in">print</span>(max_value)<br></code></pre></td></tr></table></figure><p>在 Python 中，变量的作用域是基于代码块的，但是 Python 并没有像 C++ 那样严格的块级作用域。在 C++ 里，if、for、while 等语句块内部定义的变量，其作用域仅限于该语句块；而在 Python 中，函数、类和模块会创建新的作用域，if、for、while 等语句块不会创建新的作用域。</p><p>条件表达式</p><ul><li>(1) 与 and</li><li>(2) 或 or</li><li>(3) 非 not<br>三目运算</li></ul><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs py">a, b = <span class="hljs-built_in">map</span>(<span class="hljs-built_in">int</span>, <span class="hljs-built_in">input</span>().split())<br>max_value = a <span class="hljs-keyword">if</span> a &gt; b <span class="hljs-keyword">else</span> b<br><span class="hljs-built_in">print</span>(max_value)<br></code></pre></td></tr></table></figure><p>Python中交换两个变量，可以用：a, b &#x3D; b, a。<br>Python中的比较运算符支持链式操作，这一点跟C++和Java等语言不同。例如，给三个数排序的代码可以这么写：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs py">a, b, c = <span class="hljs-built_in">map</span>(<span class="hljs-built_in">int</span>, <span class="hljs-built_in">input</span>().split())<br>x, y, z = a, b, c<br><br><span class="hljs-keyword">if</span> a &gt;= b &gt;= c:<br>    <span class="hljs-built_in">print</span>(c, b, a)<br></code></pre></td></tr></table></figure><h1 id="循环语句"><a href="#循环语句" class="headerlink" title="循环语句"></a>循环语句</h1><h2 id="while循环"><a href="#while循环" class="headerlink" title="while循环"></a>while循环</h2><p>while是每次判断，如果条件成立，则执行循环体中的语句，否则停止。</p><ul><li>while后需要加上冒号:</li><li>while语句的代码块需要缩进统一长度，规范写法是缩进4个空格。</li></ul><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs py">n = <span class="hljs-built_in">int</span>(<span class="hljs-built_in">input</span>())<br>a, b, i = <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span><br><span class="hljs-keyword">while</span> i &lt; n:<br>    a, b = b, a + b <span class="hljs-comment"># 序列解包，先把右边的计算完，再赋值给左边的</span><br>    i += <span class="hljs-number">1</span><br><span class="hljs-built_in">print</span>(a)<br></code></pre></td></tr></table></figure><h2 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h2><p>遍历 range</p><p>range()函数可以生成等差数列，可以接收1个、2个或者3个整数参数：</p><ul><li><p>1.接收1个整数参数时：range(x) 会按顺序返回$0,1,2,3,\ldots x-1$这个数列。</p></li><li><p>2.接收2个整数参数时：range(x,y) 会按顺序返回$x,x+1,x+2,\ldots,y-1$这个数列。</p></li><li><p>3.接收3个整数参数时：range(x,y,z) 分为两种情况：</p></li><li><p>z&gt;0 时，按顺序返回$x,x+z,x+2z,x+3z,\ldots$这个数列中小于$y$的所有数。</p></li><li><p>z&lt;0 时，按顺序返回$x,x+z,x+2z,x+3z,\ldots$这个数列中大于$y$的所有数。</p></li></ul><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">5</span>):  <span class="hljs-comment"># 输出：0 1 2 3 4 </span><br>    <span class="hljs-built_in">print</span>(i, end=<span class="hljs-string">&#x27; &#x27;</span>)<br><span class="hljs-built_in">print</span>()  <span class="hljs-comment"># 输出回车</span><br><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">3</span>, <span class="hljs-number">8</span>):  <span class="hljs-comment"># 输出：3 4 5 6 7 </span><br>    <span class="hljs-built_in">print</span>(i, end=<span class="hljs-string">&#x27; &#x27;</span>)<br><span class="hljs-built_in">print</span>()  <span class="hljs-comment"># 输出回车</span><br><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-number">10</span>, <span class="hljs-number">2</span>):  <span class="hljs-comment"># 输出：1 3 5 7 9 </span><br>    <span class="hljs-built_in">print</span>(i, end=<span class="hljs-string">&#x27; &#x27;</span>)<br><span class="hljs-built_in">print</span>()  <span class="hljs-comment"># 输出回车</span><br><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>, -<span class="hljs-number">10</span>, -<span class="hljs-number">2</span>):  <span class="hljs-comment"># 输出：0 -2 -4 -6 -8 </span><br>    <span class="hljs-built_in">print</span>(i, end=<span class="hljs-string">&#x27; &#x27;</span>)<br><span class="hljs-built_in">print</span>()  <span class="hljs-comment"># 输出回车</span><br></code></pre></td></tr></table></figure><h2 id="设计哲学"><a href="#设计哲学" class="headerlink" title="设计哲学"></a>设计哲学</h2><h3 id="思想"><a href="#思想" class="headerlink" title="思想"></a><strong>思想</strong></h3><h4 id="1-基于迭代器模式（与-C-的索引循环不同）"><a href="#1-基于迭代器模式（与-C-的索引循环不同）" class="headerlink" title="1. 基于迭代器模式（与 C++ 的索引循环不同）"></a>1. <strong>基于迭代器模式</strong>（与 C++ 的索引循环不同）</h4><ul><li><p><strong>直接遍历可迭代对象</strong>：无需手动管理索引，直接遍历列表、字典、字符串等。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 遍历列表</span><br><span class="hljs-keyword">for</span> num <span class="hljs-keyword">in</span> [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]:<br>    <span class="hljs-built_in">print</span>(num)  <span class="hljs-comment"># 输出 1, 2, 3</span><br><br><span class="hljs-comment"># 遍历字符串</span><br><span class="hljs-keyword">for</span> char <span class="hljs-keyword">in</span> <span class="hljs-string">&quot;hello&quot;</span>:<br>    <span class="hljs-built_in">print</span>(char)  <span class="hljs-comment"># 输出 h, e, l, l, o</span><br><br><span class="hljs-comment"># 遍历字典键</span><br>d = &#123;<span class="hljs-string">&#x27;a&#x27;</span>: <span class="hljs-number">1</span>, <span class="hljs-string">&#x27;b&#x27;</span>: <span class="hljs-number">2</span>&#125;<br><span class="hljs-keyword">for</span> key <span class="hljs-keyword">in</span> d:<br>    <span class="hljs-built_in">print</span>(key)  <span class="hljs-comment"># 输出 &#x27;a&#x27;, &#x27;b&#x27;</span><br></code></pre></td></tr></table></figure></li><li><p>**对比 C++**：<br>C++ 的 <code>for</code> 循环通常基于索引（如 <code>for(int i=0; i&lt;n; i++)</code>），而 Python 的 <code>for</code> 更接近 C++11 的范围循环（<code>for(auto&amp; x : container)</code>）。</p></li></ul><h4 id="2-支持任何可迭代对象"><a href="#2-支持任何可迭代对象" class="headerlink" title="2. 支持任何可迭代对象"></a>2. <strong>支持任何可迭代对象</strong></h4><ul><li><strong>可迭代对象</strong>：列表、元组、字典、集合、字符串、文件对象、生成器等。<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 遍历文件行</span><br><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;data.txt&quot;</span>) <span class="hljs-keyword">as</span> f:<br>    <span class="hljs-keyword">for</span> line <span class="hljs-keyword">in</span> f:<br>        <span class="hljs-built_in">print</span>(line.strip())<br><br><span class="hljs-comment"># 遍历生成器</span><br>squares = (x**<span class="hljs-number">2</span> <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">5</span>))<br><span class="hljs-keyword">for</span> num <span class="hljs-keyword">in</span> squares:<br>    <span class="hljs-built_in">print</span>(num)  <span class="hljs-comment"># 输出 0, 1, 4, 9, 16</span><br></code></pre></td></tr></table></figure></li></ul><h4 id="3-自动处理迭代细节"><a href="#3-自动处理迭代细节" class="headerlink" title="3. 自动处理迭代细节"></a>3. <strong>自动处理迭代细节</strong></h4><ul><li><strong>无需手动控制索引或迭代器失效</strong>：Python 的迭代器自动管理迭代状态。<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 无需担心索引越界</span><br>lst = [<span class="hljs-number">10</span>, <span class="hljs-number">20</span>, <span class="hljs-number">30</span>]<br><span class="hljs-keyword">for</span> item <span class="hljs-keyword">in</span> lst:<br>    <span class="hljs-built_in">print</span>(item)  <span class="hljs-comment"># 安全遍历</span><br></code></pre></td></tr></table></figure></li></ul><h3 id="二、技巧"><a href="#二、技巧" class="headerlink" title="二、技巧"></a><strong>二、技巧</strong></h3><h4 id="1-使用-enumerate-同时获取索引和值"><a href="#1-使用-enumerate-同时获取索引和值" class="headerlink" title="1. 使用 enumerate 同时获取索引和值"></a>1. <strong>使用 <code>enumerate</code> 同时获取索引和值</strong></h4><ul><li><p><strong>场景</strong>：需要遍历元素并获取索引（类似 C++ 的 <code>for(int i=0; ...)</code>）。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python">fruits = [<span class="hljs-string">&quot;apple&quot;</span>, <span class="hljs-string">&quot;banana&quot;</span>, <span class="hljs-string">&quot;cherry&quot;</span>]<br><span class="hljs-keyword">for</span> index, fruit <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(fruits):<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;Index <span class="hljs-subst">&#123;index&#125;</span>: <span class="hljs-subst">&#123;fruit&#125;</span>&quot;</span>)<br><span class="hljs-comment"># 输出：</span><br><span class="hljs-comment"># Index 0: apple</span><br><span class="hljs-comment"># Index 1: banana</span><br><span class="hljs-comment"># Index 2: cherry</span><br></code></pre></td></tr></table></figure></li><li><p><strong>指定起始索引</strong>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">for</span> idx, val <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(fruits, start=<span class="hljs-number">1</span>):<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;#<span class="hljs-subst">&#123;idx&#125;</span>: <span class="hljs-subst">&#123;val&#125;</span>&quot;</span>)<br></code></pre></td></tr></table></figure></li></ul><h4 id="2-使用-zip-并行遍历多个序列"><a href="#2-使用-zip-并行遍历多个序列" class="headerlink" title="2. 使用 zip 并行遍历多个序列"></a>2. <strong>使用 <code>zip</code> 并行遍历多个序列</strong></h4><ul><li><p><strong>场景</strong>：同时遍历多个列表&#x2F;元组（类似 C++ 的多个迭代器）。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python">names = [<span class="hljs-string">&quot;Alice&quot;</span>, <span class="hljs-string">&quot;Bob&quot;</span>, <span class="hljs-string">&quot;Charlie&quot;</span>]<br>ages = [<span class="hljs-number">25</span>, <span class="hljs-number">30</span>, <span class="hljs-number">35</span>]<br><span class="hljs-keyword">for</span> name, age <span class="hljs-keyword">in</span> <span class="hljs-built_in">zip</span>(names, ages):<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;<span class="hljs-subst">&#123;name&#125;</span> is <span class="hljs-subst">&#123;age&#125;</span> years old&quot;</span>)<br><span class="hljs-comment"># 输出：</span><br><span class="hljs-comment"># Alice is 25</span><br><span class="hljs-comment"># Bob is 30</span><br><span class="hljs-comment"># Charlie is 35</span><br></code></pre></td></tr></table></figure></li><li><p><strong>处理不等长序列</strong>：默认以最短序列为准，可用 <code>itertools.zip_longest</code> 填充。</p></li></ul><h4 id="3-列表推导式（List-Comprehension）"><a href="#3-列表推导式（List-Comprehension）" class="headerlink" title="3. 列表推导式（List Comprehension）"></a>3. <strong>列表推导式（List Comprehension）</strong></h4><ul><li><p><strong>场景</strong>：简化循环创建列表的操作。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 传统写法</span><br>squares = []<br><span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">5</span>):<br>    squares.append(x**<span class="hljs-number">2</span>)<br><br><span class="hljs-comment"># 列表推导式</span><br>squares = [x**<span class="hljs-number">2</span> <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">5</span>)]  <span class="hljs-comment"># [0, 1, 4, 9, 16]</span><br></code></pre></td></tr></table></figure></li><li><p><strong>嵌套循环</strong>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">pairs = [(x, y) <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>] <span class="hljs-keyword">for</span> y <span class="hljs-keyword">in</span> [<span class="hljs-number">3</span>,<span class="hljs-number">4</span>]]<br><span class="hljs-comment"># [(1,3), (1,4), (2,3), (2,4)]</span><br></code></pre></td></tr></table></figure></li></ul><h4 id="4-生成器表达式（Generator-Expression）"><a href="#4-生成器表达式（Generator-Expression）" class="headerlink" title="4. 生成器表达式（Generator Expression）"></a>4. <strong>生成器表达式（Generator Expression）</strong></h4><ul><li><p><strong>场景</strong>：处理大数据时节省内存（惰性计算）。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 生成器表达式（不立即生成全部数据）</span><br>gen = (x**<span class="hljs-number">2</span> <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1000000</span>))<br><span class="hljs-keyword">for</span> num <span class="hljs-keyword">in</span> gen:<br>    <span class="hljs-keyword">if</span> num &gt; <span class="hljs-number">100</span>:<br>        <span class="hljs-keyword">break</span><br>    <span class="hljs-built_in">print</span>(num)<br></code></pre></td></tr></table></figure></li></ul><h4 id="5-遍历字典的键、值或键值对"><a href="#5-遍历字典的键、值或键值对" class="headerlink" title="5. 遍历字典的键、值或键值对"></a>5. <strong>遍历字典的键、值或键值对</strong></h4><ul><li><p><strong>直接遍历键</strong>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">d = &#123;<span class="hljs-string">&#x27;a&#x27;</span>: <span class="hljs-number">1</span>, <span class="hljs-string">&#x27;b&#x27;</span>: <span class="hljs-number">2</span>&#125;<br><span class="hljs-keyword">for</span> key <span class="hljs-keyword">in</span> d:<br>    <span class="hljs-built_in">print</span>(key)  <span class="hljs-comment"># 输出 &#x27;a&#x27;, &#x27;b&#x27;</span><br></code></pre></td></tr></table></figure></li><li><p><strong>遍历键值对</strong>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">for</span> key, value <span class="hljs-keyword">in</span> d.items():<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;<span class="hljs-subst">&#123;key&#125;</span>: <span class="hljs-subst">&#123;value&#125;</span>&quot;</span>)<br></code></pre></td></tr></table></figure></li></ul><h3 id="三、陷阱"><a href="#三、陷阱" class="headerlink" title="三、陷阱"></a><strong>三、陷阱</strong></h3><h4 id="不要在循环中修改正在迭代的列表"><a href="#不要在循环中修改正在迭代的列表" class="headerlink" title="不要在循环中修改正在迭代的列表"></a><strong>不要在循环中修改正在迭代的列表</strong></h4><ul><li><p><strong>错误示例</strong>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">lst = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>]<br><span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> lst:<br>    <span class="hljs-keyword">if</span> x % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>:<br>        lst.remove(x)  <span class="hljs-comment"># 导致跳过元素</span><br><span class="hljs-comment"># 结果可能为 [1, 3]</span><br></code></pre></td></tr></table></figure></li><li><p><strong>正确做法</strong>：遍历副本或使用列表推导式。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 遍历副本</span><br><span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> lst.copy():<br>    <span class="hljs-keyword">if</span> x % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>:<br>        lst.remove(x)<br><br><span class="hljs-comment"># 使用列表推导式</span><br>lst = [x <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> lst <span class="hljs-keyword">if</span> x % <span class="hljs-number">2</span> != <span class="hljs-number">0</span>]<br></code></pre></td></tr></table></figure></li></ul><h3 id="四、与-C-的对比总结"><a href="#四、与-C-的对比总结" class="headerlink" title="四、与 C++ 的对比总结"></a><strong>四、与 C++ 的对比总结</strong></h3><table><thead><tr><th>特性</th><th>Python <code>for</code> 循环</th><th>C++ <code>for</code> 循环</th></tr></thead><tbody><tr><td><strong>迭代对象</strong></td><td>任何可迭代对象（无需索引）</td><td>通常基于索引或迭代器</td></tr><tr><td><strong>内存效率</strong></td><td>生成器支持惰性计算</td><td>需手动优化（如迭代器或范围循环）</td></tr><tr><td><strong>代码简洁性</strong></td><td>高度简洁（如列表推导式）</td><td>需要更多样板代码</td></tr><tr><td><strong>作用域</strong></td><td>循环变量在外部作用域可见</td><td>循环变量通常限定在循环块内</td></tr><tr><td><strong>修改集合</strong></td><td>需谨慎操作（建议遍历副本）</td><td>可能引发迭代器失效（如<code>vector</code>）</td></tr></tbody></table><h1 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h1><p>以下是关于 Python 列表的详细讲解，结合与 C++ 的对比，帮助你快速掌握其核心特性和使用技巧：</p><h3 id="一、Python-列表的核心特性"><a href="#一、Python-列表的核心特性" class="headerlink" title="一、Python 列表的核心特性"></a><strong>一、Python 列表的核心特性</strong></h3><h4 id="1-动态可变序列"><a href="#1-动态可变序列" class="headerlink" title="1. 动态可变序列"></a>1. <strong>动态可变序列</strong></h4><ul><li><strong>动态扩容</strong>：列表长度可动态调整（无需预先声明大小），类似 C++ 的 <code>std::vector</code>，但更灵活。</li><li><strong>异构元素</strong>：允许存储不同类型的数据（如 <code>[1, &quot;hello&quot;, 3.14]</code>），而 C++ 容器要求元素类型一致。</li><li><strong>有序性</strong>：元素按插入顺序存储，支持索引访问。</li></ul><h4 id="2-底层实现"><a href="#2-底层实现" class="headerlink" title="2. 底层实现"></a>2. <strong>底层实现</strong></h4><ul><li><strong>基于动态数组</strong>：Python 列表的底层是动态数组（类似 C++ 的 <code>vector</code>），通过连续内存存储元素。</li><li><strong>扩容机制</strong>：当空间不足时，按一定策略（如容量翻倍）重新分配内存，保证均摊时间复杂度为 O(1)。</li></ul><h3 id="二、列表基本操作"><a href="#二、列表基本操作" class="headerlink" title="二、列表基本操作"></a><strong>二、列表基本操作</strong></h3><h4 id="1-创建列表"><a href="#1-创建列表" class="headerlink" title="1. 创建列表"></a>1. <strong>创建列表</strong></h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 直接初始化</span><br>lst = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]                   <span class="hljs-comment"># [1, 2, 3]</span><br>lst_mixed = [<span class="hljs-number">1</span>, <span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-literal">True</span>, <span class="hljs-number">3.14</span>]  <span class="hljs-comment"># 混合类型</span><br><br><span class="hljs-comment"># 通过生成式</span><br>lst_range = <span class="hljs-built_in">list</span>(<span class="hljs-built_in">range</span>(<span class="hljs-number">5</span>))        <span class="hljs-comment"># [0, 1, 2, 3, 4]</span><br>lst_str = <span class="hljs-built_in">list</span>(<span class="hljs-string">&quot;hello&quot;</span>)           <span class="hljs-comment"># [&#x27;h&#x27;, &#x27;e&#x27;, &#x27;l&#x27;, &#x27;l&#x27;, &#x27;o&#x27;]</span><br></code></pre></td></tr></table></figure><p>做题常用:开一个n*m的列表</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs py">res = [[<span class="hljs-number">0</span> <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(m)] <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n)]<br></code></pre></td></tr></table></figure><h4 id="2-访问元素"><a href="#2-访问元素" class="headerlink" title="2. 访问元素"></a>2. <strong>访问元素</strong></h4><ul><li><strong>正向索引</strong>：从 <code>0</code> 开始。</li><li><strong>反向索引</strong>：从 <code>-1</code> 开始（倒数第一个元素）。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">lst = [<span class="hljs-number">10</span>, <span class="hljs-number">20</span>, <span class="hljs-number">30</span>]<br><span class="hljs-built_in">print</span>(lst[<span class="hljs-number">0</span>])    <span class="hljs-comment"># 10（正向索引）</span><br><span class="hljs-built_in">print</span>(lst[-<span class="hljs-number">1</span>])   <span class="hljs-comment"># 30（反向索引）</span><br></code></pre></td></tr></table></figure><h4 id="3-切片操作"><a href="#3-切片操作" class="headerlink" title="3. 切片操作"></a>3. <strong>切片操作</strong></h4><ul><li><strong>语法</strong>：<code>list[start:end:step]</code>。</li><li><strong>返回新列表</strong>：原列表不受影响。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">lst = [<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>]<br><span class="hljs-built_in">print</span>(lst[<span class="hljs-number">1</span>:<span class="hljs-number">4</span>])     <span class="hljs-comment"># [1, 2, 3]</span><br><span class="hljs-built_in">print</span>(lst[::<span class="hljs-number">2</span>])     <span class="hljs-comment"># [0, 2, 4]（步长为2）</span><br><span class="hljs-built_in">print</span>(lst[::-<span class="hljs-number">1</span>])    <span class="hljs-comment"># [5, 4, 3, 2, 1, 0]（逆序）</span><br></code></pre></td></tr></table></figure><h4 id="4-修改元素"><a href="#4-修改元素" class="headerlink" title="4. 修改元素"></a>4. <strong>修改元素</strong></h4><ul><li><strong>直接赋值</strong>：通过索引或切片。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">lst = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]<br>lst[<span class="hljs-number">1</span>] = <span class="hljs-number">20</span>        <span class="hljs-comment"># [1, 20, 3]</span><br>lst[<span class="hljs-number">0</span>:<span class="hljs-number">2</span>] = [<span class="hljs-number">10</span>, <span class="hljs-number">2</span>] <span class="hljs-comment"># [10, 2, 3]</span><br></code></pre></td></tr></table></figure><h3 id="三、常用方法"><a href="#三、常用方法" class="headerlink" title="三、常用方法"></a><strong>三、常用方法</strong></h3><h4 id="1-增删元素"><a href="#1-增删元素" class="headerlink" title="1. 增删元素"></a>1. <strong>增删元素</strong></h4><table><thead><tr><th>方法</th><th>功能</th><th>示例</th></tr></thead><tbody><tr><td><code>append(x)</code></td><td>尾部添加单个元素</td><td><code>lst.append(4) → [1,2,3,4]</code></td></tr><tr><td><code>extend(iterable)</code></td><td>尾部扩展多个元素（合并列表）</td><td><code>lst.extend([4,5]) → [1,2,3,4,5]</code></td></tr><tr><td><code>insert(i, x)</code></td><td>在索引 <code>i</code> 处插入元素 <code>x</code></td><td><code>lst.insert(1, 99) → [1,99,2,3]</code></td></tr><tr><td><code>remove(x)</code></td><td>删除第一个值为 <code>x</code> 的元素（无则报错）</td><td><code>lst.remove(2) → [1,3]</code></td></tr><tr><td><code>pop([i])</code></td><td>删除并返回索引 <code>i</code> 处的元素（默认尾）</td><td><code>lst.pop(0) → 1</code>，列表变为 <code>[2,3]</code></td></tr><tr><td><code>clear()</code></td><td>清空列表</td><td><code>lst.clear() → []</code></td></tr></tbody></table><h4 id="2-查找与统计"><a href="#2-查找与统计" class="headerlink" title="2. 查找与统计"></a>2. <strong>查找与统计</strong></h4><table><thead><tr><th>方法</th><th>功能</th><th>示例</th></tr></thead><tbody><tr><td><code>index(x)</code></td><td>返回第一个值为 <code>x</code> 的元素的索引</td><td><code>lst.index(2) → 1</code></td></tr><tr><td><code>count(x)</code></td><td>统计值为 <code>x</code> 的元素个数</td><td><code>lst.count(2) → 1</code></td></tr><tr><td><code>in</code> 操作符</td><td>检查元素是否存在</td><td><code>3 in lst → True</code></td></tr></tbody></table><h4 id="3-排序与反转"><a href="#3-排序与反转" class="headerlink" title="3. 排序与反转"></a>3. <strong>排序与反转</strong></h4><table><thead><tr><th>方法</th><th>功能</th><th>示例</th></tr></thead><tbody><tr><td><code>sort(key=None, reverse=False)</code></td><td>原地排序（修改原列表）</td><td><code>lst.sort() → [1,2,3]</code></td></tr><tr><td><code>sorted(lst)</code></td><td>返回新排序列表（原列表不变）</td><td><code>sorted([3,1,2]) → [1,2,3]</code></td></tr><tr><td><code>reverse()</code></td><td>原地反转列表顺序</td><td><code>lst.reverse() → [3,2,1]</code></td></tr></tbody></table><h3 id="四、高级技巧"><a href="#四、高级技巧" class="headerlink" title="四、高级技巧"></a><strong>四、高级技巧</strong></h3><h4 id="1-列表推导式（List-Comprehension）"><a href="#1-列表推导式（List-Comprehension）" class="headerlink" title="1. 列表推导式（List Comprehension）"></a>1. <strong>列表推导式（List Comprehension）</strong></h4><ul><li><p><strong>简化循环创建列表</strong>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 生成平方列表</span><br>squares = [x**<span class="hljs-number">2</span> <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">5</span>)]  <span class="hljs-comment"># [0, 1, 4, 9, 16]</span><br><br><span class="hljs-comment"># 条件过滤</span><br>evens = [x <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">10</span>) <span class="hljs-keyword">if</span> x % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>]  <span class="hljs-comment"># [0, 2, 4, 6, 8]</span><br></code></pre></td></tr></table></figure></li><li><p><strong>嵌套循环</strong>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">pairs = [(i, j) <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>] <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> [<span class="hljs-number">3</span>,<span class="hljs-number">4</span>]]  <span class="hljs-comment"># [(1,3), (1,4), (2,3), (2,4)]</span><br></code></pre></td></tr></table></figure></li></ul><h4 id="2-浅拷贝与深拷贝"><a href="#2-浅拷贝与深拷贝" class="headerlink" title="2. 浅拷贝与深拷贝"></a>2. <strong>浅拷贝与深拷贝</strong></h4><ul><li><p><strong>浅拷贝</strong>：仅复制引用（共享子对象）。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">lst1 = [<span class="hljs-number">1</span>, [<span class="hljs-number">2</span>, <span class="hljs-number">3</span>]]<br>lst2 = lst1.copy()          <span class="hljs-comment"># 浅拷贝</span><br>lst2[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">99</span><br><span class="hljs-built_in">print</span>(lst1)                 <span class="hljs-comment"># [1, [99, 3]]（共享内部列表）</span><br></code></pre></td></tr></table></figure></li><li><p><strong>深拷贝</strong>：完全独立复制所有层级。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> copy<br>lst3 = copy.deepcopy(lst1)  <span class="hljs-comment"># 深拷贝</span><br>lst3[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">100</span><br><span class="hljs-built_in">print</span>(lst1)                 <span class="hljs-comment"># [1, [99, 3]]（原列表不受影响）</span><br></code></pre></td></tr></table></figure></li></ul><h3 id="五、性能分析（对比-C-）"><a href="#五、性能分析（对比-C-）" class="headerlink" title="五、性能分析（对比 C++）"></a><strong>五、性能分析（对比 C++）</strong></h3><table><thead><tr><th>操作</th><th>Python 列表时间复杂度</th><th>C++ <code>std::vector</code> 时间复杂度</th><th>说明</th></tr></thead><tbody><tr><td><strong>访问元素</strong></td><td>O(1)</td><td>O(1)</td><td>均基于索引直接访问</td></tr><tr><td><strong>尾部追加元素</strong></td><td>O(1)（均摊）</td><td>O(1)（均摊）</td><td>动态扩容策略类似</td></tr><tr><td><strong>头部插入元素</strong></td><td>O(n)</td><td>O(n)</td><td>需要移动所有元素</td></tr><tr><td><strong>查找元素</strong></td><td>O(n)</td><td>O(n)</td><td>线性遍历</td></tr><tr><td><strong>切片操作</strong></td><td>O(k)（k 为切片长度）</td><td>无直接支持</td><td>C++ 需手动实现</td></tr></tbody></table><h1 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h1><h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><h2 id="函数基础"><a href="#函数基础" class="headerlink" title="函数基础"></a>函数基础</h2><p>基本形式</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">def</span> <span class="hljs-title function_">fact</span>(<span class="hljs-params">n</span>):<br>    res = <span class="hljs-number">1</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, n + <span class="hljs-number">1</span>):<br>        res *= i<br>    <span class="hljs-keyword">return</span> res<br></code></pre></td></tr></table></figure><p>当函数定义完但还不想实现时，可以用pass占位符，来避免出现语法错误。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">def</span> <span class="hljs-title function_">f</span>():<br>    <span class="hljs-keyword">pass</span><br></code></pre></td></tr></table></figure><p>return语句终止当前正在执行的函数，返回到调用该函数的地方，并返回结果。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">def</span> <span class="hljs-title function_">f</span>(<span class="hljs-params">x</span>):<br>    <span class="hljs-keyword">if</span> x == <span class="hljs-number">1</span>:<br>        <span class="hljs-keyword">return</span>  <span class="hljs-comment"># 不写返回值时，会返回None</span><br>    <span class="hljs-keyword">if</span> x == <span class="hljs-number">2</span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">3</span>  <span class="hljs-comment"># 返回一个变量</span><br>    <span class="hljs-keyword">if</span> x == <span class="hljs-number">3</span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">4</span>, <span class="hljs-number">5</span>  <span class="hljs-comment"># 返回多个变量</span><br></code></pre></td></tr></table></figure><h2 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h2><p>在 Python 中，函数参数初始化包含多个方面的知识，下面将从默认参数、位置参数、关键字参数、可变参数（<code>*args</code> 和 <code>**kwargs</code>）以及参数解包等几个重要角度详细展开讲解。</p><h3 id="1-位置参数"><a href="#1-位置参数" class="headerlink" title="1. 位置参数"></a>1. 位置参数</h3><p>按照参数定义的顺序依次提供对应的值。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">add</span>(<span class="hljs-params">a, b</span>):<br>    <span class="hljs-keyword">return</span> a + b<br><br>result = add(<span class="hljs-number">3</span>, <span class="hljs-number">5</span>)<br><span class="hljs-built_in">print</span>(result)  <span class="hljs-comment"># 输出 8</span><br></code></pre></td></tr></table></figure><h3 id="2-默认参数（初始化）"><a href="#2-默认参数（初始化）" class="headerlink" title="2. 默认参数（初始化）"></a>2. 默认参数（初始化）</h3><p>默认参数允许在定义函数时为参数指定默认值。如果调用函数时没有为该参数提供值，就会使用默认值。</p><p>这里的 <code>greeting</code> 就是一个默认参数，默认值为 <code>&quot;Hello&quot;</code>。当调用 <code>greet</code> 函数时只传入一个参数，<code>greeting</code> 就使用默认值；若传入两个参数，则使用传入的值。</p><p><strong>注意事项</strong>：默认参数必须放在位置参数之后，这与C++相同</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">greet</span>(<span class="hljs-params">name, greeting=<span class="hljs-string">&quot;Hello&quot;</span></span>):<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">f&quot;<span class="hljs-subst">&#123;greeting&#125;</span>, <span class="hljs-subst">&#123;name&#125;</span>!&quot;</span><br><br>message1 = greet(<span class="hljs-string">&quot;Alice&quot;</span>)<br><span class="hljs-built_in">print</span>(message1)  <span class="hljs-comment"># 输出 &quot;Hello, Alice!&quot;</span><br><br>message2 = greet(<span class="hljs-string">&quot;Bob&quot;</span>, <span class="hljs-string">&quot;Hi&quot;</span>)<br><span class="hljs-built_in">print</span>(message2)  <span class="hljs-comment"># 输出 &quot;Hi, Bob!&quot;</span><br></code></pre></td></tr></table></figure><h3 id="3-关键字参数：参数名1-参数值1，参数名2-参数值2"><a href="#3-关键字参数：参数名1-参数值1，参数名2-参数值2" class="headerlink" title="3. 关键字参数：参数名1&#x3D;参数值1，参数名2&#x3D;参数值2"></a>3. 关键字参数：参数名1&#x3D;参数值1，参数名2&#x3D;参数值2</h3><p>关键字参数允许在调用函数时通过参数名来指定参数的值，这样做的好处是可以不按照参数定义的顺序传递参数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">describe_person</span>(<span class="hljs-params">name, age, city</span>):<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">f&quot;<span class="hljs-subst">&#123;name&#125;</span> is <span class="hljs-subst">&#123;age&#125;</span> years old and lives in <span class="hljs-subst">&#123;city&#125;</span>.&quot;</span><br><br><span class="hljs-comment"># 传参的时候写好 参数名= 那么就不用考虑顺序了</span><br>description = describe_person(age=<span class="hljs-number">25</span>, city=<span class="hljs-string">&quot;New York&quot;</span>, name=<span class="hljs-string">&quot;John&quot;</span>)<br><span class="hljs-built_in">print</span>(description)  <span class="hljs-comment"># 输出 &quot;John is 25 years old and lives in New York.&quot;</span><br></code></pre></td></tr></table></figure><h3 id="4-可变参数"><a href="#4-可变参数" class="headerlink" title="4. 可变参数"></a>4. 可变参数</h3><h4 id="args"><a href="#args" class="headerlink" title="*args"></a><code>*args</code></h4><p><code>*args</code> 用于接收任意数量的位置参数，它会将这些参数打包成一个元组。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">sum_numbers</span>(<span class="hljs-params">*args</span>):<br>    total = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> num <span class="hljs-keyword">in</span> args:<br>        total += num<br>    <span class="hljs-keyword">return</span> total<br><br>result = sum_numbers(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>)<br><span class="hljs-built_in">print</span>(result)  <span class="hljs-comment"># 输出 10</span><br></code></pre></td></tr></table></figure><p>在这个例子中，<code>*args</code> 接收了 <code>1</code>、<code>2</code>、<code>3</code>、<code>4</code> 这几个参数，并将它们打包成一个元组 <code>(1, 2, 3, 4)</code>。</p><h4 id="kwargs"><a href="#kwargs" class="headerlink" title="**kwargs"></a><code>**kwargs</code></h4><p><code>**kwargs</code> 用于接收任意数量的关键字参数，它会将这些参数打包成一个字典。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">describe_person</span>(<span class="hljs-params">**kwargs</span>):<br>    <span class="hljs-keyword">for</span> key, value <span class="hljs-keyword">in</span> kwargs.items():<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;<span class="hljs-subst">&#123;key&#125;</span>: <span class="hljs-subst">&#123;value&#125;</span>&quot;</span>)<br><br>describe_person(name=<span class="hljs-string">&quot;Alice&quot;</span>, age=<span class="hljs-number">30</span>, city=<span class="hljs-string">&quot;Los Angeles&quot;</span>)<br><span class="hljs-comment"># 输出:</span><br><span class="hljs-comment"># name: Alice</span><br><span class="hljs-comment"># age: 30</span><br><span class="hljs-comment"># city: Los Angeles</span><br></code></pre></td></tr></table></figure><p>这里的 <code>**kwargs</code> 接收了 <code>name</code>、<code>age</code>、<code>city</code> 这几个关键字参数，并将它们打包成一个字典 <code>&#123;&#39;name&#39;: &#39;Alice&#39;, &#39;age&#39;: 30, &#39;city&#39;: &#39;Los Angeles&#39;&#125;</code>。</p><h3 id="5-参数解包"><a href="#5-参数解包" class="headerlink" title="5. 参数解包"></a>5. 参数解包</h3><p>在调用函数时，可以使用 <code>*</code> 和 <code>**</code> 对可迭代对象和字典进行解包。<br>可以用<code>*</code>将列表解包为若干个位置参数</p><p>可以用<code>**</code>将字典解包为若干个关键字参数（参数名1&#x3D;参数值1，参数名2&#x3D;参数值2）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">add</span>(<span class="hljs-params">a, b</span>):<br>    <span class="hljs-keyword">return</span> a + b<br><br>numbers = [<span class="hljs-number">3</span>, <span class="hljs-number">5</span>]<br>result = add(*numbers)  <span class="hljs-comment"># 等价于 add(3, 5)</span><br><span class="hljs-built_in">print</span>(result)  <span class="hljs-comment"># 输出 8</span><br><br>person = &#123;<span class="hljs-string">&#x27;name&#x27;</span>: <span class="hljs-string">&#x27;Bob&#x27;</span>, <span class="hljs-string">&#x27;age&#x27;</span>: <span class="hljs-number">22</span>&#125;<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">greet</span>(<span class="hljs-params">name, age</span>):<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">f&quot;Hello, <span class="hljs-subst">&#123;name&#125;</span>! You are <span class="hljs-subst">&#123;age&#125;</span> years old.&quot;</span><br><br>message = greet(**person)  <span class="hljs-comment"># 等价于 greet(name=&#x27;Bob&#x27;, age=22)</span><br><span class="hljs-built_in">print</span>(message)  <span class="hljs-comment"># 输出 &quot;Hello, Bob! You are 22 years old.&quot;</span><br></code></pre></td></tr></table></figure><p><code>*numbers</code> 将列表 <code>numbers</code> 解包成位置参数，<code>**person</code> 将字典 <code>person</code> 解包成关键字参数。</p><h2 id="高级性质"><a href="#高级性质" class="headerlink" title="高级性质"></a>高级性质</h2><h3 id="1-参数在函数定义时初始化，而非在函数调用时初始化"><a href="#1-参数在函数定义时初始化，而非在函数调用时初始化" class="headerlink" title="1.参数在函数定义时初始化，而非在函数调用时初始化"></a>1.参数在函数定义时初始化，而非在函数调用时初始化</h3><p>在这个例子中，lst在def函数定义时就被初始化为[],指向了内存中的一个具体实例</p><p>下面每一次调用函数都是在对这个实例不断的增删改查</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">def</span> <span class="hljs-title function_">append_item</span>(<span class="hljs-params">item, lst=[]</span>):<br>    lst.append(item)<br>    <span class="hljs-keyword">return</span> lst<br><br><span class="hljs-built_in">print</span>(append_item(<span class="hljs-number">1</span>))  <span class="hljs-comment"># 输出 [1]</span><br><span class="hljs-built_in">print</span>(append_item(<span class="hljs-number">2</span>))  <span class="hljs-comment"># 输出 [1, 2]，而不是 [2]</span><br></code></pre></td></tr></table></figure><p>在这个例子中，lst在函数调用过程中采被赋予了确定的值，这个lst是函数调用过程中创建的值，生命周期随着函数消失而消失</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">def</span> <span class="hljs-title function_">append_item</span>(<span class="hljs-params">item, lst=<span class="hljs-literal">None</span></span>):<br>    <span class="hljs-keyword">if</span> lst <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>        lst = []<br>    lst.append(item)<br>    <span class="hljs-keyword">return</span> lst<br><br><span class="hljs-built_in">print</span>(append_item(<span class="hljs-number">1</span>))  <span class="hljs-comment"># 输出 [1]</span><br><span class="hljs-built_in">print</span>(append_item(<span class="hljs-number">2</span>))  <span class="hljs-comment"># 输出 [2]</span><br></code></pre></td></tr></table></figure><h3 id="2-可变对象和不可变对象的参数传递机制不同"><a href="#2-可变对象和不可变对象的参数传递机制不同" class="headerlink" title="2.可变对象和不可变对象的参数传递机制不同"></a>2.可变对象和不可变对象的参数传递机制不同</h3><p>不可变对象（如数值、字符串）：类似C++的值传递，函数内修改不影响外部变量。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">def</span> <span class="hljs-title function_">modify_num</span>(<span class="hljs-params">x</span>):<br>    x = <span class="hljs-number">10</span>  <span class="hljs-comment"># 不影响外部x</span><br><br>a = <span class="hljs-number">5</span><br>modify_num(a)<br><span class="hljs-built_in">print</span>(a)  <span class="hljs-comment"># 输出5</span><br></code></pre></td></tr></table></figure><p>可变对象（如列表、NumPy数组）：类似C++的引用传递，函数内修改会影响外部，但重新赋值引用（不影响外部）</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-comment"># 可变对象（列表）</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">modify_mutable</span>(<span class="hljs-params">lst</span>):<br>    lst.append(<span class="hljs-number">4</span>)  <span class="hljs-comment"># 修改原对象</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">reassign_mutable</span>(<span class="hljs-params">lst</span>):<br>    lst = [<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>]  <span class="hljs-comment"># 重新赋值引用（不影响外部）</span><br><br><span class="hljs-comment"># 初始化</span><br>my_list = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]<br><br>modify_mutable(my_list)<br><span class="hljs-built_in">print</span>(my_list)      <span class="hljs-comment"># 输出 [1,2,3,4]</span><br><br>reassign_mutable(my_list)<br><span class="hljs-built_in">print</span>(my_list)      <span class="hljs-comment"># 输出 [1,2,3,4]</span><br></code></pre></td></tr></table></figure><h3 id="3-lambda表达式"><a href="#3-lambda表达式" class="headerlink" title="3.lambda表达式"></a>3.lambda表达式</h3><p><code>lambda</code> 表达式是 Python 中一种创建匿名函数的方式。它允许快速定义简单的、一次性使用的函数。</p><p><code>lambda</code> 表达式的基本语法如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">lambda</span> 参数列表: 表达式<br></code></pre></td></tr></table></figure><ul><li><code>lambda</code>：关键字，用于声明这是一个 <code>lambda</code> 表达式。</li><li><code>参数列表</code>：和普通函数的参数列表类似，可以有零个或多个参数，多个参数之间用逗号分隔。</li><li><code>表达式</code>：函数的返回值，<code>lambda</code> 表达式只能包含一个表达式，不能包含复杂的语句块。</li></ul><p>例如，定义一个简单的 <code>lambda</code> 函数来实现两个数相加：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">add = <span class="hljs-keyword">lambda</span> x, y: x + y<br>result = add(<span class="hljs-number">3</span>, <span class="hljs-number">5</span>)<br><span class="hljs-built_in">print</span>(result)  <span class="hljs-comment"># 输出 8</span><br></code></pre></td></tr></table></figure><p>这里 <code>lambda x, y: x + y</code> 定义了一个匿名函数add，它接受两个参数 <code>x</code> 和 <code>y</code>，并返回它们的和。</p><p>在一些内置函数（如 <code>sorted()</code>、<code>map()</code>、<code>filter()</code> 等）中，经常需要传入一个函数作为参数来定义排序规则或对元素进行处理。<br><code>lambda</code> 表达式可以很方便地创建这种一次性使用的函数。以sort函数为例子</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs py">pairs = [[<span class="hljs-number">1</span>, <span class="hljs-string">&quot;one&quot;</span>], [<span class="hljs-number">2</span>, <span class="hljs-string">&quot;two&quot;</span>], [<span class="hljs-number">3</span>, <span class="hljs-string">&quot;three&quot;</span>], [<span class="hljs-number">4</span>, <span class="hljs-string">&quot;four&quot;</span>]]<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">compare</span>(<span class="hljs-params">pair</span>):<br>    <span class="hljs-keyword">return</span> pair[<span class="hljs-number">1</span>]<br><br><br>pairs.sort(key=compare)  <span class="hljs-comment"># 每个元素使用第二个变量比较大小</span><br><span class="hljs-built_in">print</span>(pairs)  <span class="hljs-comment"># 输出：[[4, &#x27;four&#x27;], [1, &#x27;one&#x27;], [3, &#x27;three&#x27;], [2, &#x27;two&#x27;]]</span><br></code></pre></td></tr></table></figure><p>等价于下面的写法：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs py">pairs = [[<span class="hljs-number">1</span>, <span class="hljs-string">&quot;one&quot;</span>], [<span class="hljs-number">2</span>, <span class="hljs-string">&quot;two&quot;</span>], [<span class="hljs-number">3</span>, <span class="hljs-string">&quot;three&quot;</span>], [<span class="hljs-number">4</span>, <span class="hljs-string">&quot;four&quot;</span>]]<br><br>pairs.sort(key=<span class="hljs-keyword">lambda</span> pair: pair[<span class="hljs-number">1</span>])  <span class="hljs-comment"># 每个元素使用第二个变量比较大小</span><br><span class="hljs-built_in">print</span>(pairs)  <span class="hljs-comment"># 输出：[[4, &#x27;four&#x27;], [1, &#x27;one&#x27;], [3, &#x27;three&#x27;], [2, &#x27;two&#x27;]]</span><br></code></pre></td></tr></table></figure><h1 id="其他数据结构"><a href="#其他数据结构" class="headerlink" title="其他数据结构"></a>其他数据结构</h1><h2 id="1-元组"><a href="#1-元组" class="headerlink" title="1.元组"></a>1.元组</h2><p>元组跟列表类似，只是不支持动态添加、删除元素，以及不能修改元素。</p><h3 id="1-1-元组的初始化"><a href="#1-1-元组的初始化" class="headerlink" title="1.1 元组的初始化"></a>1.1 元组的初始化</h3><p>元组需要用小括号括起来，中间的元素用逗号隔开。<br>注意，如果初始化只包含一个元素的元组，需要在该元素后添加逗号。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs py">a = ()  <span class="hljs-comment"># 初始化一个空元组</span><br>b = (<span class="hljs-number">1</span>, <span class="hljs-number">2</span>)  <span class="hljs-comment"># 含有2个整数的元组</span><br>c = <span class="hljs-number">6</span>, <span class="hljs-string">&quot;Python&quot;</span>, <span class="hljs-number">3.14</span>  <span class="hljs-comment"># 小括号可以省略，等价于(6, &quot;Python&quot;, 3.14)</span><br>d = (<span class="hljs-number">5</span>,)  <span class="hljs-comment"># 注意不能写成(5)，(5)表示整数5</span><br>e = <span class="hljs-number">5</span>,  <span class="hljs-comment"># 等价于(5,)</span><br><br><span class="hljs-built_in">print</span>(a, b, c, d, e)<br><span class="hljs-number">1.2</span> 元组的解包<br>t = <span class="hljs-number">12345</span>, <span class="hljs-number">54321</span>, <span class="hljs-string">&quot;Hello!&quot;</span>  <span class="hljs-comment"># 初始化一个元组</span><br>x, y, z = t  <span class="hljs-comment"># 将元组解包，将元组内的三个值按顺序赋值给x、y、z</span><br><span class="hljs-built_in">print</span>(x, y, z)<br>所以，<span class="hljs-number">2.</span> 判断语句中学习的交换操作，本质上是元组的解包：<br><br>a, b = <span class="hljs-number">3</span>, <span class="hljs-number">4</span>  <span class="hljs-comment"># 将元组(3, 4)解包，分别赋值给a、b</span><br>a, b = b, a  <span class="hljs-comment"># 将元组(b, a)解包，分别赋值给a、b</span><br>同样地，<span class="hljs-number">6.</span> 函数中函数返回多个值，本质上也是返回了一个元组：<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">calc</span>(<span class="hljs-params">x, y</span>):<br>    <span class="hljs-keyword">return</span> x + y, x * y  <span class="hljs-comment"># 等价于 return (x + y, x * y)</span><br><br><br>x, y = <span class="hljs-number">3</span>, <span class="hljs-number">4</span><br>s, p = calc(x, y)  <span class="hljs-comment"># 将(x + y, x * y)解包，分别赋值给s、p</span><br><span class="hljs-built_in">print</span>(s, p)<br></code></pre></td></tr></table></figure><h3 id="1-3-元组的比较运算"><a href="#1-3-元组的比较运算" class="headerlink" title="1.3 元组的比较运算"></a>1.3 元组的比较运算</h3><p>元组和列表均支持比较运算符：&#x3D;&#x3D;、!&#x3D;、&gt;、&lt;、&gt;&#x3D;、&lt;&#x3D;等，按字典序进行比较。</p><h3 id="1-4-元组的其他操作"><a href="#1-4-元组的其他操作" class="headerlink" title="1.4 元组的其他操作"></a>1.4 元组的其他操作</h3><p>元组的下标访问元素、循环遍历、切片、加法和乘法运算等操作，都与列表相同。</p><h2 id="2-集合"><a href="#2-集合" class="headerlink" title="2. 集合"></a>2. 集合</h2><p>集合是Python中最常用的数据结构之一，用来存储不同元素。<br>注意，集合中的元素是无序的。</p><h3 id="2-1-集合的初始化"><a href="#2-1-集合的初始化" class="headerlink" title="2.1 集合的初始化"></a>2.1 集合的初始化</h3><p>创建集合用花括号或set()函数。注意：</p><ul><li>创建空集合只能用set()，不能用{}，因为{}创建的是空字典</li></ul><p>集合常见的初始化方式：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs py">basket = &#123;<span class="hljs-string">&#x27;apple&#x27;</span>, <span class="hljs-string">&#x27;orange&#x27;</span>, <span class="hljs-string">&#x27;apple&#x27;</span>, <span class="hljs-string">&#x27;pear&#x27;</span>, <span class="hljs-string">&#x27;orange&#x27;</span>, <span class="hljs-string">&#x27;banana&#x27;</span>&#125;  <span class="hljs-comment"># 会自动去除重复元素</span><br><span class="hljs-built_in">print</span>(basket)  <span class="hljs-comment"># 重复的元素已经去除了</span><br><br>s = <span class="hljs-built_in">set</span>()  <span class="hljs-comment"># 初始化一个空列表</span><br><span class="hljs-built_in">print</span>(s)<br><br>a = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">1</span>]<br>b = <span class="hljs-built_in">set</span>(a)  <span class="hljs-comment"># 将列表转化成集合，一般是为了去重。</span><br>c = <span class="hljs-built_in">list</span>(b)  <span class="hljs-comment"># 将集合转化回列表</span><br><span class="hljs-built_in">print</span>(b, c)<br><br>x = <span class="hljs-string">&quot;abracadabra&quot;</span><br>a = <span class="hljs-built_in">set</span>(x)  <span class="hljs-comment"># 将字符串中的每个字符存到集合中</span><br><span class="hljs-built_in">print</span>(a) <span class="hljs-comment"># &#123;&#x27;r&#x27;, &#x27;d&#x27;, &#x27;a&#x27;, &#x27;c&#x27;, &#x27;b&#x27;&#125;</span><br></code></pre></td></tr></table></figure><h2 id="2-2-集合的常用操作"><a href="#2-2-集合的常用操作" class="headerlink" title="2.2 集合的常用操作"></a>2.2 集合的常用操作</h2><p>假设a表示一个集合。</p><ul><li>len(a) 返回集合中包含的元素数量。</li><li>a.add(x) 在集合中添加一个元素。</li><li>a.remove(x) 删除集合中的x，如果x不存在，则报异常。</li><li>a.discard(x) 删除集合中的x，如果x不存在，则不进行任何操作。</li><li>x in a 判断x是否在a中。</li><li>x not in a 判断x是否不在a中。<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs py">a = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;<br><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">len</span>(a))  <span class="hljs-comment"># 输出3</span><br><br>a.add(<span class="hljs-number">4</span>)<br><span class="hljs-built_in">print</span>(a)  <span class="hljs-comment"># 输出 &#123;1, 2, 3, 4&#125;，注意集合中的元素是无序的。</span><br><br>a.remove(<span class="hljs-number">2</span>)<br><span class="hljs-built_in">print</span>(a)  <span class="hljs-comment"># 输出 &#123;1, 3, 4&#125;</span><br><br>a.remove(<span class="hljs-number">5</span>)  <span class="hljs-comment"># 因为5不存在，所以会报异常</span><br>a.discard(<span class="hljs-number">5</span>)  <span class="hljs-comment"># 因为5不存在，所以不进行任何操作</span><br><span class="hljs-built_in">print</span>(a)  <span class="hljs-comment"># &#123;1, 3, 4&#125;</span><br></code></pre></td></tr></table></figure></li></ul><h2 id="2-3-使用for循环遍历集合"><a href="#2-3-使用for循环遍历集合" class="headerlink" title="2.3 使用for循环遍历集合"></a>2.3 使用for循环遍历集合</h2><p>类似于列表，集合也可以用for … in …的形式遍历。例如：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs py">a = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;<br><br><span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> a:  <span class="hljs-comment"># 循环遍历整个集合</span><br>    <span class="hljs-built_in">print</span>(x, end=<span class="hljs-string">&#x27; &#x27;</span>)<br></code></pre></td></tr></table></figure><h2 id="3-字典"><a href="#3-字典" class="headerlink" title="3. 字典"></a>3. 字典</h2><p>字典是Python中最常用的数据结构之一，用来存储映射关系。   <code>key:value </code></p><ul><li><p>字典中的元素是无序的。        </p></li><li><p>字典是以key进行索引的，可以将每个key映射到某个value。</p></li><li><p>key必须是不可变类型，常用可以作为key的类型有数字和字符串。</p></li><li><p>value可以是任意类型。</p></li></ul><h2 id="3-1-字典的初始化"><a href="#3-1-字典的初始化" class="headerlink" title="3.1 字典的初始化"></a>3.1 字典的初始化</h2><p>创建字典用花括号或dict()函数。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs py">tel = &#123;<span class="hljs-string">&#x27;jack&#x27;</span>: <span class="hljs-number">4098</span>, <span class="hljs-string">&#x27;sape&#x27;</span>: <span class="hljs-number">4139</span>&#125;  <span class="hljs-comment"># 创建一个字典</span><br><span class="hljs-built_in">print</span>(tel)  <span class="hljs-comment"># 输出 &#123;&#x27;jack&#x27;: 4098, &#x27;sape&#x27;: 4139&#125;</span><br><br><span class="hljs-comment">###########################################################</span><br>a = <span class="hljs-built_in">dict</span>()  <span class="hljs-comment"># 创建一个空字典</span><br>a[<span class="hljs-number">123</span>] = <span class="hljs-string">&quot;abc&quot;</span>  <span class="hljs-comment"># 在字典中插入一个key-value对</span><br>a[<span class="hljs-number">456</span>] = <span class="hljs-string">&quot;def&quot;</span>  <span class="hljs-comment"># 在字典中插入一个key-value对</span><br><span class="hljs-built_in">print</span>(a)  <span class="hljs-comment"># 输出 &#123;123: &#x27;abc&#x27;, 456: &#x27;def&#x27;&#125;</span><br><br>b = <span class="hljs-built_in">list</span>(a)  <span class="hljs-comment"># 将字典的key转化成列表</span><br><span class="hljs-built_in">print</span>(b)  <span class="hljs-comment"># 输出[123, 456]</span><br></code></pre></td></tr></table></figure><h2 id="3-2-字典的常用操作"><a href="#3-2-字典的常用操作" class="headerlink" title="3.2 字典的常用操作"></a>3.2 字典的常用操作</h2><p>假设a表示一个字典。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-built_in">len</span>(a)：返回字典中的元素对数。<br>a[x]：获取关键字x对应的值，如果x不存在，会报异常。<br>a.get(x)：获取关键字x对应的值，如果x不存在，会返回<span class="hljs-literal">None</span>，不会报异常。<br>a.get(x, y)：获取关键字x对应的值，如果x不存在，会返回默认值y，不会报异常。<br>a[x] = y：在字典中插入一对元素，如果关键字x已存在，则将它之前映射的值覆盖掉。<br><span class="hljs-keyword">del</span> a[x]：删除关键字x对应的元素对，如果x不存在，会报异常。<br>x <span class="hljs-keyword">in</span> a：检查字典中是否存在关键字x。<br>x <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> a：检查字典中是否不存在关键字x。<br>a.keys()：返回字典的所有key。<br>a.values()：返回字典的所有value。<br>a.items()：返回字典的所有由key和value组成的元组。<br></code></pre></td></tr></table></figure><p>例如：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs py">a = &#123;<span class="hljs-string">&#x27;abc&#x27;</span>: <span class="hljs-number">1</span>, <span class="hljs-string">&#x27;def&#x27;</span>: <span class="hljs-number">2</span>, <span class="hljs-string">&#x27;python&#x27;</span>: <span class="hljs-number">3</span>&#125;  <span class="hljs-comment"># 初始化一个字典</span><br><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">len</span>(a))  <span class="hljs-comment"># 输出3</span><br><span class="hljs-built_in">print</span>(a[<span class="hljs-string">&#x27;def&#x27;</span>])  <span class="hljs-comment"># 输出2</span><br><span class="hljs-built_in">print</span>(a.get(<span class="hljs-string">&#x27;def&#x27;</span>))  <span class="hljs-comment"># 输出2</span><br><span class="hljs-built_in">print</span>(a.get(<span class="hljs-string">&#x27;xyz&#x27;</span>, <span class="hljs-number">5</span>))  <span class="hljs-comment"># 因为&#x27;xyz&#x27;不存在，所以输出默认值5</span><br><br>a[<span class="hljs-string">&#x27;hello&#x27;</span>] = <span class="hljs-number">4</span>  <span class="hljs-comment"># 插入一对元素 &#x27;hello&#x27; -&gt; 4</span><br><span class="hljs-built_in">print</span>(a)  <span class="hljs-comment"># 输出&#123;&#x27;abc&#x27;: 1, &#x27;def&#x27;: 2, &#x27;python&#x27;: 3, &#x27;hello&#x27;: 4&#125;</span><br><br>a[<span class="hljs-string">&#x27;def&#x27;</span>] = <span class="hljs-number">5</span>  <span class="hljs-comment"># 更新&#x27;def&#x27;映射的值</span><br><span class="hljs-built_in">print</span>(a[<span class="hljs-string">&#x27;def&#x27;</span>])  <span class="hljs-comment"># 输出5</span><br><br><span class="hljs-keyword">del</span> a[<span class="hljs-string">&#x27;python&#x27;</span>]  <span class="hljs-comment"># 删除关键字&#x27;python&#x27;</span><br><span class="hljs-built_in">print</span>(a)  <span class="hljs-comment"># 输出&#123;&#x27;abc&#x27;: 1, &#x27;def&#x27;: 5, &#x27;hello&#x27;: 4&#125;</span><br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;hello&#x27;</span> <span class="hljs-keyword">in</span> a)  <span class="hljs-comment"># 输出True</span><br><span class="hljs-built_in">print</span>(a.keys())  <span class="hljs-comment"># 输出dict_keys([&#x27;abc&#x27;, &#x27;def&#x27;, &#x27;hello&#x27;])</span><br><span class="hljs-built_in">print</span>(a.values())  <span class="hljs-comment"># 输出dict_values([1, 5, 4])</span><br><span class="hljs-built_in">print</span>(a.items())  <span class="hljs-comment"># 输出dict_items([(&#x27;abc&#x27;, 1), (&#x27;def&#x27;, 5), (&#x27;hello&#x27;, 4)])</span><br></code></pre></td></tr></table></figure><h2 id="3-3-使用for循环遍历字典"><a href="#3-3-使用for循环遍历字典" class="headerlink" title="3.3 使用for循环遍历字典"></a>3.3 使用for循环遍历字典</h2><p>类似于列表，字典也可以用for … in …的形式遍历。例如：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs py">a = &#123;<span class="hljs-string">&#x27;abc&#x27;</span>: <span class="hljs-number">1</span>, <span class="hljs-string">&#x27;def&#x27;</span>: <span class="hljs-number">2</span>, <span class="hljs-string">&#x27;python&#x27;</span>: <span class="hljs-number">3</span>&#125;  <span class="hljs-comment"># 初始化一个字典</span><br><br><span class="hljs-keyword">for</span> k <span class="hljs-keyword">in</span> a:  <span class="hljs-comment"># 遍历key</span><br>    <span class="hljs-built_in">print</span>(k, end=<span class="hljs-string">&#x27; &#x27;</span>)<br><span class="hljs-built_in">print</span>()  <span class="hljs-comment"># 输出回车</span><br><br><span class="hljs-keyword">for</span> k <span class="hljs-keyword">in</span> a.keys():  <span class="hljs-comment"># 遍历key</span><br>    <span class="hljs-built_in">print</span>(k, end=<span class="hljs-string">&#x27; &#x27;</span>)<br><span class="hljs-built_in">print</span>()  <span class="hljs-comment"># 输出回车</span><br><br><span class="hljs-keyword">for</span> v <span class="hljs-keyword">in</span> a.values():  <span class="hljs-comment"># 遍历value</span><br>    <span class="hljs-built_in">print</span>(v, end=<span class="hljs-string">&#x27; &#x27;</span>)<br><span class="hljs-built_in">print</span>()  <span class="hljs-comment"># 输出回车</span><br><br><span class="hljs-comment">## 常用！！！</span><br><span class="hljs-keyword">for</span> k, v <span class="hljs-keyword">in</span> a.items():  <span class="hljs-comment"># 遍历key-value对</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;(%s, %d) &quot;</span> % (k, v), end=<span class="hljs-string">&#x27; &#x27;</span>)<br><span class="hljs-built_in">print</span>()  <span class="hljs-comment"># 输出回车</span><br></code></pre></td></tr></table></figure><h1 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h1><h3 id="1-类的定义"><a href="#1-类的定义" class="headerlink" title="1. 类的定义"></a>1. 类的定义</h3><p>在 Python 中，使用 <code>class</code> 关键字来定义一个类，类名通常采用大写字母开头的驼峰命名法。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Dog</span>:<br>    <span class="hljs-keyword">pass</span><br></code></pre></td></tr></table></figure><h3 id="2-类的属性和方法"><a href="#2-类的属性和方法" class="headerlink" title="2. 类的属性和方法"></a>2. 类的属性和方法</h3><p>类是一种重要的编程结构，它能够将数据（属性）和操作数据的代码（方法）封装在一起。类中的属性和方法大致分为三类，下面一一介绍</p><h4 id="2-1-实例属性与实例方法"><a href="#2-1-实例属性与实例方法" class="headerlink" title="2.1 实例属性与实例方法"></a>2.1 实例属性与实例方法</h4><p>实例属性和实例方法是最普通的属性和方法。每个实例都的独立的属性即为实例属性，实例方法用于对这些实例属性进行操作。</p><h5 id="构造函数（特殊的实例方法）"><a href="#构造函数（特殊的实例方法）" class="headerlink" title="构造函数（特殊的实例方法）"></a>构造函数（特殊的实例方法）</h5><p>构造函数在创建类的实例时会自动被调用，其主要功能是对实例的属性进行初始化。在 Python 中，构造函数的名称固定为 <code>__init__</code>。<br>第一个传入的参数必须是<code>self</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Dog</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, name, age</span>):<br>        <span class="hljs-comment"># self 代表类的实例本身</span><br>        <span class="hljs-variable language_">self</span>.name = name<br>        <span class="hljs-variable language_">self</span>.age = age<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">bark</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;<span class="hljs-subst">&#123;self.name&#125;</span> says woof!&quot;</span>)<br><br><span class="hljs-comment"># 创建 Dog 类的实例</span><br>dog1 = Dog(<span class="hljs-string">&quot;Buddy&quot;</span>, <span class="hljs-number">3</span>)<br><span class="hljs-built_in">print</span>(dog1.name)  <span class="hljs-comment"># 输出 &quot;Buddy&quot;</span><br><span class="hljs-built_in">print</span>(dog1.age)   <span class="hljs-comment"># 输出 3</span><br>dog1.bark()       <span class="hljs-comment"># 输出 &quot;Buddy says woof!&quot;</span><br></code></pre></td></tr></table></figure><ul><li><strong><code>__init__</code> 方法</strong>：这是一个特殊的实例方法。当我们使用 <code>Dog(&quot;Buddy&quot;, 3)</code> 创建 <code>Dog</code> 类的实例时，Python 会自动调用 <code>__init__</code> 方法，并把新创建的实例对象传递给 <code>self</code> 参数，同时将 <code>&quot;Buddy&quot;</code> 和 <code>3</code> 分别传递给 <code>name</code> 和 <code>age</code> 参数。通过 <code>self.name = name</code> 和 <code>self.age = age</code>，为实例对象设置了 <code>name</code> 和 <code>age</code> 这两个实例属性。</li><li><strong><code>bark</code> 方法</strong>：这是一个普通的实例方法。在方法内部，通过 <code>self.name</code> 可以访问实例的 <code>name</code> 属性，并打印出相应的信息。实例方法只能通过类的实例来调用，若使用类名直接调用实例方法，会因缺少实例对象作为第一个参数而报错。例如，若执行 <code>Dog.bark()</code> 会产生错误。</li></ul><h4 id="2-2-类属性与类方法"><a href="#2-2-类属性与类方法" class="headerlink" title="2.2 类属性与类方法"></a>2.2 类属性与类方法</h4><p>类属性和类方法是与类本身相关联的。与不同的实例无关。类属性被所有类的实例共享，类方法则用于访问和操作这些类属性。</p><p>类方法既可以通过类调用，也可以通过实例调用</p><p>注意以下三点</p><ul><li>类方法必须对类属性操作</li><li>类方法传入的第一个参数必须是<code>cls</code></li><li>类方法之前使用<code>@classmethod</code>装饰器</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Dog</span>:<br>    <span class="hljs-comment"># 类属性，所有 Dog 类的实例共享</span><br>    species = <span class="hljs-string">&quot;Canis familiaris&quot;</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, name, age</span>):<br>        <span class="hljs-variable language_">self</span>.name = name<br>        <span class="hljs-variable language_">self</span>.age = age<br><br><span class="hljs-meta">    @classmethod</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">get_species</span>(<span class="hljs-params">cls</span>):<br>        <span class="hljs-keyword">return</span> cls.species<br><br><span class="hljs-comment"># 创建 Dog 类的实例</span><br>dog1 = Dog(<span class="hljs-string">&quot;Buddy&quot;</span>, <span class="hljs-number">3</span>)<br><span class="hljs-comment"># 调用类方法，两种方式</span><br><span class="hljs-built_in">print</span>(Dog.get_species())  <span class="hljs-comment"># 可以通过类直接调用：输出 &quot;Canis familiaris&quot;</span><br><span class="hljs-built_in">print</span>(dog1.get_species()) <span class="hljs-comment"># 可以通过实例调用：输出 &quot;Canis familiaris&quot;</span><br></code></pre></td></tr></table></figure><ul><li>**<code>species</code>**：这是一个类属性，它存储了狗的物种信息。无论创建多少个 <code>Dog</code> 类的实例，它们访问的 <code>species</code> 属性都是同一个值。</li><li><strong><code>get_species</code> 方法</strong>：这是一个类方法，使用 <code>@classmethod</code> 装饰器进行定义。类方法的第一个参数通常命名为 <code>cls</code>，它代表类本身。通过 <code>cls.species</code>，我们可以访问类的 <code>species</code> 属性。类方法的调用方式较为灵活，既可以通过类名直接调用，也可以通过类的实例调用，Python 会自动将类对象传递给 <code>cls</code> 参数。</li></ul><h4 id="2-3-静态方法"><a href="#2-3-静态方法" class="headerlink" title="2.3 静态方法"></a>2.3 静态方法</h4><p>静态方法与类和实例都没有直接的关联，它不访问或修改类和实例的属性。静态方法通常用于执行一些通用的、与类或实例状态无关的操作。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Dog</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, name, age</span>):<br>        <span class="hljs-variable language_">self</span>.name = name<br>        <span class="hljs-variable language_">self</span>.age = age<br><br><span class="hljs-meta">    @staticmethod</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">info</span>():<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Dogs are mammals.&quot;</span>)<br><br><span class="hljs-comment"># 创建 Dog 类的实例</span><br>dog1 = Dog(<span class="hljs-string">&quot;Buddy&quot;</span>, <span class="hljs-number">3</span>)<br>Dog.info()  <span class="hljs-comment"># 输出 &quot;Dogs are mammals.&quot;</span><br>dog1.info() <span class="hljs-comment"># 输出 &quot;Dogs are mammals.&quot;</span><br></code></pre></td></tr></table></figure><ul><li><strong><code>info</code> 方法</strong>：这是一个静态方法，使用 <code>@staticmethod</code> 装饰器进行定义。静态方法没有特殊的第一个参数，它就像一个普通的函数，不依赖于类或实例的状态。静态方法的调用方式和类方法一样灵活，既可以通过类名 <code>Dog</code> 调用，也可以通过类的实例 <code>dog1</code> 调用。</li></ul><h3 id="总结表格"><a href="#总结表格" class="headerlink" title="总结表格"></a>总结表格</h3><table><thead><tr><th>方法类型</th><th>定义方式</th><th>第一个参数</th><th>调用方式</th><th>用途</th></tr></thead><tbody><tr><td>实例方法</td><td>普通定义，无特殊装饰器</td><td><code>self</code>（代表实例对象）</td><td>只能通过实例调用</td><td>操作实例的属性，实现与特定实例相关的行为</td></tr><tr><td>类方法</td><td>使用 <code>@classmethod</code> 装饰器</td><td><code>cls</code>（代表类本身）</td><td>可通过类名或实例调用</td><td>访问和修改类属性，执行与类相关的操作</td></tr><tr><td>静态方法</td><td>使用 <code>@staticmethod</code> 装饰器</td><td>无特殊第一个参数</td><td>可通过类名或实例调用</td><td>执行通用的、与类或实例状态无关的操作</td></tr></tbody></table><h3 id="2-4-私有属性和私有方法"><a href="#2-4-私有属性和私有方法" class="headerlink" title="2.4 私有属性和私有方法"></a>2.4 私有属性和私有方法</h3><p>在 Python 中，通过在属性名或方法名前加上双下划线 __ 来定义私有属性和私有方法。私有属性和私有方法不能在类的外部直接访问，只能在类的内部使用。<br>私有实例属性和私有实例方法</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Dog</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, name, age</span>):<br>        <span class="hljs-variable language_">self</span>.name = name<br>        <span class="hljs-variable language_">self</span>.__age = age  <span class="hljs-comment"># 私有实例属性</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__display_age</span>(<span class="hljs-params">self</span>):  <span class="hljs-comment"># 私有实例方法</span><br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;<span class="hljs-subst">&#123;self.name&#125;</span> is <span class="hljs-subst">&#123;self.__age&#125;</span> years old.&quot;</span>)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">show_age_info</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-variable language_">self</span>.__display_age()<br><br><span class="hljs-comment"># 创建 Dog 类的实例</span><br>dog1 = Dog(<span class="hljs-string">&quot;Buddy&quot;</span>, <span class="hljs-number">3</span>)<br><span class="hljs-comment"># 以下代码会报错，不能直接访问私有实例属性和方法</span><br><span class="hljs-comment"># print(dog1.__age)</span><br><span class="hljs-comment"># dog1.__display_age()</span><br>dog1.show_age_info()  <span class="hljs-comment"># 可以通过公共实例方法间接访问私有实例方法</span><br></code></pre></td></tr></table></figure><ul><li>__age：这是一个私有实例属性，每个实例都有自己独立的该属性副本。它只能在类的内部通过其他实例方法访问。</li><li>__display_age：这是一个私有实例方法，只能在类的内部被调用，比如通过公共实例方法 show_age_info 间接调用。</li></ul><h3 id="3-继承"><a href="#3-继承" class="headerlink" title="3. 继承"></a>3. 继承</h3><p>继承是面向对象编程的一个重要特性，它允许你创建一个新的类（子类），继承另一个类（父类）的属性和方法。<br>子类可以重写父类的方法，也可以添加新的属性和方法。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Animal</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, name</span>):<br>        <span class="hljs-variable language_">self</span>.name = name<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">speak</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;<span class="hljs-subst">&#123;self.name&#125;</span> makes a sound.&quot;</span>) <span class="hljs-comment"># 开发中一般直接写pass就行</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Dog</span>(<span class="hljs-title class_ inherited__">Animal</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">speak</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;<span class="hljs-subst">&#123;self.name&#125;</span> says woof!&quot;</span>)<br><br><span class="hljs-comment"># 创建 Dog 类的实例</span><br>dog1 = Dog(<span class="hljs-string">&quot;Buddy&quot;</span>)<br>dog1.speak()  <span class="hljs-comment"># 输出 &quot;Buddy says woof!&quot;</span><br></code></pre></td></tr></table></figure><ul><li><code>Animal</code> 类：这是一个父类，定义了 <code>__init__</code> 方法和 <code>speak</code> 方法。</li><li><code>Dog</code> 类：这是一个子类，继承了 <code>Animal</code> 类的属性和方法，并重写了 <code>speak</code> 方法。</li></ul><h3 id="4-多态"><a href="#4-多态" class="headerlink" title="4. 多态"></a>4. 多态</h3><p>多态是指不同的对象可以对同一个消息做出不同的响应。在 Python 中，多态通常通过继承和方法重写来实现。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Animal</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">speak</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">pass</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Dog</span>(<span class="hljs-title class_ inherited__">Animal</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">speak</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Woof!&quot;</span>)<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Cat</span>(<span class="hljs-title class_ inherited__">Animal</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">speak</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Meow!&quot;</span>)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">make_animal_speak</span>(<span class="hljs-params">animal</span>):<br>    animal.speak()<br><br><span class="hljs-comment"># 创建 Dog 和 Cat 类的实例</span><br>dog = Dog()<br>cat = Cat()<br><br>make_animal_speak(dog)  <span class="hljs-comment"># 输出 &quot;Woof!&quot;</span><br>make_animal_speak(cat)  <span class="hljs-comment"># 输出 &quot;Meow!&quot;</span><br></code></pre></td></tr></table></figure><ul><li><code>make_animal_speak</code> 函数：它接受一个 <code>Animal</code> 类的对象作为参数，并调用该对象的 <code>speak</code> 方法。由于 <code>Dog</code> 和 <code>Cat</code> 类都重写了 <code>speak</code> 方法，所以可以对同一个消息（调用 <code>speak</code> 方法）做出不同的响应。</li></ul><h3 id="5-封装"><a href="#5-封装" class="headerlink" title="5. 封装"></a>5. 封装</h3><p>封装是指将数据和操作数据的方法隐藏在类的内部，只对外提供必要的接口。在 Python 中，通过使用私有属性和私有方法来实现封装。私有属性和私有方法以双下划线 <code>__</code> 开头。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">BankAccount</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, balance</span>):<br>        <span class="hljs-variable language_">self</span>.__balance = balance<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">deposit</span>(<span class="hljs-params">self, amount</span>):<br>        <span class="hljs-keyword">if</span> amount &gt; <span class="hljs-number">0</span>:<br>            <span class="hljs-variable language_">self</span>.__balance += amount<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;Deposited <span class="hljs-subst">&#123;amount&#125;</span>. New balance: <span class="hljs-subst">&#123;self.__balance&#125;</span>&quot;</span>)<br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Invalid deposit amount.&quot;</span>)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">withdraw</span>(<span class="hljs-params">self, amount</span>):<br>        <span class="hljs-keyword">if</span> <span class="hljs-number">0</span> &lt; amount &lt;= <span class="hljs-variable language_">self</span>.__balance:<br>            <span class="hljs-variable language_">self</span>.__balance -= amount<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;Withdrew <span class="hljs-subst">&#123;amount&#125;</span>. New balance: <span class="hljs-subst">&#123;self.__balance&#125;</span>&quot;</span>)<br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Invalid withdrawal amount.&quot;</span>)<br><br><span class="hljs-comment"># 创建 BankAccount 类的实例</span><br>account = BankAccount(<span class="hljs-number">1000</span>)<br>account.deposit(<span class="hljs-number">500</span>)  <span class="hljs-comment"># 输出 &quot;Deposited 500. New balance: 1500&quot;</span><br>account.withdraw(<span class="hljs-number">200</span>) <span class="hljs-comment"># 输出 &quot;Withdrew 200. New balance: 1300&quot;</span><br></code></pre></td></tr></table></figure><ul><li><code>__balance</code>：这是一个私有属性，只能通过类的方法来访问和修改。</li><li><code>deposit</code> 和 <code>withdraw</code> 方法：这是对外提供的接口，用于存款和取款操作。</li></ul><h1 id="包"><a href="#包" class="headerlink" title="包"></a>包</h1><h2 id="一、基础概念"><a href="#一、基础概念" class="headerlink" title="一、基础概念"></a>一、基础概念</h2><p>在 Python 里，模块是组织代码的一种方式，一个 <code>.py</code> 文件就是一个模块。例如，<code>abc.py</code> 就是名为 <code>abc</code> 的模块，<code>xyz.py</code> 就是名为 <code>xyz</code> 的模块。模块能把相关的代码组合在一起，方便复用和管理。</p><h3 id="1-1-模块的导入"><a href="#1-1-模块的导入" class="headerlink" title="1.1 模块的导入"></a>1.1 模块的导入</h3><p>在 Python 中，使用 <code>import</code> 语句来导入模块。下面是几种常见的导入方式：</p><h4 id="1-1-1-直接导入整个模块"><a href="#1-1-1-直接导入整个模块" class="headerlink" title="1.1.1 直接导入整个模块"></a>1.1.1 直接导入整个模块</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> math<br><br><span class="hljs-comment"># 使用 math 模块中的函数</span><br>result = math.sqrt(<span class="hljs-number">16</span>)<br><span class="hljs-built_in">print</span>(result)  <span class="hljs-comment"># 输出 4.0</span><br></code></pre></td></tr></table></figure><p>这里通过 <code>import math</code> 导入了 Python 标准库中的 <code>math</code> 模块，之后就可以使用 <code>math</code> 模块里的函数，像 <code>sqrt()</code> 函数用于计算平方根。</p><h4 id="1-1-2-导入模块中的特定函数或变量"><a href="#1-1-2-导入模块中的特定函数或变量" class="headerlink" title="1.1.2 导入模块中的特定函数或变量"></a>1.1.2 导入模块中的特定函数或变量</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> math <span class="hljs-keyword">import</span> sqrt<br><br><span class="hljs-comment"># 直接使用导入的函数</span><br>result = sqrt(<span class="hljs-number">25</span>)<br><span class="hljs-built_in">print</span>(result)  <span class="hljs-comment"># 输出 5.0</span><br></code></pre></td></tr></table></figure><p>使用 <code>from math import sqrt</code> 语句，只导入了 <code>math</code> 模块中的 <code>sqrt</code> 函数，这样在代码里就可以直接使用 <code>sqrt</code> 函数，而不需要加上 <code>math.</code> 前缀。</p><h4 id="1-1-3-导入模块并起别名"><a href="#1-1-3-导入模块并起别名" class="headerlink" title="1.1.3 导入模块并起别名"></a>1.1.3 导入模块并起别名</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> math <span class="hljs-keyword">as</span> m<br><br><span class="hljs-comment"># 使用别名调用函数</span><br>result = m.cos(m.pi)<br><span class="hljs-built_in">print</span>(result)  <span class="hljs-comment"># 输出 -1.0</span><br></code></pre></td></tr></table></figure><p>通过 <code>import math as m</code> 为 <code>math</code> 模块起了别名 <code>m</code>，之后就可以使用 <code>m</code> 来调用 <code>math</code> 模块中的函数和变量。</p><h2 id="二、包的使用"><a href="#二、包的使用" class="headerlink" title="二、包的使用"></a>二、包的使用</h2><p>当模块数量增多，为避免模块名冲突，可使用包来组织模块。包是包含多个模块的目录，每个包目录下必须有一个 <code>__init__.py</code> 文件（Python 3.3 之后，该文件不是严格必需的，但为了兼容性和清晰性，建议保留），这个文件可以为空，也可以包含 Python 代码。</p><h3 id="2-1-包的目录结构示例"><a href="#2-1-包的目录结构示例" class="headerlink" title="2.1 包的目录结构示例"></a>2.1 包的目录结构示例</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">mycompany<br>├─ __init__.py<br>├─ abc.py<br>└─ xyz.py<br></code></pre></td></tr></table></figure><p>在这个结构中，<code>mycompany</code> 是顶层包名，只要这个顶层包名不与其他包冲突，<code>abc.py</code> 和 <code>xyz.py</code> 的模块名就分别变为 <code>mycompany.abc</code> 和 <code>mycompany.xyz</code>。</p><h3 id="2-2-多级包结构示例"><a href="#2-2-多级包结构示例" class="headerlink" title="2.2 多级包结构示例"></a>2.2 多级包结构示例</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">mycompany<br> ├─ web<br> │  ├─ __init__.py<br> │  ├─ utils.py<br> │  └─ www.py<br> ├─ __init__.py<br> ├─ abc.py<br> └─ utils.py<br></code></pre></td></tr></table></figure><p>在这个多级包结构中，<code>www.py</code> 的模块名是 <code>mycompany.web.www</code>，两个 <code>utils.py</code> 文件的模块名分别是 <code>mycompany.utils</code> 和 <code>mycompany.web.utils</code>。</p><h3 id="2-3-包中模块的导入"><a href="#2-3-包中模块的导入" class="headerlink" title="2.3 包中模块的导入"></a>2.3 包中模块的导入</h3><h4 id="2-3-1-导入包中的模块"><a href="#2-3-1-导入包中的模块" class="headerlink" title="2.3.1 导入包中的模块"></a>2.3.1 导入包中的模块</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> mycompany.abc<br><br><span class="hljs-comment"># 使用导入的模块</span><br>mycompany.abc.some_function()<br></code></pre></td></tr></table></figure><h4 id="2-3-2-从包中导入特定模块"><a href="#2-3-2-从包中导入特定模块" class="headerlink" title="2.3.2 从包中导入特定模块"></a>2.3.2 从包中导入特定模块</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> mycompany <span class="hljs-keyword">import</span> xyz<br><br><span class="hljs-comment"># 使用导入的模块</span><br>xyz.some_other_function()<br></code></pre></td></tr></table></figure><h4 id="2-3-3-从包的子模块中导入特定函数"><a href="#2-3-3-从包的子模块中导入特定函数" class="headerlink" title="2.3.3 从包的子模块中导入特定函数"></a>2.3.3 从包的子模块中导入特定函数</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> mycompany.web.www <span class="hljs-keyword">import</span> some_web_function<br><br><span class="hljs-comment"># 使用导入的函数</span><br>some_web_function()<br></code></pre></td></tr></table></figure><h2 id="三、模块的搜索路径"><a href="#三、模块的搜索路径" class="headerlink" title="三、模块的搜索路径"></a>三、模块的搜索路径</h2><p>当使用 <code>import</code> 语句导入模块时，Python 会按照以下顺序在指定的路径中搜索模块：</p><ol><li><strong>当前目录</strong>：也就是运行 Python 脚本的目录。</li><li><strong>环境变量 <code>PYTHONPATH</code> 中指定的目录</strong>：可以通过设置 <code>PYTHONPATH</code> 环境变量来添加额外的模块搜索路径。</li><li><strong>Python 安装的默认库目录</strong>：包含 Python 标准库和第三方库。</li></ol><p>可以使用 <code>sys.path</code> 查看 Python 的模块搜索路径：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> sys<br><br><span class="hljs-built_in">print</span>(sys.path)<br></code></pre></td></tr></table></figure><h2 id="四、-name-属性"><a href="#四、-name-属性" class="headerlink" title="四、__name__ 属性"></a>四、<code>__name__</code> 属性</h2><p>每个模块都有一个 <code>__name__</code> 属性，它在不同情况下有不同的值：</p><ul><li>当模块作为脚本直接运行时，<code>__name__</code> 的值为 <code>&#39;__main__&#39;</code>。</li><li>当模块被其他模块导入时，<code>__name__</code> 的值为模块名(文件名)</li></ul><p>利用 <code>__name__</code> 属性，可以在模块中编写测试代码，这些代码只有在模块作为脚本直接运行时才会执行：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># test_module.py</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">add</span>(<span class="hljs-params">a, b</span>):<br>    <span class="hljs-keyword">return</span> a + b<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    result = add(<span class="hljs-number">3</span>, <span class="hljs-number">5</span>)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;测试结果: <span class="hljs-subst">&#123;result&#125;</span>&quot;</span>)<br></code></pre></td></tr></table></figure><p>在这个例子中，<code>if __name__ == &#39;__main__&#39;:</code> 块中的代码只有在直接运行 <code>test_module.py</code> 时才会执行，当该模块被其他模块导入时，这部分代码不会执行。</p><h1 id="文件结构：以机器学习为例"><a href="#文件结构：以机器学习为例" class="headerlink" title="文件结构：以机器学习为例"></a>文件结构：以机器学习为例</h1><p>对于机器学习科研项目，一个良好的文件夹结构能够帮助更高效地管理代码、数据、模型和实验结果。以下是一个典型的机器学习科研项目文件夹结构及其各部分的详细解释：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">project_name/<br>├── data/<br>│   ├── raw/<br>│   │   ├── train.csv<br>│   │   ├── test.csv<br>│   ├── processed/<br>│   │   ├── train_processed.npy<br>│   │   ├── test_processed.npy<br>├── models/<br>│   ├── architectures/<br>│   │   ├── neural_network.py<br>│   │   ├── decision_tree.py<br>│   ├── saved_models/<br>│   │   ├── model_1.pth<br>│   │   ├── model_2.pkl<br>├── notebooks/<br>│   ├── exploratory_data_analysis.ipynb<br>│   ├── model_experimentation.ipynb<br>├── scripts/<br>│   ├── data_preprocessing.py<br>│   ├── model_training.py<br>│   ├── model_evaluation.py<br>├── results/<br>│   ├── figures/<br>│   │   ├── accuracy_plot.png<br>│   │   ├── loss_curve.png<br>│   ├── metrics/<br>│   │   ├── classification_report.txt<br>│   │   ├── confusion_matrix.csv<br>├── configs/<br>│   ├── experiment_1.yaml<br>│   ├── experiment_2.yaml<br>├── utils/<br>│   ├── general_utils.py<br>│   ├── visualization_utils.py<br>├── tests/<br>│   ├── test_data_preprocessing.py<br>│   ├── test_model_architectures.py<br>├── README.md<br>└── requirements.txt<br></code></pre></td></tr></table></figure><h3 id="各部分详细解释"><a href="#各部分详细解释" class="headerlink" title="各部分详细解释"></a>各部分详细解释</h3><h4 id="1-data"><a href="#1-data" class="headerlink" title="1. data/"></a>1. <code>data/</code></h4><ul><li><strong><code>raw/</code></strong>: 用于存放从数据源获取的原始数据，例如 CSV 文件、图像文件、文本文件等。这些数据未经任何处理，保持原始状态，方便追溯和重复实验。</li><li><strong><code>processed/</code></strong>: 存放经过预处理后的数据，如归一化、编码、划分训练集和测试集后的数据。这些数据可以以常见的数据格式保存，如 NumPy 数组（<code>.npy</code>）或 Pandas DataFrame（<code>.csv</code>）。</li></ul><h4 id="2-models"><a href="#2-models" class="headerlink" title="2. models/"></a>2. <code>models/</code></h4><ul><li><strong><code>architectures/</code></strong>: 包含各种模型的定义代码。例如，在深度学习项目中，可以定义不同结构的神经网络模型；在传统机器学习项目中，可以定义决策树、支持向量机等模型。</li><li><strong><code>saved_models/</code></strong>: 保存训练好的模型参数。根据使用的框架不同，模型可以保存为不同的格式，如 PyTorch 的 <code>.pth</code> 文件、Scikit-learn 的 <code>.pkl</code> 文件。</li></ul><h4 id="3-notebooks"><a href="#3-notebooks" class="headerlink" title="3. notebooks/"></a>3. <code>notebooks/</code></h4><ul><li>存放 Jupyter Notebook 文件&#x2F;markdown文件，用于进行数据探索性分析（EDA）、模型实验和可视化。这些 Notebook 可以记录你的思考过程、实验结果和分析结论，方便后续查看和分享。</li></ul><h4 id="4-scripts-脚本目录"><a href="#4-scripts-脚本目录" class="headerlink" title="4. scripts/(脚本目录)"></a>4. <code>scripts/</code>(脚本目录)</h4><ul><li><strong><code>data_preprocessing.py</code></strong>: 包含数据预处理的脚本，如数据清洗、特征工程、数据划分等操作。</li><li><strong><code>model_training.py</code></strong>: 用于训练模型的脚本，可以包含模型的初始化、训练循环、优化器的设置等。</li><li><strong><code>model_evaluation.py</code></strong>: 对训练好的模型进行评估的脚本，计算各种评估指标，如准确率、召回率、F1 值等。</li></ul><h4 id="5-results"><a href="#5-results" class="headerlink" title="5. results/"></a>5. <code>results/</code></h4><ul><li><strong><code>figures/</code></strong>: 保存实验过程中生成的可视化图表，如准确率曲线、损失曲线、混淆矩阵图等。这些图表可以直观地展示模型的性能和训练过程。</li><li><strong><code>metrics/</code></strong>: 存放模型评估的指标结果，如分类报告、混淆矩阵等。可以以文本文件或 CSV 文件的形式保存，方便后续分析和比较。</li></ul><h4 id="6-configs"><a href="#6-configs" class="headerlink" title="6. configs/"></a>6. <code>configs/</code></h4><ul><li>存放实验的配置文件，通常使用 YAML 或 JSON 格式。配置文件可以包含模型的超参数、数据路径、训练设置等信息，方便不同实验之间的参数调整和管理。</li></ul><h4 id="7-utils"><a href="#7-utils" class="headerlink" title="7. utils/"></a>7. <code>utils/</code></h4><ul><li><strong><code>general_utils.py</code></strong>: 包含一些通用的工具函数，如文件操作、日志记录、随机种子设置等。</li><li><strong><code>visualization_utils.py</code></strong>: 专门用于可视化的工具函数，如绘制图表、展示图像等。</li></ul><h4 id="8-tests"><a href="#8-tests" class="headerlink" title="8. tests/"></a>8. <code>tests/</code></h4><ul><li>包含对代码各部分进行单元测试的脚本，确保代码的正确性和稳定性。例如，对数据预处理函数、模型架构进行测试。</li></ul><h4 id="9-README-md"><a href="#9-README-md" class="headerlink" title="9. README.md"></a>9. <code>README.md</code></h4><ul><li>项目的说明文档，介绍项目的背景、目的、使用方法、依赖环境等信息，方便其他人员快速了解和使用你的项目。</li></ul><h4 id="10-requirements-txt"><a href="#10-requirements-txt" class="headerlink" title="10. requirements.txt"></a>10. <code>requirements.txt</code></h4><ul><li>列出项目所依赖的第三方库及其版本号，方便其他人在新环境中安装相同的依赖，确保项目的可复现性。</li></ul><p>通过这样的文件夹结构，你可以将不同功能的代码和数据进行清晰的划分，提高项目的可维护性和可扩展性，更高效地进行机器学习科研工作。 </p><h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><ul><li><a href="https://liaoxuefeng.com/books/python/introduction/index.html">廖雪峰Python教程</a></li><li><a href="https://c.biancheng.net/python/">Python基础教程 - 编程狮</a></li><li><a href="https://www.acwing.com/activity/content/punch_the_clock/3425/">AcWing相关页面</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>编程语言</category>
      
      <category>python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>safe</title>
    <link href="/2025/03/21/%E6%96%87%E7%8C%AE/safe-screening/safe/"/>
    <url>/2025/03/21/%E6%96%87%E7%8C%AE/safe-screening/safe/</url>
    
    <content type="html"><![CDATA[<p>本文介绍了一种在 l1 惩罚最小二乘法回归（或 LASSO）问题中消除特征（变量）的快速方法。消除特征可大幅缩短运行时间，尤其是在惩罚参数值较大的情况下。这个方法不是启发式的：它只消除在求解 LASSO 问题后保证不存在的特征。特征消除步骤易于并行化，可以独立测试每个特征的消除情况。此外，与求解 LASSO 问题相比，这一方法的计算量可以忽略不计–大致相当于单梯度步骤。这个方法扩展了现有 LASSO 算法的范围，使其可以处理以前无法处理的更大数据集。本文展示了如何将此方法扩展到一般的 l1 惩罚凸问题，并介绍了稀疏支持向量机和逻辑回归问题的初步结果。</p><h2 id="insight"><a href="#insight" class="headerlink" title="insight"></a>insight</h2><p>作者几乎是单纯的从数学角度提出了这一巧妙的方法，着实令人佩服，后面无论多少文章在本质上都是对此方法的改进。</p><h2 id="核心理论"><a href="#核心理论" class="headerlink" title="核心理论"></a>核心理论</h2><p>先定义一下本文用到的符号</p><ul><li>训练的data：$X&#x3D;\left(a_{1},\ldots,a_{m}\right)^{T}\in\mathbb{R}^{m\times n}$，每一行为一个样本，因此每一列即为一个特征。</li><li>lasso原问题：$\mathcal{P}(\lambda) : \phi(\lambda):&#x3D;\min_w\frac12\left|Xw-y\right|_2^2+\lambda\left|w\right|_1$</li><li>lasso对偶问题：$\mathcal{D}(\lambda)<del>:</del>\phi(\lambda):&#x3D;\max_{\theta}<del>G(\theta)</del>:<del>\left|\theta^Tx_k\right|\leq\lambda,</del>k&#x3D;1,\ldots,n$，其中$\begin{aligned}G(\theta)&#x3D;\frac{1}{2}\left|y\right|<em>{2}^{2}-\frac{1}{2}\left|\theta+y\right|</em>{2}^{2}\end{aligned}$，$\theta$是求解对偶问题中引入的量，表示残差：“$Xw-y$”</li></ul><p>这全部的奥妙就在这约束条件$~\left|\theta^Tx_k\right|\leq\lambda$上了，不难的凸优化分析即可告诉我们：$\left|\theta^{\star T}x_k\right|&lt;\lambda\Rightarrow\left(w^\star\right)_k&#x3D;0$，也就是说对于满足这样的判断的w分量，我们可以断言其为0，从而断言此分量对应的那一列特征是无用的，可以剔除掉。然而我们只有求解完lasso才能做出上面的断言呀，如何在求解开始之前预先识别并剔除无用特征呢？作者为此提出了一种通用策略：</p><p>开始将策略之前先做一些必要的铺垫，我们不难发现$\lambda$越大，得到的解的稀疏程度越大，取恰好使得$w&#x3D;0$的$\lambda$为$\lambda_0$,根据我们的筛选规则，不难看出$\begin{aligned}\lambda_0&#x3D;\max_{1\leq j\leq n} |y^Tx_j|&#x3D;|X^Ty|_\infty.\end{aligned}$，对应的$\theta_0^\star&#x3D;-y$</p><h3 id="第一步"><a href="#第一步" class="headerlink" title="第一步"></a>第一步</h3><p>尽管在开始训练前，我们无法精确找到最优解$\theta^*$,但是可以尝试构建一个必定包含$\theta^*$的集合$\Theta$，如果我们可以验证$\forall\theta\in\Theta$,均有$|\theta^Tx_k|&lt;\lambda$,那么也可以断言第k个特征无效。，因此构建一个尽量小的$\Theta$即可。作者采用的策略是构建两个必定包含$\theta^*$的集合$\Theta_1,\Theta_2$,取二者交集作为$\Theta$,定义</p><p>注意到对偶问题$G(\theta)$,任取一个可行点（比如上面提到的$\lambda_0系列$）得到$\gamma:&#x3D;{G}(\theta_s)$，可以构建出一个球形约束区域<br>$$\begin{aligned}\Theta_1:&#x3D;{\theta \mid G(\theta)\geq\gamma}\end{aligned}$$<br>（对于$\gamma$的得到作者采用了对偶缩放的技巧，这不是重点，暂且按下不谈）<br>作者用一阶条件构建了第二个区域<br>$$\Theta_{2}:&#x3D;\begin{Bmatrix}\theta|&amp;g^{T}(\theta-\theta_{0}^{\star})\leq0\end{Bmatrix}$$</p><h3 id="第二步"><a href="#第二步" class="headerlink" title="第二步"></a>第二步</h3><p>可以舍弃的特征的指标集合可以表示为<br>$$\mathcal{E}&#x3D;{k\mid\lambda&gt;\max(P(\gamma,x_k),P(\gamma,-x_k)}$$<br>其中<br>$$P(\gamma,x_k):&#x3D;\max_\theta x_k^T\theta : G(\theta)\geq\gamma, g^T\left(\theta-\theta_0^\star\right)\geq0.$$<br>可以用凸优化方法求出这个问题的封闭解。<br>如果我们有某个$\lambda$下对应的最优解$w$,两个区域是不难构建的，即使我们没有某个$\lambda$下对应的最优解$w$，我们也可以选择恰好使得$w&#x3D;0$的$\lambda_0$，在这种情况下，解集还可以有一个优雅地表达，<br>$$\lambda&gt;\rho_k\lambda_{\mathrm{max}}$$<br>其中$\rho_k&#x3D;\frac{\left|y\right|_2\left|x_k\right|_2+\left|y^Tx_k\right|}{\left|y\right|_2\left|x_k\right|<em>2+\lambda</em>{\max}}.$</p><h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><p>以上分析可以产生两种算法，解决两类问题</p><h3 id="SAFE-for-reducing-memory-limit-problems"><a href="#SAFE-for-reducing-memory-limit-problems" class="headerlink" title="SAFE for reducing memory limit problems"></a>SAFE for reducing memory limit problems</h3><p><img src="https://img.picui.cn/free/2024/11/04/6728b19c0d5f6.png"></p><h3 id="Recursive-SAFE-for-the-Lasso"><a href="#Recursive-SAFE-for-the-Lasso" class="headerlink" title="Recursive SAFE for the Lasso"></a>Recursive SAFE for the Lasso</h3><p><img src="https://img.picui.cn/free/2024/11/04/6728b19bc20c1.png"></p><h2 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h2><p>作者对更一般的带l1正则化的凸优化问题给出了解析，包括logistics回归，稀疏支持向量机等等。<br><img src="https://img.picui.cn/free/2024/11/04/6728dce65c095.png" alt="在这里插入图片描述"></p><h2 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h2><p>对于有内存限制下的求解问题，SAFE表现出色，圆满完成了限制内存的任务<br>在不同lassosolver的实验中，safe方法均表现出了较好的提前筛选效果。<br><img src="https://img.picui.cn/free/2024/11/04/6728b19ad0d75.png" alt="在这里插入图片描述"><br><img src="https://img.picui.cn/free/2024/11/04/6728b19b4446a.png" alt="在这里插入图片描述"></p><h1 id="改进：strong-rules"><a href="#改进：strong-rules" class="headerlink" title="改进：strong rules"></a>改进：strong rules</h1><p>stong rules提出的强规则并非万无一失，但在实践中很少失效。这些规则非常简单，并可辅以对 KarushKuhn-Tucker (KKT) 条件的简单检查，以确保提供凸问题的精确解。这些规则为各种统计优化问题节省了大量计算时间和内存。</p><p>本文符号定义：$\hat{\boldsymbol{\beta} }&#x3D;\underset{\boldsymbol{\beta} }{\operatorname*{argmin} } \frac{1}{2}|\mathbf{y}-<br>\mathbf{X}\boldsymbol{\beta}|_2^2+\lambda|\boldsymbol{\beta}|_1,$</p><p>上一篇文章的筛选规则可以写为<br>$$|\mathbf{x}<em>j^T\mathbf{y}|&lt;\lambda-|\mathbf{x}<em>j|<em>2|\mathbf{y}|<em>2\frac{\lambda</em>{\max}-\lambda}{\lambda</em>{\max} },$$<br>如果我们对X进行了归一化，上面的式子可以进一步写为<br>$$\lambda-|\mathbf{y}|</em>{2}\frac{\lambda</em>{\max}-\lambda}{\lambda_{\max} }$$<br>作者采取了大胆的缩放，定义$\mathbf{r}&#x3D;\mathbf{y}-\mathbf{X}\hat{\boldsymbol{\beta} }(\lambda_0),$<br>$$|\mathbf{x}_j^T\mathbf{r}|&lt;2\lambda-\lambda_0.$$<br>作者进行了一系列分析来阐述他的动机和上述式子几乎不会失误，尽管效果惊人的显著，不过他毕竟还是不安全的。后续工作也几乎不再与此工作进行比较，因此不再赘述。</p><h1 id="slores，适用于logistic回归的强且安全的筛选法则"><a href="#slores，适用于logistic回归的强且安全的筛选法则" class="headerlink" title="slores，适用于logistic回归的强且安全的筛选法则"></a>slores，适用于logistic回归的强且安全的筛选法则</h1><p>要注意slores是针对于逻辑回归提出的，也正因如此才能利用上强凸性，<br>原问题：<br>$$\min_{\beta,c} \frac1m\sum_{i&#x3D;1}^m\log(1+\exp(-\langle\beta,\bar{\mathbf{x} }_i\rangle-b_ic))+\lambda|\beta|<em>1,$$<br>对偶问题·，定义$f(y)&#x3D;y\log(y)+(1-y)\log(1-y)\text{ for }y\in(0,1)$<br>$$\min_\theta \left{g(\theta)&#x3D;\frac1m\sum</em>{i&#x3D;1}^mf(\theta_i): |\bar{\mathbf{X} }^T\theta|_\infty\leq m\lambda,\langle\theta,\mathbf{b}\rangle&#x3D;0,\theta\in\mathcal{C}\right}$$</p><p>针对于逻辑回归的筛选规则可以表达为<br>$$T(\theta_\lambda^*,\bar{\mathbf{x} }^j):&#x3D;\max_{\theta\in\mathcal{A}_\lambda}|\langle\theta,\bar{\mathbf{x} }^j\rangle|&lt;m\lambda\Rightarrow[\beta_\lambda^*]_j&#x3D;0.$$</p><p>下面就是构建区域了，作者利用强凸性构建了一个理论上和实践上都很紧的球形区域<br>$$|\theta_\lambda^*-\theta_{\lambda_0}^<em>|<em>2^2\leq\frac m2\left[g\left(\frac\lambda{\lambda_0}\theta</em>{\lambda_0}^</em>\right)-g(\theta_{\lambda_0}^*)+\left(1-\frac\lambda{\lambda_0}\right)\langle\nabla g(\theta_{\lambda_0}^*),\theta_{\lambda_0}^*\rangle\right]$$<br>并结合其他的一些必要条件做出了部分约束，求出了筛选规则的闭式解，效果显著</p><p><img src="https://img.picui.cn/free/2024/11/05/672a25b365af6.png" alt="在这里插入图片描述"></p><p><img src="https://img.picui.cn/free/2024/11/05/672a25d6e2967.png" alt="在这里插入图片描述"><br><img src="https://img.picui.cn/free/2024/11/05/672a25d6eeaf6.png" alt="在这里插入图片描述"></p>]]></content>
    
    
    <categories>
      
      <category>文献</category>
      
      <category>ml理论</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>算法竞赛集训笔记（三）</title>
    <link href="/2025/03/21/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B%E9%9B%86%E8%AE%AD%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89/"/>
    <url>/2025/03/21/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B%E9%9B%86%E8%AE%AD%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<p>NOIP2003 普及组 栈<br>考虑的是这样一个问题：一个操作数序列，</p><p>1,2,…,n（图示为 1 到 3 的情况），栈 A 的深度大于 n。</p><p>现在可以进行两种操作，</p><p>将一个数，从操作数序列的头端移到栈的头端（对应数据结构栈的 push 操作）<br>将一个数，从栈的头端移到输出序列的尾端（对应数据结构栈的 pop 操作）<br>问可以构成多少排列？  </p><h3 id="记忆化搜索"><a href="#记忆化搜索" class="headerlink" title="记忆化搜索"></a>记忆化搜索</h3><p>本题关键在于用怎样的数据结构模拟过程，起先我希望使用三个栈来模拟，dfs搜索状态树，然而较为繁琐难写。事实上通过一个二维数组来传递状态量是合理的选择。引入f[i][j]表示中转栈中有j个元素，仍然有i个元素等待进入中转栈的情况下，在原有情况基础上新加多少情况数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">int</span> f[<span class="hljs-number">20</span>][<span class="hljs-number">20</span>]=&#123;<span class="hljs-number">0</span>&#125;;<br><span class="hljs-function"><span class="hljs-type">long</span> <span class="hljs-type">long</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> i,<span class="hljs-type">int</span> j)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(dfs[i][j]) <span class="hljs-keyword">return</span> f[i][j];  <span class="hljs-comment">//搜过直接return</span><br>    <span class="hljs-keyword">if</span>(i==<span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>    <span class="hljs-comment">//只能全部出栈</span><br>    <span class="hljs-keyword">if</span>(j&gt;<span class="hljs-number">0</span>) f[i][j]+=<span class="hljs-built_in">dfs</span>(i,j<span class="hljs-number">-1</span>);  <span class="hljs-comment">//要么出栈一个</span><br>    f[i][j]+=<span class="hljs-built_in">dfs</span>(i<span class="hljs-number">-1</span>,j<span class="hljs-number">+1</span>);               <span class="hljs-comment">//要么入栈一个</span><br>    <span class="hljs-keyword">return</span> f[i][j];<br><br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">int</span> n;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;n);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld&quot;</span>,<span class="hljs-built_in">dfs</span>(n,<span class="hljs-number">0</span>));<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h3><p>dp关键在于找边界，找递推。并且递推关系一定要是依赖于历史值。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> n;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;n);<br><span class="hljs-type">long</span> <span class="hljs-type">long</span>  dp[<span class="hljs-number">20</span>][<span class="hljs-number">20</span>]=&#123;<span class="hljs-number">0</span>&#125;;<br><span class="hljs-comment">//i 中间坑多少个数 j原来坑多少个数</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;=n;i++) <br>&#123;<br>dp[i][<span class="hljs-number">0</span>]=<span class="hljs-number">1</span>;<br>&#125;    <span class="hljs-comment">//dp边界</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=n;j++)  <span class="hljs-comment">//注意顺序</span><br>&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;=n;i++)<br>&#123;<br><span class="hljs-keyword">if</span>(i==<span class="hljs-number">0</span>) dp[i][j]=dp[i][j<span class="hljs-number">-1</span>];  <span class="hljs-comment">//更新边界时特殊情况</span><br><span class="hljs-keyword">else</span><br>&#123;<br>dp[i][j]+=dp[i<span class="hljs-number">-1</span>][j]+dp[i<span class="hljs-number">+1</span>][j<span class="hljs-number">-1</span>];  <span class="hljs-comment">//要么出要么进</span><br>&#125;<br>&#125;<br> &#125; <br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld&quot;</span>,dp[<span class="hljs-number">0</span>][n]);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="01背包"><a href="#01背包" class="headerlink" title="01背包"></a>01背包</h3><p><img src="https://www.freeimg.cn/i/2024/04/06/661135d1cf60d.png"><br>一种思路是使用二维数组dp，fij，i表示在前i种商品中做选择，j表示花费掉j元方案数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cmath&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> N 110</span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">int</span> n,m,a[N],f[N][<span class="hljs-number">10010</span>];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br> <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);<br> <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)<br>   <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;a[i]);<br> <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;=n;i++) <span class="hljs-comment">//注意这里要从0开始 </span><br>   f[i][<span class="hljs-number">0</span>]=<span class="hljs-number">1</span>;             <span class="hljs-comment">//边界</span><br> <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)<br>   <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=m;j++)<br>   &#123;<br>   f[i][j]+=f[i<span class="hljs-number">-1</span>][j];   <span class="hljs-comment">//不选a[i]</span><br>   <span class="hljs-keyword">if</span>(j&gt;=a[i])<br>     f[i][j]+=f[i<span class="hljs-number">-1</span>][j-a[i]];   <span class="hljs-comment">//选a[i]</span><br>   &#125;<br> cout&lt;&lt;f[n][m];<br> <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>另一种思路使用一维数组，f[j]仅仅表示花费j元的方案数，但是注意更新方向。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cmath&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> N 110</span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">int</span> n,m,a[N],f[<span class="hljs-number">10010</span>];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>   <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);<br>   <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)<br>     <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;a[i]);<br>   f[<span class="hljs-number">0</span>]=<span class="hljs-number">1</span>;<br>   <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)<br>     <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=m;j&gt;=a[i];j--)   <span class="hljs-comment">//反向更新，确保f[j]更新使用到的f[j-a[i]]是没有更新过的</span><br>       f[j]=f[j]+f[j-a[i]];<br>   cout&lt;&lt;f[m];<br>   <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>题目总结</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法竞赛</tag>
      
      <tag>c++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>GAP</title>
    <link href="/2025/03/21/%E6%96%87%E7%8C%AE/safe-screening/GAP/"/>
    <url>/2025/03/21/%E6%96%87%E7%8C%AE/safe-screening/GAP/</url>
    
    <content type="html"><![CDATA[<h1 id="动态筛选的提出"><a href="#动态筛选的提出" class="headerlink" title="动态筛选的提出"></a>动态筛选的提出</h1><p>以往的安全筛选法则，都是脱离训练过程所存在的筛选。我们称之为静态筛选规则(We will refer to such safe rules as static safe rules)他大致分为全局的(利用$\lambda_0$)和递归的(加速筛选一系列$\lambda$),动态筛选规则为我们提供了新的思路。作者用简单的伪代码为我们展示了何为动态筛选：(字典D就是上篇里的X，x是上篇的w)<br><img src="https://img.picui.cn/free/2024/11/04/6728b23d8eab7.png" alt="在这里插入图片描述"><br>它通过在优化过程中迭代减少字典的大小，丢弃已知不属于 Lasso 解的元素，从而加速了一大类优化算法。</p><p>动态筛选的符号选择跟前面处处有不同，看得我挺难受，同时一些处理做了细微改动。主要区别在于以下：</p><ul><li>字典D就是上篇里的X，x是上篇的w,原问题写为<br>$$\mathcal{P}(\lambda,\mathbf{D},\mathbf{y}):\tilde { \mathbf {x} }\triangleq\arg\min_\mathbf{x}\frac12|\mathbf{D}\mathbf{x}-\mathbf{y}|_2^2+\lambda|\mathbf{x}|_1,$$</li><li>对偶问题除以了$\lambda$,变成了这样<br>$$\begin{aligned}\tilde{\boldsymbol{\theta} }\triangleq\arg\max_{ {\boldsymbol{\theta} } }\frac{1}{2}\left|\mathbf{y}\right|<em>{2}^{2}-\frac{\lambda^{2} } {2}\left|\boldsymbol{\theta}-\frac{\mathbf{y} }{\lambda}\right|</em>{2}^{2}\\mathrm{s.t.~}\forall i\in\Omega,|\boldsymbol{\theta}^{T}\mathbf{d}_{i}|\leq1.\end{aligned}$$</li><li>抛弃了之前求出的闭式解，在有球形约束的情况下采用了计算量较小的筛选规则：<br>Lemma 1 (Sphere Test Principle [7]). If the solution $\tilde{\boldsymbol{\theta}}$ of (2)<br>satisfes $\exists { r, \mathbf{c} } \in \mathbb{R} \times \mathbb{R} ^{N}, | \widetilde{\boldsymbol{\theta } } - \mathbf{c} | _{2}\leq r, then:$<br>$$|\mathbf{c}^T\mathbf{d}_i|&lt;1-r\Rightarrow\tilde{\mathbf {x} }\left(i\right)&#x3D;0.$$</li></ul><p>这种思路是很好的，他使得safe screen技术由一种预处理技术变为了对solver的加速技术，作者给出算法如下：<br><img src="https://img.picui.cn/free/2024/11/04/6728b2880635e.png" alt="在这里插入图片描述"><br>上面的see(6)主要利用了对偶缩放技巧，意在使得$r_k$尽可能的收敛，从而使得加速效率越来越快。但是作者并没有很好的处理好“如何让$r_k$必然收敛”这件事，于是新的方法诞生了。</p><h1 id="GAP-SAFE-Rule"><a href="#GAP-SAFE-Rule" class="headerlink" title="GAP SAFE Rule"></a>GAP SAFE Rule</h1><p>针对于上一篇文章提出的方法，本文的作者进行了一种关键的改进。insight在于，由于强对偶性的存在，对偶间隙必然是不断缩小直到趋于0的，那么我们如果构建一个与对偶间隙成比例的安全区域，那么这个安全区域也是严格收敛的，这样的加速方法大概率更优。定义本文的gapsafe区域<br>$$\begin{aligned}<br>&amp;\widehat{R}<em>{\lambda}(\beta):&#x3D;\frac{1}{\lambda}\big(\left|y\right|^{2}-\left|X\beta-y\right|^{2}-2\lambda\left|\beta\right|</em>{1}\big)<em>{+}^{1&#x2F;2},\check{R}</em>{\lambda}(\theta):&#x3D; \<br>&amp;\left|\theta-y&#x2F;\lambda\right|,\hat{\theta}^{(\lambda)}\textit{ the dual optimal Lasso solution and} \<br>&amp;\tilde{r}<em>\lambda(\beta,\theta):&#x3D;\sqrt{\breve{R}<em>\lambda(\theta)^2-\widehat{R}<em>\lambda(\beta)^2},\textit{then} \<br>&amp;\hat{\theta}^{(\lambda)}\in B\bigg(\theta,\tilde{r}</em>{\lambda}(\beta,\theta)\bigg).&amp; \text{(15)}<br>\end{aligned}$$<br>证明是很简洁的，根据对偶关系可以得到<br>$$\frac{1}{2}\left|y\right|^{2}-\frac{\lambda^{2} }{2}\left|\theta-\frac{y}{\lambda}\right|^{2}\leqslant\frac{1}{2}\left|X\beta-y\right|^{2}+\lambda\left|\beta\right|</em>{1}$$<br>$$\left|\theta-\frac y\lambda\right|\geqslant\frac{\sqrt{\left(\left|y\right|^2-\left|X\beta-y\right|^2-2\lambda\left|\beta\right|<em>1\right)}+}{\lambda}.$$<br>同时利用原先的SAFE技巧，任取一个对偶可行点，可以约束得到$\check{R}</em>{\lambda}(\theta)$,因此安全区域夹在了两个圆之间的环上，根据几何关系可以直观地推导出最终的安全区域<br><img src="https://img.picui.cn/free/2024/11/04/6728b2a722e3e.png" alt="在这里插入图片描述"><br>$$\begin{aligned}<br>&amp;\textbf{GAP SAFE sphere:} \<br>&amp; \mathcal{C}</em>{k}&#x3D;B\left(\theta_{k},r_{\lambda}(\beta,\theta)\right). &amp; \text{(18)} \<br>&amp;\textbf{GAP SAFE dome:} \<br>&amp;\begin{aligned}\mathcal{C}_k&#x3D;D\Bigg(\frac{\frac{y}{\lambda}+\theta_k}{2},\frac{\breve{R}_\lambda(\theta_k)}{2},2\left(\frac{\widehat{R}_\lambda(\beta_k)}{\check{R}_\lambda(\theta_k)}\right)^2-1,\frac{\theta_k-\frac{y}{\lambda}}{|\theta_k-\frac{y}{\lambda}|}\Bigg).\end{aligned}<br>\end{aligned}$$</p><p>回到本来的思路，我们探究gap safe sphere和对偶间隔$G_{\lambda}(\beta,\theta)&#x3D;P_{\lambda}(\beta)-D_{\lambda}\left(\theta\right)$的关系，容易证明得到<br>$$\tilde{r}_\lambda(\beta,\theta)^2\leqslant r_\lambda(\beta,\theta)^2:&#x3D;\frac{2}{\lambda^2}G_\lambda(\beta,\theta).$$<br>为此作者一开始的insight得到了利用，区域的收敛性有了保障。这一算法的伪代码记录如下</p><p><img src="https://www.freeimg.cn/i/2024/11/09/672f5f2bd75d5.webp" alt="1731157801710.png"></p><p>K表示优化步骤最多进行的次数，f表示每隔几次单独的优化步骤便进行一次筛选。<br>作者进行了时间比较，在加速以及特征筛选方面效果显著。</p>]]></content>
    
    
    <categories>
      
      <category>文献</category>
      
      <category>ml理论</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>matplotlib画图</title>
    <link href="/2025/03/21/%E5%AD%A6%E6%9C%AF%E5%B7%A5%E5%85%B7/matplotlib/"/>
    <url>/2025/03/21/%E5%AD%A6%E6%9C%AF%E5%B7%A5%E5%85%B7/matplotlib/</url>
    
    <content type="html"><![CDATA[<h1 id="通用模版"><a href="#通用模版" class="headerlink" title="通用模版"></a>通用模版</h1><p>由于matplotlib的知识点非常繁杂，在实际使用过程中也不可能将全部API都记住，很多时候都是边用边查。因此这里提供一个通用的绘图基础模板，任何复杂的图表几乎都可以基于这个模板骨架填充内容而成。初学者刚开始学习时只需要牢记这一模板就足以应对大部分简单图表的绘制，在学习过程中可以将这个模板模块化，了解每个模块在做什么，在绘制复杂图表时如何修改，填充对应的模块。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># step1 准备数据</span><br>x = np.linspace(<span class="hljs-number">0</span>, <span class="hljs-number">2</span>, <span class="hljs-number">100</span>)<br>y = x**<span class="hljs-number">2</span><br><br><span class="hljs-comment"># step2 设置绘图样式，这一模块的扩展参考第五章进一步学习，这一步不是必须的，样式也可以在绘制图像是进行设置</span><br>mpl.rc(<span class="hljs-string">&#x27;lines&#x27;</span>, linewidth=<span class="hljs-number">4</span>, linestyle=<span class="hljs-string">&#x27;-.&#x27;</span>)<br><br><span class="hljs-comment"># step3 定义布局， 这一模块的扩展参考第三章进一步学习</span><br>fig, ax = plt.subplots()  <br><br><span class="hljs-comment"># step4 绘制图像， 这一模块的扩展参考第二章进一步学习</span><br>ax.plot(x, y, label=<span class="hljs-string">&#x27;linear&#x27;</span>)  <br><br><span class="hljs-comment"># step5 添加标签，文字和图例，这一模块的扩展参考第四章进一步学习</span><br>ax.set_xlabel(<span class="hljs-string">&#x27;x label&#x27;</span>) <br>ax.set_ylabel(<span class="hljs-string">&#x27;y label&#x27;</span>) <br>ax.set_title(<span class="hljs-string">&quot;Simple Plot&quot;</span>)  <br>ax.legend() ;<br></code></pre></td></tr></table></figure><h1 id="第二章-绘制图像"><a href="#第二章-绘制图像" class="headerlink" title="第二章:绘制图像"></a>第二章:绘制图像</h1>]]></content>
    
    
    <categories>
      
      <category>学术工具</category>
      
    </categories>
    
    
    <tags>
      
      <tag>论文写作</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>文章总结：如何写论文，读论文？</title>
    <link href="/2025/03/21/%E5%AD%A6%E6%9C%AF%E5%B7%A5%E5%85%B7/%E8%AE%BA%E6%96%87%E5%86%99%E4%BD%9C/"/>
    <url>/2025/03/21/%E5%AD%A6%E6%9C%AF%E5%B7%A5%E5%85%B7/%E8%AE%BA%E6%96%87%E5%86%99%E4%BD%9C/</url>
    
    <content type="html"><![CDATA[<h2 id="写作之前"><a href="#写作之前" class="headerlink" title="写作之前"></a>写作之前</h2><h3 id="写作流程"><a href="#写作流程" class="headerlink" title="写作流程"></a>写作流程</h3><ul><li>统计机器翻译</li><li>利⽤用句法对⻓长距离调序建模</li><li>将树到串对泛化为树到串模板</li><li>规则抽取，搜索算法</li><li>数据集、基线系统、评价指标</li><li>投稿ACL<br>也就是，确定方向<br>确定问题<br>确定思路<br>确定方法<br>实验验证<br>撰写论⽂</li></ul><h3 id="选择课题"><a href="#选择课题" class="headerlink" title="选择课题"></a>选择课题</h3><p>无论热门还是冷门，都要坚持下去，持之以恒        </p><ul><li>①填补研究空白（老问题）<br>重在创新<br>侧重和前人研究的不同与融合      </li><li>②延伸现有研究（新问题）<br>追踪研究历史：建立在前一项研究的基础下同时为下一项研究奠定基础<br>蕴含更多机会<br>注重意义        </li><li>③复制成功研究<br>在不同情况下进行复制（不同变量范围、不同领域）<br>避免错误</li></ul><h3 id="好的论文具有的特点"><a href="#好的论文具有的特点" class="headerlink" title="好的论文具有的特点"></a>好的论文具有的特点</h3><p><img src="https://www.freeimg.cn/i/2024/07/19/669a3077d1d7b.png" alt="1721380980302.png"><br><img src="https://www.freeimg.cn/i/2024/07/19/669a31bfa42fd.png" alt="1721381308189.png"></p><h3 id="关于审稿"><a href="#关于审稿" class="headerlink" title="关于审稿"></a>关于审稿</h3><p>要接受被拒绝，接受别人的提问，有时候即使是很好的工作也未必可以被接受（比如玻尔兹曼） </p><p>审稿⼈人实际上往往是这样审稿的：<br>他不一定是专家，一直忙于其他事，在deadline到来之前一天要完成<br>n篇。审稿时他往往先看题目、摘要，扫一下introduction（知道你做<br>什么），然后直接翻到最后找核心实验结果（做得好不好），然后<br>基本确定录还是不录（也许只⽤用5分钟！）。如果决定录，剩下就是<br>写些赞美的话，指出些次要的小⽑毛病。如果决定拒，下⾯面的过程就<br>是细看中间部分找理由拒了。<br>要全心全意为读者服务，论文结构与叙述要做到逻辑清晰，语言流畅，思路明确。具体的</p><ul><li>重视abstract，introduction</li><li>深入浅出，引⼈入胜，让读者快速找到想要的信息</li><li>合理地综合使⽤用信息元素：图&gt;曲线&gt;表&gt;正文&gt;公式</li><li>降低信息理解难度</li></ul><h2 id="写作方法"><a href="#写作方法" class="headerlink" title="写作方法"></a>写作方法</h2><h3 id="如何看论文？"><a href="#如何看论文？" class="headerlink" title="如何看论文？"></a>如何看论文？</h3><p>如何看浩如烟海的文献？ </p><ul><li>根据标题过滤50% </li><li>根据摘要再过滤20% </li><li>根据介绍再过滤20% </li><li>剩下的10%再仔细看论⽂</li></ul><h3 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h3><p>一句话说明白，可以适当的别出心裁。</p><h3 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h3><p>几句话概括你的工作<br><strong>误区</strong>        </p><ul><li>力图把所有细节都说清楚      </li><li>用很专业的术语来描述                 </li><li>出现数学符号</li></ul><p>语言要简单自然，能让外行看懂。   </p><p>摘要应当介绍的是：<img src="https://www.freeimg.cn/i/2024/07/19/669a33e83ac77.png" alt="1721381782725.png"></p><h3 id="介绍introduction"><a href="#介绍introduction" class="headerlink" title="介绍introduction"></a>介绍introduction</h3><ul><li>要点是充分论证你所做工作的必要性和重要性，要让审稿⼈人认同并迫不及待想往下看。</li></ul><p>提供一种优秀的格式：</p><ul><li>说明问题是什么</li><li>说明前人的工作，目前最好的工作面临什么挑战</li><li>说明我们的工作可以解决怎样的挑战</li></ul><h3 id="段落"><a href="#段落" class="headerlink" title="段落"></a>段落</h3><p>每个段落有个论断性的中心句<br>• 其余部分都是支撑句，围绕中心句展开论证<br>• 前人工作<br>• 具体数据<br>• 支撑句之间可分类组织<br>• 段尾可以加上衔接句<br><img src="https://www.freeimg.cn/i/2024/07/19/669a35a2c06f4.png" alt="1721382301623.png"></p><ul><li><p>可以在文首加图表帮助理解<br><img src="https://www.freeimg.cn/i/2024/07/19/669a3653b6881.png" alt="1721382475191.png"></p></li><li><p>学会使用running example阐述自己的思路</p></li></ul><p><img src="https://www.freeimg.cn/i/2024/07/19/669a376aa465b.png" alt="1721382758780.png"></p><p><strong>一个具体的例子：</strong></p><p><img src="https://www.freeimg.cn/i/2024/07/19/669a37a11f3f0.png" alt="1721382813066.png"></p><h3 id="实验设计"><a href="#实验设计" class="headerlink" title="实验设计"></a>实验设计</h3><p><img src="https://www.freeimg.cn/i/2024/07/19/669a6c1155113.png"></p>]]></content>
    
    
    <categories>
      
      <category>学术工具</category>
      
    </categories>
    
    
    <tags>
      
      <tag>论文写作</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>51单片机（二）</title>
    <link href="/2025/03/21/EE/51%E5%8D%95%E7%89%87%E6%9C%BA%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <url>/2025/03/21/EE/51%E5%8D%95%E7%89%87%E6%9C%BA%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="51单片机简明笔记（二）"><a href="#51单片机简明笔记（二）" class="headerlink" title="51单片机简明笔记（二）"></a>51单片机简明笔记（二）</h1><h2 id="7中断与定时器"><a href="#7中断与定时器" class="headerlink" title="7中断与定时器"></a>7中断与定时器</h2><h3 id="7-1-定时与中断基本概念"><a href="#7-1-定时与中断基本概念" class="headerlink" title="7-1 定时与中断基本概念"></a>7-1 定时与中断基本概念</h3><p><strong>问：按照顺序执行结构，如果main函数一直在循环，那么程序的读取应该一直在main函数处，下面的中断函数永远读取不到，难道说单片机c语言不满足顺序执行结构？</strong></p><p>答：是的，单片机的C语言程序并不完全满足顺序执行结构。在单片机编程中，除了顺序执行结构，还广泛使用了中断结构。</p><p>在顺序执行结构中，程序会按照代码的顺序，从上到下依次执行。但是，当一个中断事件发生时，单片机会暂停当前正在执行的程序，保存当前的程序状态，然后跳转到对应的中断服务程序执行。</p><p>在代码中，<code>main</code>函数是程序的主体，它在单片机上电或复位后开始执行，并且会一直循环执行。然而，<code>Timer0_Routine</code>函数是定时器0的中断服务程序，当定时器0产生中断时，这个函数会被自动调用。</p><p>因此，即使<code>main</code>函数一直在循环，只要定时器0产生中断，<code>Timer0_Routine</code>函数就会被执行。这就是为什么<code>main</code>函数和<code>Timer0_Routine</code>函数可以交替执行的原因。</p><p><strong>问：常见的中断函数与中断结构？</strong></p><p>答：在单片机编程中，中断函数是一种特殊的函数，当满足一定的条件时，它会暂停主函数的执行内容，转而去执行中断函数1。以下是一些关于中断函数的基本概念和用法：</p><p>中断函数的书写：中断函数与我们封装过的子函数的写法不同，有个区分标志“interrupt”。函数名我们可以随意取，只要不跟以前封装定义好的函数名冲突就行1。</p><p>EX0和EA：我们说过要想进入中断函数，必须满足它的一些前提条件。这里的EX0（IE0）和EA（IE7）要初始化赋值给1才能进入的了中断函数去执行任务。EA叫做总中断开关，EX0是针对P3.2的外部中断的开关。也就是要想进入中断函数必须满足两个开关都要闭合（都为1）1。</p><p>中断函数注意事项：中断函数应该尽可能地短小精悍，以避免在执行中断时影响程序的性能。在中断函数中使用的变量应该是 volatile 类型，以确保其值会在中断时被正确更新。为了确保程序的可靠性，应该避免在中断函数中使用复杂的逻辑控制结构，例如循环和递归2。</p><p>关于常见的中断结构，以下是一些基本的分类：</p><p>外部中断：利用检测GPIO引脚变化来执行一些操作3。</p><p>定时器中断：定时时间到了。</p><p>串口中断：串口接收到了数据。</p><p>中断优先级：当有多个中断源同时申请中断时，CPU会根据中断源的轻重缓急进行裁决，优先响应更加紧急的中断源3。</p><p>链接：<a href="https://www.dotcpp.com/course/367">https://www.dotcpp.com/course/367</a><br><strong>问：单片机中寄存器有哪些种类？所谓的RAM又和寄存器是什么关系？</strong>    </p><p>单片机中寄存器有很多种类，根据功能和用途，可以分为以下几类：</p><p>CPU寄存器：用于存储和检查CPU的状态，如程序计数器、累加器、栈指针等。           </p><p>特殊功能寄存器：用于控制和设置单片机的外围功能，如定时器&#x2F;计数器、串口、中断、看门狗等。      </p><p>通用寄存器：用于存储临时数据和变量，如寄存器组R0-R7等。       </p><p>可位寻址寄存器：用于存储和操作单个位，如P0-P3等。<br>RAM用于存储程序运行中的数据和变量，断电即丢失。51单片机</p><h3 id="7-2-crol-函数"><a href="#7-2-crol-函数" class="headerlink" title="7-2 _crol_函数"></a>7-2 _crol_函数</h3><p>_crol_函数功能：将 c 进行b位左位移，并将值以unsigned char类型返回</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> _crol_ (<br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> c,        <span class="hljs-comment">/* character to rotate left */</span><br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> b);       <span class="hljs-comment">/* bit positions to rotate */</span><br><br></code></pre></td></tr></table></figure><p>函数返回类型为unsigned char，函数的两个形参也是unsigned char类型。</p><p>c 为要被进行 位左移 的形式参数</p><p>b 为要进行的 位移数</p><h3 id="7-3-中断相关寄存器"><a href="#7-3-中断相关寄存器" class="headerlink" title="7-3 中断相关寄存器"></a>7-3 中断相关寄存器</h3><h4 id="中断请求TCON"><a href="#中断请求TCON" class="headerlink" title="中断请求TCON"></a>中断请求TCON</h4><p>51单片机Tcon寄存器是定时器&#x2F;计数器控制寄存器，它可以控制定时器&#x2F;计数器的启动、停止、溢出和中断。它的每一位都有特定的功能，如下：（7-&gt;0)</p><p>TF1：定时器T1溢出标志位。当定时器T1溢出时，由硬件自动置1，并向CPU申请中断。CPU响应中断后，自动对TF1清零。TF1也可以用软件清零。<br>TR1：定时器T1运行控制位。可由软件置1或清零来启动或关闭定时器T1，使定时器T1开始计数。用指令SETB TR1或CLR TR1使TR1置1或清零。<br>TF0：定时器T0溢出标志位。当定时器T0溢出时，由硬件自动置1，并向CPU申请中断。CPU响应中断后，自动对TF0清零。TF0也可以用软件清零。<br>TR0：定时器T0运行控制位。可由软件置1或清零来启动或关闭定时器T0，使定时器T0开始计数。用指令SETB TR0或CLR TR0使TR0置1或清零。<br>IE1：外部中断INT1请求中断标志位。当外部中断INT1引脚出现有效的请求信号时，由硬件自动置1，并向CPU申请中断。CPU响应中断后，自动对IE1清零。IE1也可以用软件清零。<br>IT1：外部中断INT1触发方式控制位。当IT1&#x3D;1时，为跳变沿触发方式，INT1上的电平从高到低的负跳变有效；当IT1&#x3D;0时，为电平触发方式，INT1上低电平有效。<br>IE0：外部中断INT0请求中断标志位。当外部中断INT0引脚出现有效的请求信号时，由硬件自动置1，并向CPU申请中断。CPU响应中断后，自动对IE0清零。IE0也可以用软件清零。<br>IT0：外部中断INT0触发方式控制位。当IT0&#x3D;1时，为跳变沿触发方式，INT0上的电平从高到低的负跳变有效；当IT0&#x3D;0时，为电平触发方式，INT0上低电平有效。     </p><h4 id="中断允许IE"><a href="#中断允许IE" class="headerlink" title="中断允许IE"></a>中断允许IE</h4><p><img src="https://picss.sunbangyan.cn/2024/01/28/9fee7f34885e9ba88182815d77044b3d.jpeg"></p><p>EA：中断总允许位。EA&#x3D;1，CPU开放中断；EA&#x3D;0，CPU禁止所有的中断请求。EA相当于一个总开关，只有当EA&#x3D;1时，其他位才有效。         </p><p>ES：串行口中断允许位。ES&#x3D;1，允许串行口中断；ES&#x3D;0，禁止串行口中断。当ES&#x3D;1时，如果串行口接收或发送缓冲区满或空时，会产生中断请求。         </p><p>ET1：定时器&#x2F;计数器1溢出中断允许位。ET1&#x3D;1，允许T1中断；ET1&#x3D;0，禁止T1中断。当ET1&#x3D;1时，如果定时器&#x2F;计数器1溢出时，会产生中断请求。</p><p>EX1：外部中断1允许位。EX1&#x3D;1，允许外部中断1中断；EX1&#x3D;0，禁止外部中断1中断。当EX1&#x3D;1时，如果外部中断引脚INT1出现有效的请求信号时，会产生中断请求。         </p><p>ET0：定时器&#x2F;计数器0溢出中断允许位。ET0&#x3D;1，允许T0中断；ET0&#x3D;0，禁止T0中断。当ET0&#x3D;1时，如果定时器&#x2F;计数器0溢出时，会产生中断请求。              </p><p>EX0：外部中断0允许位。EX0&#x3D;1，允许外部中断0中断；EX0&#x3D;0，禁止外部中断0中断。当EX0&#x3D;1时，如果外部中断引脚INT0出现有效的请求信号时，会产生中断请求。        </p><h4 id="如何中断？"><a href="#如何中断？" class="headerlink" title="如何中断？"></a>如何中断？</h4><p>中断响应条件<br>①中断源有中断请求；<br>②此中断源的中断允许位为 1；<br>③CPU 开中断（即 EA&#x3D;1）。<br>以上三条同时满足时，CPU 才有可能响应中断。在使用中断时我们需要做什么呢？<br>①你想使用的中断是哪个？选择相应的中断号；<br>②你所希望的触发条件是什么？<br>③你希望在中断之后干什么？<br>我们以外部中断 0 为例，如下：<br>主程序中需要有以下代码           </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c">EA=<span class="hljs-number">1</span>；<span class="hljs-comment">//打开总中断开关</span><br>EX0=<span class="hljs-number">1</span>；<span class="hljs-comment">//开外部中断 0</span><br>IT0=<span class="hljs-number">0</span>/<span class="hljs-number">1</span>；<span class="hljs-comment">//设置外部中断的触发方式</span><br>中断服务函数：<br><span class="hljs-type">void</span> int0() interrupt <span class="hljs-number">0</span> using <span class="hljs-number">1</span><br>&#123;<br><span class="hljs-comment">//编写用户所需的功能代码</span><br>&#125;<br></code></pre></td></tr></table></figure><p>void int0() interrupt 0 using 1是一种定义中断服务函数的语法，它的含义是：</p><p>void表示这个函数没有返回值，也没有参数。<br>int0表示这个函数的名字是int0，你可以自己取其他的名字，但要避免和系统函数重名。<br>interrupt 0表示这个函数是外部中断0的中断服务函数，当外部中断0发生时，CPU会自动调用这个函数。<br>using 1表示这个函数使用第1组寄存器，也就是R0-R7的地址是08H-0FH。using后面的数字可以是0-3，分别对应第0-3组寄存器。<br>例如，以下是一个简单的中断服务函数，它的功能是每当外部中断0发生时，就让P0口的值取反：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">int0</span><span class="hljs-params">()</span> interrupt 0 using 1<br>&#123;<br>    P0 = ~P0; <span class="hljs-comment">// P0口取反</span><br>&#125;<br><br></code></pre></td></tr></table></figure><p><strong>关于using 1是否可以省略的问题</strong><br>using 1是否可以省略，取决于你的具体需求和编译器的设置。一般来说，using 1是用来指定中断服务函数使用的寄存器组的，如果不写using 1，编译器会自动选择一组寄存器作为绝对寄存器访问的。1 using 1对代码是有一定的影响的，比如：</p><p>使用using 1可以节省一些代码空间，因为不需要在进入和退出中断时保存和恢复寄存器的值。<br>使用using 1可以提高一些执行速度，因为不需要进行寄存器的切换操作。<br>使用using 1可以避免一些潜在的错误，比如如果在中断中调用了其他函数，而这些函数也使用了相同的寄存器组，就可能导致数据的混乱和覆盖。<br>所以，如果你的中断服务函数比较简单，不需要调用其他函数，也不需要使用多个寄存器，那么你可以省略using 1，让编译器自动选择寄存器组。但是，如果你的中断服务函数比较复杂，需要调用其他函数，或者需要使用多个寄存器，那么你最好使用using 1，来指定不同的寄存器组，以提高效率和安全性。</p><h3 id="7-4-外部中断-按键控制LED灯-（外部中断用法）"><a href="#7-4-外部中断-按键控制LED灯-（外部中断用法）" class="headerlink" title="7-4 外部中断-按键控制LED灯 （外部中断用法）"></a>7-4 外部中断-按键控制LED灯 （外部中断用法）</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;REGX52.H&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;Delay.h&quot;</span></span><br><span class="hljs-type">void</span> <span class="hljs-title function_">Init_INT0</span><span class="hljs-params">()</span><br>&#123;<br>EA=<span class="hljs-number">1</span>;   <span class="hljs-comment">//cpu中断允许</span><br>EX0=<span class="hljs-number">1</span>;  <span class="hljs-comment">//INT0中断允许</span><br>IT0=<span class="hljs-number">1</span>;  <span class="hljs-comment">//触发模式为下降沿触发</span><br>&#125;<br><span class="hljs-type">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>Init_INT0();<br><span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)<br>&#123;<br><br>&#125;<br>&#125;<br><span class="hljs-type">void</span> <span class="hljs-title function_">exti0</span><span class="hljs-params">()</span> interrupt 0     <span class="hljs-comment">//其实就是一个if的逻辑</span><br>&#123;<br>Delay_1ms(<span class="hljs-number">1</span>);<br><span class="hljs-keyword">if</span>(P3_2==<span class="hljs-number">0</span>)<br>P2_0=!P2_0;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://picdl.sunbangyan.cn/2024/01/30/ed710a3f73b151bd0ee0dd7669982788.jpeg"><br>从这个图可以看到INT0默认的外部中断触发方式是IO口P3_2，也就是和独立按键共用了一个I&#x2F;O口。</p><h3 id="7-5按键控制流水灯（定时器用法）"><a href="#7-5按键控制流水灯（定时器用法）" class="headerlink" title="7-5按键控制流水灯（定时器用法）"></a>7-5按键控制流水灯（定时器用法）</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs c"><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;REGX52.H&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;Timer0.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;Key.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;INTRINS.H&gt;</span></span><br><br><span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> KeyNum,LEDMode;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>P2=<span class="hljs-number">0xFE</span>;<br>Timer0Init();<br><span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)<br>&#123;<br>KeyNum=Key();<span class="hljs-comment">//获取独立按键键码</span><br><span class="hljs-keyword">if</span>(KeyNum)<span class="hljs-comment">//如果按键按下</span><br>&#123;<br><span class="hljs-keyword">if</span>(KeyNum==<span class="hljs-number">1</span>)<span class="hljs-comment">//如果K1按键按下</span><br>&#123;<br>LEDMode++;<span class="hljs-comment">//模式切换</span><br><span class="hljs-keyword">if</span>(LEDMode&gt;=<span class="hljs-number">2</span>)LEDMode=<span class="hljs-number">0</span>;<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">Timer0_Routine</span><span class="hljs-params">()</span> interrupt 1<br>&#123;<br><span class="hljs-type">static</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> T0Count;<br>TL0 = <span class="hljs-number">0x18</span>;<span class="hljs-comment">//设置定时初值</span><br>TH0 = <span class="hljs-number">0xFC</span>;<span class="hljs-comment">//设置定时初值</span><br>T0Count++;<span class="hljs-comment">//T0Count计次，对中断频率进行分频</span><br><span class="hljs-keyword">if</span>(T0Count&gt;=<span class="hljs-number">500</span>)<span class="hljs-comment">//分频500次，500ms</span><br>&#123;<br>T0Count=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">if</span>(LEDMode==<span class="hljs-number">0</span>)<span class="hljs-comment">//模式判断</span><br>P2=_crol_(P2,<span class="hljs-number">1</span>);<span class="hljs-comment">//LED输出</span><br><span class="hljs-keyword">if</span>(LEDMode==<span class="hljs-number">1</span>)<br>P2=_cror_(P2,<span class="hljs-number">1</span>);<br>&#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;REGX52.H&gt;</span></span><br><span class="hljs-type">void</span> <span class="hljs-title function_">Timer0Init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>TMOD &amp;= <span class="hljs-number">0xF0</span>;<span class="hljs-comment">//设置定时器模式</span><br>TMOD |= <span class="hljs-number">0x01</span>;<span class="hljs-comment">//设置定时器模式</span><br>TL0 = <span class="hljs-number">0x18</span>;<span class="hljs-comment">//设置定时初值</span><br>TH0 = <span class="hljs-number">0xFC</span>;<span class="hljs-comment">//设置定时初值</span><br>TF0 = <span class="hljs-number">0</span>;<span class="hljs-comment">//清除TF0标志</span><br>TR0 = <span class="hljs-number">1</span>;<span class="hljs-comment">//定时器0开始计时</span><br>ET0=<span class="hljs-number">1</span>;<br>EA=<span class="hljs-number">1</span>;<br>PT0=<span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">/*定时器中断函数模板(1000ms)</span><br><span class="hljs-comment">void Timer0_Routine() interrupt 1</span><br><span class="hljs-comment">&#123;</span><br><span class="hljs-comment">static unsigned int T0Count;</span><br><span class="hljs-comment">TL0 = 0x18;//设置定时初值</span><br><span class="hljs-comment">TH0 = 0xFC;//设置定时初值</span><br><span class="hljs-comment">T0Count++;</span><br><span class="hljs-comment">if(T0Count&gt;=1000)</span><br><span class="hljs-comment">&#123;</span><br><span class="hljs-comment">T0Count=0;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">&#125;</span><br><span class="hljs-comment">&#125;</span><br><span class="hljs-comment">*/</span><br><br><br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>EE</category>
      
      <category>51单片机</category>
      
    </categories>
    
    
    <tags>
      
      <tag>51单片机</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2013B读论文笔记</title>
    <link href="/2025/03/21/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1/2013B%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0/"/>
    <url>/2025/03/21/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1/2013B%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>拼接碎纸片成为完整的纸片，问题难度循序渐进，分为三个</p><ul><li>一张写有汉字的纸纵切成19条，要求复原</li><li>一张写有汉字的纸，一张写有英文的纸分别横纵切为11*19个块，要求分别复原</li><li>一张双面写有汉字的纸，横纵切为11*19个块，要求区分开正反面复原<br>可以人工干预，各个片(条)没有旋转，边缘信息保留较好。</li></ul><h1 id="处理思路"><a href="#处理思路" class="headerlink" title="处理思路"></a>处理思路</h1><h2 id="Q1"><a href="#Q1" class="headerlink" title="Q1"></a>Q1</h2><ul><li>$step1$ 将19个条建立对应的灰度值矩阵，（考虑）转化为0,1矩阵</li><li>$step2$ 找到每个矩阵对应的最左边和最右边向量，依次与其他矩阵的最左最右向量遍历比较，定义一个量描述差异度<br>采用曼哈顿距离，注意：最左侧碎片判断为左留白最多者<br>$$\delta(n,k)&#x3D;\sum\left|g_{n,R}-g_{k,L}\right|$$</li></ul><h2 id="Q2"><a href="#Q2" class="headerlink" title="Q2"></a>Q2</h2><ul><li><p>$step1$<br>先行后列的方法，因为每个碎片竖向距离更大，蕴含信息更多。考虑采用聚类的方法聚类出十一个类别（行），比如使用k-means算法。自然地我们需要选取进行聚类的特征，对汉字来说，基准线是一个很好的选择，因为汉字排列是公正的，以每一条基准线开始的位置作为特征进行聚类可以方便的得到结果。对于英文，基准线方法较为困难，考虑双基准线的方法即可</p></li><li><p>$step2$<br>每一行的内部碎片进行匹配时，边缘信息量较少，需要更优的距离函数描述差异。采用斯皮尔曼相关系数。<br>斯皮尔曼秩相关系数(The Spearman’s rank coefficient of correlation)，简称斯皮尔曼相关系数，是秩相关(rank correlation)的一种非参数度量(nonparametric measure)。得名于英国统计学家Charles Spearman，通常记为希腊字母‘ρ’ (rho)( often called Spearman’s rho)或者 。</p><p>  在讨论斯皮尔曼相关系数之前，首先要理解皮尔逊相关(Pearson’s correlation)，斯皮尔曼相关可以看作是皮尔逊相关的非参数版本（nonparametric version）。皮尔逊相关是关于两个随机变量之间的线性关系强度的统计度量(statistical measure)，而斯皮尔曼相关考察的是两者单调关系（monotonic relationship）的强度，通俗地说就是两者在变大或变小的趋势上多大程度上保持步调一致，哪怕没有保持比例关系。计算皮尔逊相关系数时使用的是数据样本值本身，而计算斯皮尔曼相关系数使用的是数据样本排位位次值（有时候数据本身就是位次值，有时候数据本身不是位次值，则在计算斯皮尔曼相关系数之前要先计算位次值）。</p><p>  这里”非参数”有两层含义。首先，当X和Y的关系是由任意单调函数描述的，则它们是完全皮尔逊相关的。与此相应的，皮尔逊相关系数只能给出由线性方程描述的X和Y的相关性。其次，斯皮尔曼不需要先验知识(也就是说，除了数据本身不需要知道其它参数，比如说关于数据的分布的先验信息)便可以准确获取X和Y的采样概率分布之间的相关性。</p><p>  $$\rho&#x3D;\frac{\frac1n\sum_{i&#x3D;1}^n\left(R(x_i)-\overline{R(x)})\cdot(R(y_i)-\overline{R(y)}\right)}{\sqrt{\left(\frac1n\sum_{i&#x3D;1}^n\left(R(x_i)-\overline{R(x)}\right)^2\right)\cdot\left(\frac1n\sum_{i&#x3D;1}^n\left(R(y_i)-\overline{R(y)}\right)^2\right)}}$$</p><h2 id="Q3"><a href="#Q3" class="headerlink" title="Q3"></a>Q3</h2></li></ul>]]></content>
    
    
    <categories>
      
      <category>数学建模</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>图论</title>
    <link href="/2025/03/21/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1/%E5%9B%BE%E8%AE%BA/"/>
    <url>/2025/03/21/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1/%E5%9B%BE%E8%AE%BA/</url>
    
    <content type="html"><![CDATA[<h2 id="理论"><a href="#理论" class="headerlink" title="理论"></a>理论</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p>假设平面上的$n$个点，把其中的一些点对用曲线或直线连接起来，不考虑点的位置与连线曲直长短，形成的一个关系结构称为一个图。记   </p><p>$G&#x3D;\left(V(G),E(G)\right),V&#x3D;V(G)$ 是顶点集，$E&#x3D;E(G)$ 是边集。      </p><p>设$\nu{\in}V(G)$,若$\nu$是边$e{\in}E(G)$的端点，则称$\nu$与$e$相关联， 与顶点$\nu$关联的边数之和称为该顶点的次数（度数），记为$d(\nu)$。可以证明握手定理</p><p>$$<br>\sum_{\nu\in V(G)}d(\nu)&#x3D;2|E(G)|:,<br>$$</p><p>且由此可知：奇次顶点的总数是偶数，且所有<br>顶点的次数之和是边数的两倍。次数为奇数顶点称为奇点，否则称为偶点。所以我们在一些建模问题中，为了消去奇次顶点，可以两两配对进行加边。</p><p>常用$d(\nu)$表示图$G$ 中与顶点$\nu$关联的边的数目， $d(\nu)$称为顶点$\nu$的度数.<br> 与顶点$\nu$出关联的边的数目称为出度，记作${d^+}(\nu)$,<br> 与顶点$\nu$入关联的边的数目称为入度，记作${d^-(\nu)}$。用$N(\nu)$表示图$G$ 中所有与顶点$\nu$相邻的顶点的集合.</p><p>有结论:<br>$\sum_{\nu\in V}d^{+}\big(\nu\big)&#x3D;\sum_{\nu\in V}d^{-}\big(\nu\big)&#x3D;\big|E|$  </p><p>这是显然的，每条弧必然连接两个顶点，也对应一个入度和一个出度，所以所有顶点的入度之和等于所有顶点的出度之和</p><p>若对于每条边是有指向的,则称为有向图;若每条边是不区分指向的,则称为无向图。若有的边有向，有的边无向，则称为混合图。</p><h3 id="特殊的结构"><a href="#特殊的结构" class="headerlink" title="特殊的结构"></a>特殊的结构</h3><p><strong>self-loop（自环）</strong> 一个节点指向自己的边，比如网络爬虫中我们需要遍历所有网页，但有的网页会给出自己的url（链接到自己），这就需要用自环描述<br><strong>mutiedge(多重边)</strong>   一个城市到另一个城市有很多条不同的航班，要用多重边描述。</p><h3 id="图的邻接矩阵-adjacency-matrix-表示法"><a href="#图的邻接矩阵-adjacency-matrix-表示法" class="headerlink" title="图的邻接矩阵(adjacency matrix)表示法"></a>图的邻接矩阵(adjacency matrix)表示法</h3><p>将邻接矩阵理解为一种数据结构<br>图$G&#x3D;(V,E)$的邻接矩阵$C&#x3D;(c_{ij})$是如下定义<br>$$c_{ij}&#x3D;\begin{cases}1,(v_i,v_j)\in E\0,(v_i,v_j)\not\in E\end{cases}$$</p><p>也就是说，<br><strong>1</strong>     如果两节点之间有一条弧,则邻接矩阵中对应的元素为1;否则为0。这一数据结构便于我们查找图的情况与节点连接情况。<br><strong>2</strong>  如果图中的每条边都有一个（或多个）实数与之对应，称这样的图为赋权图。同样,对于网络中的权,也可以用这样的邻接矩阵表示。只是此时一条弧所对应的元素不再是1,而是相应的权</p><p><img src="https://www.freeimg.cn/i/2024/05/06/6638cec520744.png"><br>邻接矩阵表示为<br>$\begin{pmatrix}0&amp;1&amp;1&amp;0&amp;0\0&amp;0&amp;0&amp;1&amp;0\0&amp;1&amp;0&amp;0&amp;0\0&amp;0&amp;1&amp;0&amp;0\0&amp;0&amp;1&amp;1&amp;0\end{pmatrix}$<br>注意到<br>无向图的邻接矩阵是一个对称阵<br>如果网络比较稀疏,这种表示法会浪费大量的存储空间,而且增加了在网络中查找弧的时！          </p><h3 id="关联矩阵表示法-incidence-matrix"><a href="#关联矩阵表示法-incidence-matrix" class="headerlink" title="关联矩阵表示法(incidence matrix)"></a>关联矩阵表示法(incidence matrix)</h3><p>图$G&#x3D;(V,E)$的关联矩阵$B&#x3D;(b_{ij})$定义为：<br>$$b_{ij}&#x3D;\begin{cases}1,&amp;\exists v_k\in V,s.t.e_j&#x3D;(v_i,v_k)\in E\-1,&amp;\exists v_k\in V,s.t.e_j&#x3D;(v_k,v_i)\in E\0,&amp;其他\end{cases}$$<br>也就是说，节点$v_i$是边$e_j$的起点时，$b_{ij}&#x3D;1$,是终点时，$b_{ij}&#x3D;-1$,否则为$b_{ij}&#x3D;0$。<br>·关联矩阵中，每一行对应一个节点；每一列对应一条边。·对于简单图，每一列只有2个非0元(一个1，一个-1)。·对于赋权图，可以把关联矩阵增加一行，把每一条弧所对应的权存储在增加的行中。</p><h3 id="Dijkstra算法"><a href="#Dijkstra算法" class="headerlink" title="Dijkstra算法"></a>Dijkstra算法</h3><p>算法目标：在一个有权重的图中，给出一个起始点，我们可以求出到达其他所有点的最短路径。      </p><p>有一个极其重要的图论定理:<strong>最短路径的子路径仍然是最短路径</strong></p><p>（最短路径的子路径最优性质）： 如果在带权图中从顶点u到顶点v存在一条最短路径P，并且路径P经过中间顶点w，那么从u到w的子路径Q1和从w到v的子路径Q2分别也是u到w和w到v的最短路径。           </p><p><a href="https://zhuanlan.zhihu.com/p/454373256">https://zhuanlan.zhihu.com/p/454373256</a></p><p>Dijkstra算法是把从起点开始到其他点的所有路径按长度从小到大的顺序列举了出来，保证前一次列出的路径的长度一定小于下一次，这样的话，当某个节点第一次作为终点出现时，一定是最短路径，因为后续列出的路径一定比这一次要长</p><p>具体来说，Dijkstra算法的执行过程如下：</p><p>1，找出此时路状态表中最短的一条，这一定是我们要求的d[]&#x3D;M.(因为倘若这不是我们要求的d，那么我们要求的d一定在由起始点从其他节点过来的路上，但那些路必然包含着大于M的子路径，归谬！所以此时状态表中最短的d[]就是我们要求的d[]).记录st[t]&#x3D;true，并记录t作为下一次延伸节点<br>2从t向外再延伸一次得到一系列新的待比较的d[]，与原有d[]取min留下，得到从t向外延伸一次后新的d[]表<br>重复到1步骤   </p><p>这本质上实在逐步构建最短路径树。</p><p>c艹代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">510</span>;<br><span class="hljs-type">int</span> dist[N];<span class="hljs-comment">//dist[i]表示结点i到起点的距离</span><br><span class="hljs-type">int</span> g[N][N];<span class="hljs-comment">//g[i][j]表示结点i到结点j的边的长度</span><br><span class="hljs-type">bool</span> st[N];<span class="hljs-comment">//st[i]表示该结点是否确定了最小距离，1是确定，0是未确定</span><br><span class="hljs-type">int</span> n, m;<br><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dijkstra</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">memset</span>(dist, <span class="hljs-number">0x3f</span>, <span class="hljs-keyword">sizeof</span> dist);<span class="hljs-comment">//把距离初始化为正无穷</span><br>    dist[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<br>    <br>    <span class="hljs-type">int</span> iter = n;<br>    <span class="hljs-keyword">while</span>(iter--)<span class="hljs-comment">//n个点，循环n次</span><br>    &#123;<br>        <span class="hljs-type">int</span> t = <span class="hljs-number">-1</span>;<br>        <span class="hljs-comment">//t随便初始化了一个不存在的结点，它最终用来存储未确定最小距离的结点，且该结点与其它结点相比目前到起点的距离最小</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>            <span class="hljs-keyword">if</span>(st[i] == <span class="hljs-number">0</span> &amp;&amp; (t == <span class="hljs-number">-1</span> || dist[i] &lt; dist[t]))<br>                t = i;<br>                <br>        st[t] = <span class="hljs-literal">true</span>;<br>        <span class="hljs-comment">//用结点t依次取更新其它结点到起点的距离，dist[i] = min(dist[i], dist[t] + g[t][i]);</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>            <span class="hljs-keyword">if</span>(st[i] == <span class="hljs-number">0</span>)<br>                dist[i] = <span class="hljs-built_in">min</span>(dist[i], dist[t] + g[t][i]);<br>                <br>    &#125;<br>    <br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <br>    cin &gt;&gt; n &gt;&gt; m;<br>    <br>    <span class="hljs-built_in">memset</span>(g, <span class="hljs-number">0x3f</span>, <span class="hljs-keyword">sizeof</span> g);<span class="hljs-comment">//将边先初始化为正无穷</span><br>    <br>    <span class="hljs-keyword">while</span>(m--)<br>    &#123;<br>        <span class="hljs-type">int</span> x, y, z;<br>        cin &gt;&gt; x &gt;&gt; y &gt;&gt; z;<br>        g[x][y] = <span class="hljs-built_in">min</span>(g[x][y], z);<span class="hljs-comment">//存在重边</span><br>        <span class="hljs-comment">//对于自环，不做处理，它不影响结果的计算</span><br>    &#125;<br>    <br>    <br>    <span class="hljs-built_in">dijkstra</span>();<br>    <br>    <br>    <span class="hljs-keyword">if</span>(dist[n] == <span class="hljs-number">0x3f3f3f3f</span>)<br>        cout &lt;&lt; <span class="hljs-string">&quot;-1&quot;</span> &lt;&lt; endl;<br>    <span class="hljs-keyword">else</span><br>        cout &lt;&lt; dist[n] &lt;&lt; endl;<br>    <br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>eg:   请帮助该公司设计一张城市 $c_1$到其它城市间的票价最便宜的路线图。</p><p>某公司在六个城市$c_1,c_2,\cdots,c_6$中有分公司，从 $c_i$到$c_j$的直接航程票价记在下述矩阵的$(i,j)$位置上$(\infty$表示无直接航路)<br>$$\begin{pmatrix}0&amp;50&amp;\infty&amp;40&amp;25&amp;10\50&amp;0&amp;15&amp;20&amp;\infty&amp;25\\infty&amp;15&amp;0&amp;10&amp;20&amp;\infty\40&amp;20&amp;10&amp;0&amp;10&amp;25\25&amp;\infty&amp;20&amp;10&amp;0&amp;55\10&amp;25&amp;\infty&amp;25&amp;550\end{pmatrix}$$</p><p>py代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> networkx <span class="hljs-keyword">as</span> nx<br><span class="hljs-comment"># create a undirected graphs.</span><br>G = nx.Graph()<br>G.add_node(<span class="hljs-number">1</span>,name=<span class="hljs-string">&quot;1&quot;</span>)<br>G.add_node(<span class="hljs-number">2</span>)<br>G.add_node(<span class="hljs-number">3</span>)<br>G.add_node(<span class="hljs-number">4</span>)<br>G.add_node(<span class="hljs-number">5</span>)<br>G.add_node(<span class="hljs-number">6</span>)<br><span class="hljs-comment"># add edges with weight: price</span><br>G.add_edge(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, price=<span class="hljs-number">50</span>)<br>G.add_edge(<span class="hljs-number">1</span>, <span class="hljs-number">4</span>, price=<span class="hljs-number">40</span>)<br>G.add_edge(<span class="hljs-number">1</span>, <span class="hljs-number">5</span>, price=<span class="hljs-number">25</span>)<br>G.add_edge(<span class="hljs-number">1</span>, <span class="hljs-number">6</span>, price=<span class="hljs-number">10</span>)<br>G.add_edge(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, price=<span class="hljs-number">15</span>)<br>G.add_edge(<span class="hljs-number">2</span>, <span class="hljs-number">4</span>, price=<span class="hljs-number">20</span>)<br>G.add_edge(<span class="hljs-number">2</span>, <span class="hljs-number">6</span>, price=<span class="hljs-number">25</span>)<br>G.add_edge(<span class="hljs-number">3</span>, <span class="hljs-number">4</span>, price=<span class="hljs-number">10</span>)<br>G.add_edge(<span class="hljs-number">3</span>, <span class="hljs-number">5</span>, price=<span class="hljs-number">20</span>)<br>G.add_edge(<span class="hljs-number">4</span>, <span class="hljs-number">5</span>, price=<span class="hljs-number">10</span>)<br>G.add_edge(<span class="hljs-number">4</span>, <span class="hljs-number">6</span>, price=<span class="hljs-number">25</span>)<br>G.add_edge(<span class="hljs-number">5</span>, <span class="hljs-number">6</span>, price=<span class="hljs-number">55</span>)<br><br>sp= nx.dijkstra_path(G,<span class="hljs-number">1</span>,<span class="hljs-number">4</span>, weight=<span class="hljs-string">&#x27;price&#x27;</span>) <span class="hljs-comment">#路径</span><br><span class="hljs-built_in">print</span>(sp)<br><br><br><span class="hljs-comment"># 使用 Dijkstra 算法找到最短路径的长度  </span><br>sp_length = nx.dijkstra_path_length(G, <span class="hljs-number">1</span>, <span class="hljs-number">4</span>, weight=<span class="hljs-string">&#x27;price&#x27;</span>)  <br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;最短路径的总价格:&quot;</span>, sp_length)<br><br><br><span class="hljs-comment"># 获取最短路径的长度  ，不一定是dij算法，会根据数据结构调整算法</span><br>shortest_path_length = nx.shortest_path_length(G, source=<span class="hljs-number">1</span>, target=<span class="hljs-number">4</span>, weight=<span class="hljs-string">&#x27;price&#x27;</span>)  <br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;从节点 1 到节点 4 的最短路径总价格:&quot;</span>, shortest_path_length)<br><br><br></code></pre></td></tr></table></figure><p>matlab</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs matlab"><br>G = graph();  <br>  <br> <br>G = addnode(G,<span class="hljs-number">6</span>);  <br> <br><span class="hljs-comment">% 添加带权重的边  </span><br>G = addedge(G, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">50</span>);  <br>G = addedge(G, <span class="hljs-number">1</span>, <span class="hljs-number">4</span>, <span class="hljs-number">40</span>);  <br>G = addedge(G, <span class="hljs-number">1</span>, <span class="hljs-number">5</span>, <span class="hljs-number">25</span>);  <br>G = addedge(G, <span class="hljs-number">1</span>, <span class="hljs-number">6</span>, <span class="hljs-number">10</span>);  <br>G = addedge(G, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">15</span>);  <br>G = addedge(G, <span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-number">20</span>);  <br>G = addedge(G, <span class="hljs-number">2</span>, <span class="hljs-number">6</span>, <span class="hljs-number">25</span>);  <br>G = addedge(G, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">10</span>);  <br>G = addedge(G, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-number">20</span>);  <br>G = addedge(G, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">10</span>);  <br>G = addedge(G, <span class="hljs-number">4</span>, <span class="hljs-number">6</span>, <span class="hljs-number">25</span>);  <br>G = addedge(G, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">55</span>);  <br>  <br><br>[dist, path] = shortestpath(G, <span class="hljs-number">1</span>, <span class="hljs-number">4</span>);  <span class="hljs-comment">%注意接口顺序</span><br><span class="hljs-built_in">plot</span>(G) <br><span class="hljs-comment">% 打印最短路径  </span><br><span class="hljs-built_in">disp</span>(<span class="hljs-string">&#x27;最短路径长度：&#x27;</span>);  <br><span class="hljs-built_in">disp</span>(dist);  <br><span class="hljs-built_in">disp</span>(<span class="hljs-string">&#x27;最短路径为：&#x27;</span>);  <br><span class="hljs-built_in">disp</span>(path);<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数学建模</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>层次分析模版</title>
    <link href="/2025/03/21/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1/%E5%B1%82%E6%AC%A1%E5%88%86%E6%9E%90/"/>
    <url>/2025/03/21/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1/%E5%B1%82%E6%AC%A1%E5%88%86%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h2 id="step1画图建立层次模型结构"><a href="#step1画图建立层次模型结构" class="headerlink" title="step1画图建立层次模型结构"></a>step1画图建立层次模型结构</h2><p>确定评价指标形成评价体系，选择最佳的方案，我们要考虑</p><ul><li>评价目标是什么？</li><li>评价标准是什么？</li><li>可选方案有哪些？</li></ul><p>注意！！使用层次分析，论文中应当出现这个图<img src="https://www.freeimg.cn/i/2024/07/26/66a33eaa6172d.png" alt="1721974438802.png"></p><h2 id="step2列出每个指标的评价矩阵"><a href="#step2列出每个指标的评价矩阵" class="headerlink" title="step2列出每个指标的评价矩阵"></a>step2列出每个指标的评价矩阵</h2><p><img src="https://www.freeimg.cn/i/2024/07/26/66a33d69af56d.png" alt="1721974119051.png"></p><p><img src="https://www.freeimg.cn/i/2024/07/26/66a33f0ac76e9.png" alt="1721974535304.png"></p><p>将该表格记为矩阵，第i行j个元素记为 $a_{ij}$</p><ul><li><p>(1)$a_{ij}$的含义表示$i$ 相较于$j$ 的重要程度.</p></li><li><p>(2)当$i&#x3D;j$时，规定$a_{ij}&#x3D;1.$</p></li><li><p>(3)当且仅当$a_{ij}&gt;0,a_{ij}\times a_{ji}&#x3D;1$时，称该矩阵为正互反矩阵. 这个矩阵就是层次分析法中的判断矩阵，有了判断矩阵，就可以得出各个评判指标之间的权重向量了</p></li></ul><h2 id="step3每一个评价矩阵进行一致性检验"><a href="#step3每一个评价矩阵进行一致性检验" class="headerlink" title="step3每一个评价矩阵进行一致性检验"></a>step3每一个评价矩阵进行一致性检验</h2><p>正互反矩阵应当是秩1矩阵，因为显然该体系自由度为n，我们只需要矩阵的一行或一列便可以推出整个矩阵。那么自然地该矩阵特征值为n，每一个列向量都可以作为特征向量。</p><ul><li>1.正互反矩阵$A$ 的秩$1,A$ 的唯一非零特征根为$n;$</li><li>2.正互反矩阵$A$ 的任一列向量都是对于特征根$n$ 的特征向量， </li><li>3.当正互反矩阵$A$不为一致阵时，其最大特征根$\lambda_\mathrm{max}&gt;n.$ $\lambda$与$n$ 相差越大，其不一致程度越大</li></ul><p>计算一致性指标，$CI&#x3D;\frac{\lambda_{\max}-n}{n-1},CI&#x3D;\begin{cases}0\text{,有完全一致性}\\text{接近}0\text{,满意的一致性}\\\text{越大，一致性越差}&amp;\end{cases}$</p><p>为了衡量$CI$的大小，引入随机一致性指标$RI$,先构造500个判断矩阵$A_1,A_2,…,A_{500}$<br>分别计算其$\lambda_\mathrm{max}$,于是得到它们的一致性指标 $CI_1,CI_2,\cdotp\cdotp\cdotp,CI_{500}$</p><p>定义一致性指标$RI&#x3D;\frac{CI_1+CI_2+\cdotp\cdotp\cdotp CI_{500}}{500}&#x3D;\frac{\frac{\lambda_1+\lambda_2+\cdotp\cdotp\cdotp+\lambda_{500}}{500}-n}{n-1}$,常用随机一致性指标可以查表</p><table>    <tbody>        <tr>            <th>n</th>            <th>1</th>            <th>2</th>            <th>3</th>            <th>4</th>            <th>5</th>            <th>6</th>            <th>7</th>            <th>8</th>            <th>9</th>            <th>10</th>            <th>11</th>        </tr>        <tr>            <td> RI </td>            <td>0</td>            <td>0</td>            <td>0.58</td>            <td>0.90</td>            <td>1.12</td>            <td>1.24</td>            <td>1.32</td>            <td>1.41</td>            <td>1.45</td>            <td>1.49</td>            <td>1.51</td>        </tr>    </tbody></table><p>$$\text{一致性指标 }CI&#x3D;\frac{\lambda_{\max}-n}{n-1},\text{ 一致性比例 }CR&#x3D;\frac{CI}{RI}\binom{&lt;0.1,\text{ 判断矩阵一致}}{\geq0.1,\text{ 判断矩阵不一致}}$$</p><h2 id="step4每一个指标评价矩阵求权重向量"><a href="#step4每一个指标评价矩阵求权重向量" class="headerlink" title="step4每一个指标评价矩阵求权重向量"></a>step4每一个指标评价矩阵求权重向量</h2><h4 id="方法1：算数平均值"><a href="#方法1：算数平均值" class="headerlink" title="方法1：算数平均值"></a>方法1：算数平均值</h4><p>$$\begin{aligned}&amp;\text{对于判断矩阵}A&#x3D;\begin{bmatrix}a_{11}&amp;a_{12}&amp;\cdots&amp;a_{1n}\a_{21}&amp;a_{22}&amp;\cdots&amp;a_{2n}\\vdots&amp;\vdots&amp;\ddots&amp;\vdots\a_{n1}&amp;a_{n2}&amp;\cdots&amp;a_{nn}\end{bmatrix},\text{ 先将其归一化,再将归一化的矩阵按列相加,并将每个元素除以}n\&amp;\text{得到权重向量,即}\omega_i&#x3D;\frac1n\sum_{j&#x3D;1}^n\frac{a_{ij}}{\sum_{k&#x3D;1}^na_{kj}}\left(i&#x3D;1,2,\cdots,n\right).\end{aligned}$$</p><h4 id="方法2：求特征向量归一化向量"><a href="#方法2：求特征向量归一化向量" class="headerlink" title="方法2：求特征向量归一化向量"></a>方法2：求特征向量归一化向量</h4><p><img src="https://www.freeimg.cn/i/2024/07/26/66a352731173f.png" alt="1721979500674.png"></p><p>方法二一般精度足矣。</p><h2 id="step5填表，综合多个指标综合得出决策"><a href="#step5填表，综合多个指标综合得出决策" class="headerlink" title="step5填表，综合多个指标综合得出决策"></a>step5填表，综合多个指标综合得出决策</h2><p><img src="https://www.freeimg.cn/i/2024/07/26/66a350d2c9477.png" alt="1721979088087.png"></p>]]></content>
    
    
    <categories>
      
      <category>数学建模</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>矩阵分解</title>
    <link href="/2025/03/21/%E6%95%B0%E5%AD%A6/%E7%9F%A9%E9%98%B5%E5%88%86%E8%A7%A3%E6%96%B9%E6%B3%95/"/>
    <url>/2025/03/21/%E6%95%B0%E5%AD%A6/%E7%9F%A9%E9%98%B5%E5%88%86%E8%A7%A3%E6%96%B9%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<p>1<br><img src="https://www.freeimg.cn/i/2024/06/08/6664781cb1c53.jpg" alt="134f115b53546f316a236d2bee50694.jpg"><br>2<br><img src="https://www.freeimg.cn/i/2024/06/08/6664781c8cb5c.jpg" alt="293895b714db264c8ba7504aa4f9b87.jpg"><br>3<br><img src="https://www.freeimg.cn/i/2024/06/08/6664781c8adaa.jpg" alt="263950eefa3879a72a0c48232ba198f.jpg"><br>4<br><img src="https://www.freeimg.cn/i/2024/06/08/6664781c529e1.jpg" alt="1310a110b3104d94351998f4e5ba963.jpg"></p>]]></content>
    
    
    <categories>
      
      <category>数学</category>
      
      <category>矩阵分析</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>插值算法</title>
    <link href="/2025/03/21/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1/%E5%B7%AE%E5%80%BC%E7%AE%97%E6%B3%95/"/>
    <url>/2025/03/21/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1/%E5%B7%AE%E5%80%BC%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h2 id="插值法定理"><a href="#插值法定理" class="headerlink" title="插值法定理"></a>插值法定理</h2><p>[定理]设有$n+1$个互不相同的节点$( x_i, y_i)$ $( i&#x3D; 0, 1, 2, . . . , n)$则存在唯一的多项式：<br>$\varphi_n(x)&#x3D;a_0+a_1x+a_2x^2+…+a_nx^n$,使得$\varphi _n( x_j) &#x3D; y_j$ $( j&#x3D; 0, 1, 2, . . . n) .$<br>$$\begin{aligned}&amp;\text{证}\begin{cases}a_0+a_1x_0+a_2x_0^2+…+a_nx_0^n&#x3D;y_0\a_0+a_1x_1+a_2x_1^2+…+a_nx_1^n&#x3D;y_1\…\a_0+a_1x_n+a_2x_n^2+…+a_nx_n^n&#x3D;y_n&amp;\end{cases}\text{,令:}A&#x3D;\begin{bmatrix}1&amp;x_0&amp;\cdots&amp;x_0^n\1&amp;x_1&amp;\cdots&amp;x_1^n\\vdots&amp;\vdots&amp;\cdots&amp;\vdots\1&amp;x_n&amp;\cdots&amp;x_n^n\end{bmatrix}\quad X&#x3D;\begin{bmatrix}a_0\a_1\\vdots\a_n\end{bmatrix}\quad Y&#x3D;\begin{bmatrix}y_0\y_1\\vdots\y_n\end{bmatrix}\&amp;\text{一}\end{aligned}$$<br>又$|A|$为范德蒙行列式，很明显$r(A)&#x3D;n$,即矩阵$A$可逆，则对于方程组$AX&#x3D;Y$有且仅有一个解.<br>从而$\varphi_n(x)&#x3D;a_0+a_1x+a_2x^2+…+a_nx^n$唯一存在，证毕.</p><h2 id="拉格朗日插值法"><a href="#拉格朗日插值法" class="headerlink" title="拉格朗日插值法"></a>拉格朗日插值法</h2><ul><li>二维的，对于点 $(x_1.y_1),(x_2,y_2)$<br>$$f(x)&#x3D;\frac{x-x_2}{x_1-x_2}y_1+\frac{x-x_1}{x_2-x_1}y_2$$</li><li>三维的，<br>$$f(x)&#x3D;\frac{\left(x-x_2\right)\left(x-x_3\right)}{\left(x_1-x_2\right)\left(x_1-x_3\right)}y_1+\frac{\left(x-x_1\right)\left(x-x_3\right)}{\left(x_2-x_1\right)\left(x_2-x_3\right)}y_2+\frac{\left(x-x_1\right)\left(x-x_2\right)}{\left(x_3-x_1\right)\left(x_3-x_2\right)}y_3$$</li><li>任意的</li></ul><p>拉格朗日插值的基函数为</p><p>$$ l_i(x)&#x3D;\frac{\left(x-x_0\right)\cdots\left(x-x_{i-1}\right)\left(x-x_{i+1}\right)\cdots\left(x-x_n\right)}{\left(x_i-x_0\right)\cdots\left(x_i-x_{i-1}\right)\left(x_i-x_{i+1}\right)\cdots\left(x_i-x_n\right)} $$</p><p>插值函数为</p><p>$$L_n(x)&#x3D;\sum_{i&#x3D;0}^ny_il_i(x)&#x3D;\sum_{i&#x3D;0}^ny_i\left(\prod_{j&#x3D;0,j\neq i}^n\frac{x-x_j}{x_i-x_j}\right).$$</p><h2 id="牛顿插值法"><a href="#牛顿插值法" class="headerlink" title="牛顿插值法"></a>牛顿插值法</h2><p>观察基本思路<br>$$f_1(x)&#x3D;f(x_0)+b_1(x-x_0)$$<br>可以解得：$f_1(x)&#x3D;f(x_0)+\frac{f(x_1)-f(x_0)}{x_1-x_0}(x-x_0)$<br>再考虑后一个点进行修正，<br>$$f_2(x)&#x3D;f_1(x)+b_2(x-x_0)\left(x-x_1\right)\text{,令}f_2(x_2)&#x3D;f(x_2)$$</p><p>解得</p><p>$$f_2(x)&#x3D;f(x_0)+\frac{f(x_1)-f(x_0)}{x_1-x_0}(x-x_0)+\frac{\left[\frac{f(x_2)-f(x_1)}{x_2-x_1}\right]-\left[\frac{f(x_1)-f(x_0)}{x_1-x_0}\right]}{x_2-x_0}(x-x_0)(x-x_1)$$</p><p>为便于书写，引入均差的概念，</p><p>其中，两个系数<br>$$b_1&#x3D;\frac{f(x_1)-f(x_0)}{x_1-x_0}, b_2&#x3D;\frac{\left[\frac{f(x_2)-f(x_1)}{x_2-x_1}\right]-\left[\frac{f(x_1)-f(x_0)}{x_1-x_0}\right]}{x_2-x_0}$$<br>成为均差</p><p>$b_1$称为一阶均差，一般形式为<br>$$f[x_i,x_j]&#x3D;\frac{f(x_i)-f(x_j)}{x_i-x_j},i\neq j$$<br>$b_2$称为二阶均差，一般形式为<br>$$ f[x_i,x_j,x_k]&#x3D;\frac{f[i,j]\boldsymbol{-}f[j,k]}{x_i\boldsymbol{-}x_k},i\neq j\neq k $$</p><p>由此可以写出牛顿插值函数，</p><p>$$\begin{aligned}<br>f(x)&#x3D;&amp; f(x_0)+f<a href="x-x_0">x_0,x_1</a> \<br>&amp;+f[x_0,x_1,x_2]\left(x-x_0\right)\left(x-x_1\right)+\cdotp\cdotp\cdotp \<br>&amp;+f\begin{bmatrix}x_0,x_1,\cdotp\cdotp\cdotp,x_{n-2},x_{n-1}\end{bmatrix}(x-x_0)(x-x_1)\cdots(x-x_{n-2})(x-x_{n-1}) \<br>&amp;+f\left[x_{0},x_{1},\cdotp\cdotp\cdotp,x_{n-1},x_{n}\right]\left(x-x_{0}\right)\left(x-x_{1}\right)\cdotp\cdotp\cdotp\left(x-x_{n-1}\right)\left(x-x_{n}\right)<br>\end{aligned}$$</p><h2 id="埃米尔特插值法"><a href="#埃米尔特插值法" class="headerlink" title="埃米尔特插值法"></a>埃米尔特插值法</h2>]]></content>
    
    
    <categories>
      
      <category>数学建模</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>整数与非线性规划模版</title>
    <link href="/2025/03/21/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1/%E6%95%B4%E6%95%B0%E4%B8%8E%E9%9D%9E%E7%BA%BF%E6%80%A7%E8%A7%84%E5%88%92/"/>
    <url>/2025/03/21/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1/%E6%95%B4%E6%95%B0%E4%B8%8E%E9%9D%9E%E7%BA%BF%E6%80%A7%E8%A7%84%E5%88%92/</url>
    
    <content type="html"><![CDATA[<h1 id="整数规划"><a href="#整数规划" class="headerlink" title="整数规划"></a>整数规划</h1><h2 id="整数规划-1"><a href="#整数规划-1" class="headerlink" title="整数规划"></a>整数规划</h2><ul><li>整数线性规划用intlinprog求解</li><li>整数非线性规划无求解算法，只能模拟，使用蒙特卡罗或其他智能算法</li><li>个人觉得，选取决策变量是建模时及其关键的一步！</li></ul><p><img src="https://t.tutu.to/img/B8pKK"></p><h2 id="01整数规划"><a href="#01整数规划" class="headerlink" title="01整数规划"></a>01整数规划</h2><p>依然可以考虑使用求解器求解，只要限制lb&#x3D;0，ub&#x3D;1即可</p><h2 id="一些例题"><a href="#一些例题" class="headerlink" title="一些例题"></a>一些例题</h2><h3 id="学校选址要求覆盖全部小区"><a href="#学校选址要求覆盖全部小区" class="headerlink" title="学校选址要求覆盖全部小区"></a>学校选址要求覆盖全部小区</h3><p>$\begin{array}{|c|c|c|c|c|c|c|c|c|}\hline\text{备选校址}&amp;\text{B1}&amp;\text{B2}&amp;\text{B3}&amp;\text{B4}&amp;\text{B5}&amp;\text{B6}\\hline\text{覆盖小区}&amp;\text{A1,A5,A7}&amp;\text{A1,A2,A5,A8}&amp;\text{A1,A3,A5}&amp;\text{A2,A4,A8}&amp;\text{A3,A6}&amp;\text{A4,A6,A8}\\hline\end{array}$</p><p> 设$x_i&#x3D;\begin{cases}1,&amp;\text{在备选校址 }B_i\text{ 建学校},\0,&amp;\text{在备选校址 }B_i\text{ 不建学校}&amp;\end{cases}$</p><p> 约束条件应当是每个小区至少有一个学校覆盖，得到8个不等式</p><p> $$\begin{gathered}\text{s. t.}\begin{cases}x_1+x_2+x_3\geqslant1\x_4+x_6\geqslant1\x_3+x_5\geqslant1\x_2+x_4\geqslant1\x_5+x_6\geqslant1\x_1\geqslant1\x_2+x_4+x_6\geqslant1\end{cases}\end{gathered}$$</p><p> 求解$\min\sum_{i&#x3D;1}^6x_i$即可</p><h3 id="指派问题"><a href="#指派问题" class="headerlink" title="指派问题"></a>指派问题</h3><p>某公司购置了设备6台，想要分配给四个企业，每个企业得到设备后年利润如下，且每个企业至少分配得到一台设备，问如何分配使得年总利润最大</p><p><a href="https://imgse.com/i/pkqYLh6"><img src="https://s21.ax1x.com/2024/07/27/pkqYLh6.png" alt="pkqYLh6.png"></a></p><p>$x_{ij}$表示第i个机器分给了第j个企业</p><p>$$\begin{aligned}&amp;\max\sum_{i&#x3D;1}^6\sum_{j&#x3D;1}^4c_{ij}x_{ij},\mathrm{<del>s.t.</del>}\begin{cases}\sum_{i&#x3D;1}^6x_{ij}\geqslant1,j&#x3D;1,2,3,4,\\sum_{j&#x3D;1}^4x_{ij}&#x3D;1,i&#x3D;1,\cdots,6,\x_{ij}&#x3D;0\text{ 或 }1,i&#x3D;1,\cdots,6;j&#x3D;1,2,3,4.\end{cases}\end{aligned}$$</p><h3 id="通用方法：蒙特卡罗-随机数硬试"><a href="#通用方法：蒙特卡罗-随机数硬试" class="headerlink" title="通用方法：蒙特卡罗(随机数硬试)"></a>通用方法：蒙特卡罗(随机数硬试)</h3><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs matlab"><span class="hljs-comment">%% 用蒙特卡洛解决工厂分配设备问题</span><br>clear;clc;<br>n = <span class="hljs-number">10000</span>; <span class="hljs-comment">%模拟次数</span><br>C = [<span class="hljs-number">4</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>;<br>     <span class="hljs-number">6</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">5</span>;<br>     <span class="hljs-number">7</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">6</span>;<br>     <span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">8</span>,<span class="hljs-number">6</span>;<br>     <span class="hljs-number">7</span>,<span class="hljs-number">9</span>,<span class="hljs-number">8</span>,<span class="hljs-number">6</span>;<br>     <span class="hljs-number">7</span>,<span class="hljs-number">10</span>,<span class="hljs-number">8</span>,<span class="hljs-number">6</span>];<br> res_x = <span class="hljs-number">0</span>;<br> res = <span class="hljs-number">0</span>;<br> <span class="hljs-keyword">for</span> k = <span class="hljs-number">1</span>:n<br>     flag = <span class="hljs-number">1</span>;<br>     x = randi([<span class="hljs-number">1</span>,<span class="hljs-number">4</span>],<span class="hljs-number">1</span>,<span class="hljs-number">6</span>); <span class="hljs-comment">%生成一个1*6的向量，元素为1-4的整数，表示该设备分配给了哪个企业</span><br>     <span class="hljs-keyword">for</span> <span class="hljs-built_in">j</span> = <span class="hljs-number">1</span> : <span class="hljs-number">4</span> <span class="hljs-comment">%检查每个企业至少分配一台</span><br>         <br>         <span class="hljs-keyword">if</span>(<span class="hljs-built_in">ismember</span>(<span class="hljs-built_in">j</span>,x) == <span class="hljs-number">0</span>)<br>             flag = <span class="hljs-number">0</span>;<br>             <span class="hljs-keyword">break</span>;<br>         <span class="hljs-keyword">end</span><br>     <span class="hljs-keyword">end</span><br>     <br>     <span class="hljs-keyword">if</span>(flag == <span class="hljs-number">1</span>)<br>         sum = <span class="hljs-number">0</span>;<br>         <span class="hljs-keyword">for</span> <span class="hljs-built_in">j</span> = <span class="hljs-number">1</span> : <span class="hljs-number">6</span><br>             sum = sum + C(<span class="hljs-built_in">j</span>, x(<span class="hljs-built_in">j</span>));<br>         <span class="hljs-keyword">end</span><br>         <br>         <span class="hljs-keyword">if</span>(sum &gt; res)<br>             res = sum;<br>             res_x = x;<br>         <span class="hljs-keyword">end</span><br>     <span class="hljs-keyword">end</span><br> <span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><h1 id="非线性规划"><a href="#非线性规划" class="headerlink" title="非线性规划"></a>非线性规划</h1><p>利用matlab求解器求解，关键是合理建模，找好非线性约束。比如著名的飞机调度问题。</p><p>在约10000米的高空的某边长为160公里的正方形区域内，经常有若干架飞机作水平飞行，区域内每架飞机的位置和速度向量均有计算机记录其数据，以便进行飞行管理。当一架欲进入该区域的飞机到达区域边缘时，记录其数据后，要立即计算并判断是否会与区域内的飞机发生碰撞，如果会碰撞，则应计算如何调整每架（包括新进入的）飞机飞行角度的方向角，以避免碰撞。现假定条件如下：                      </p><ul><li>①不碰撞的标准为任意两架飞机的距离大于8公里          </li><li>②飞机飞行方向角调整的幅度不应该超过30度         </li><li>③所有飞机飞行速度均为每小时800公里              </li><li>④进入该区域的飞机在到达区域边缘时与区域内飞机的距离应在60公里以上               </li><li>⑤最多需考虑6架飞机          </li><li>⑥不必考虑飞机离开此区域后的情况</li></ul><p>请你对这个碰撞的飞行管理问题建立数学模型，列出计算步骤，要求飞机飞行方向角调整的幅度尽量小。并对一下数据进行计算（方向角误差不超过0.01°）                   </p><p><a href="https://imgse.com/i/pkqUqNn"><img src="https://s21.ax1x.com/2024/07/27/pkqUqNn.png" alt="pkqUqNn.png"></a></p><p>这是一个求解$\min\sum_{i&#x3D;1}^6(\Delta\theta_i)^2$的问题，下面写约束条件。<br>任意两架飞机i，j在时间t时刻的距离<br>$$d_{ij}^{(2)}(t)&#x3D;[x_i(t)-x_j(t)]^2+[y_i(t)-y_j(t)]^2$$<br>求导<br>$$\begin{aligned}d_{ij}^{(2)}&amp;’(t)&#x3D;2[x_i(t)-x_j(t)][x_i(t)-x_j(t)]’+2[y_i(t)-y_j(t)][y_i(t)-y_j(t)]’\&amp;&#x3D;2[x_i(t)-x_j(t)][v\cos(\theta_i+\Delta\theta_i)-v\cos(\theta_j+\Delta\theta_j)]+2[y_i(t)-y_j(t)][v\sin(\theta_i+\Delta\theta_i)-v\sin(\theta_j+\Delta\theta_j)]\end{aligned}$$<br>容易看出其二阶导大于等于0，一阶导等于0求出极值点$t_0$因此只需要保证在极值点时刻<br>$$t_0&#x3D;-\frac{(x_i^0-x_j^0)\left(\cos(\theta_i+\Delta\theta_i)-\cos(\theta_j+\Delta\theta_j)\right)+(y_i^0-y_j^0)\left(\sin(\theta_i+\Delta\theta_i)-\sin(\theta_j+\Delta\theta_j)\right)}{v[\left(\cos(\theta_i+\Delta\theta_i)-\cos(\theta_j+\Delta\theta_j)\right)^2+(\sin(\theta_i+\Delta\theta_i)-\sin(\theta_j+\Delta\theta_j))^2]}$$<br>满足<br>$$d_{ij}^{(2)}(t_0)&gt;64$$<br>飞机就是安全的</p><p>另外两个约束条件分别是<br>$$\mid\Delta\theta_i\mid&lt;\frac\pi6$$<br>与<br>$$\sqrt{\left(x_i(T_i)-x_j(t)\right)^2+\left(y_i(T_i)-y_j(t)\right)^2}&gt;60(i\neq j)$$</p>]]></content>
    
    
    <categories>
      
      <category>数学建模</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>时间序列</title>
    <link href="/2025/03/21/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1/%E6%97%B6%E9%97%B4%E5%BA%8F%E5%88%97/"/>
    <url>/2025/03/21/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1/%E6%97%B6%E9%97%B4%E5%BA%8F%E5%88%97/</url>
    
    <content type="html"><![CDATA[<h1 id="ARIMA模型"><a href="#ARIMA模型" class="headerlink" title="ARIMA模型"></a>ARIMA模型</h1><h2 id="AR模型（自回归）"><a href="#AR模型（自回归）" class="headerlink" title="AR模型（自回归）"></a>AR模型（自回归）</h2><p>简单来说，就是利用过去最近的时刻p个时刻的标签来对需要预测的时刻进行线性回归</p><p>$$Y_t&#x3D;c+\varphi_1Y_{t-1}+\varphi_2Y_{t-2}+\ldots+\varphi_pY_{t-p}+\xi_t$$</p><p>其中$\xi_{t}$表示噪声 ，$p$为模型的可调参数              </p><p>对于模型的设立，有两点基本假设</p><ul><li>时序依赖性：假设不同时间点的标签值之间存在强相关性。</li><li>时序衰减：两个时间点之间的距离越远，他们之间的关联性越弱。例如，昨天的天气可能对今天的天气影响很大，但三个月前的某一天的天气，对今天的天气的影响就相对微弱。</li></ul><p>AR( p )模型模型在时间区间[0,t]上进行训练，在时间区间[t+1,t+m]上进行预测     </p><h4 id="train"><a href="#train" class="headerlink" title="train"></a>train</h4><p>$$<br>\begin{aligned}<br>&amp;Y_{1}&#x3D;c+\varphi_1Y_0\<br>&amp;Y_{2}&#x3D;c+\varphi_1Y_1+\varphi_2Y_0\<br>&amp;Y_{3}&#x3D;c+\varphi_1Y_2+\varphi_2Y_1+\varphi_3Y_0\<br>&amp;Y_{t}&#x3D;c+\varphi_1Y_{t-1}+\varphi_2Y_{t-2}+\ldots+\varphi_pY_{t-p}<br>\end{aligned}<br>$$</p><h4 id="predict"><a href="#predict" class="headerlink" title="predict"></a>predict</h4><p>$$\begin{aligned}&amp;\hat{Y}<em>{t+1}&#x3D;c+\varphi_1Y_t+\varphi_2Y</em>{t-1}+\ldots+\varphi_pY_{t-p+1}\&amp;\hat{Y}<em>{t+2}&#x3D;c+\varphi_1\hat{Y}</em>{t+1}+\varphi_2Y_t+\ldots+\varphi_pY_{t-p+2}\&amp;\hat{Y}<em>{t+3}&#x3D;c+\varphi_1\hat{Y}</em>{t+2}+\varphi_2\hat{Y}<em>{t+1}+\ldots+\varphi_pY</em>{t-p+3}\&amp;\hat{Y}<em>{t+m}&#x3D;c+\varphi</em>{1}\hat{Y}<em>{t+m-1}+\varphi</em>{2}\hat{Y}<em>{t+m-2}+\ldots+\varphi</em>{p}\hat{Y}_{t+m-p}\end{aligned}$$</p><h2 id="MA模型（移动平均）"><a href="#MA模型（移动平均）" class="headerlink" title="MA模型（移动平均）"></a>MA模型（移动平均）</h2><p>MA模型的基本思想和基本假设与AR模型大不相同。MA模型的基本思想是：大部分时候时间序列应当是相对稳定的。在稳定的基础上，每个时间点上的标签值受过去一段时间内、不可预料的各种偶然事件影响而波动。即在一段时间内，时间序列应该是围绕着某个均值上下波动的序列，时间点上的标签值会围绕着某个均值移动，因此模型才被称为“移动平均模型 Moving Average Model”</p><p>给定噪声序列$\epsilon_{t}$MA模型定义为：<br>$$Y_t&#x3D;\mu+\epsilon_t+\theta_1\epsilon_{t-1}+\theta_2\epsilon_{t-2}+\cdots+\theta_q\epsilon_{t-q}$$</p><p>模型基于三点基本假设</p><ul><li>均值稳定：时间序列应该是围绕着某个均值上下波动的序列</li><li>方差稳定</li><li>无自相关性：不同时间点的观察值之间没有自相关性</li></ul><h2 id="ARIMA模型-1"><a href="#ARIMA模型-1" class="headerlink" title="ARIMA模型"></a>ARIMA模型</h2><ul><li><p>AR模型，即自回归模型，其优势是对于具有较长历史趋势的数据，AR模型可以捕获这些趋势，并据此进行预测。但是AR模型不能很好地处理某些类型的时间序列数据，例如那些有临时、突发的变化或者噪声较大的数据。AR模型相信“历史决定未来”，因此很大程度上忽略了现实情况的复杂性、也忽略了真正影响标签的因子带来的不可预料的影响。</p></li><li><p>相反地，MA模型，即移动平均模型，可以更好地处理那些有临时、突发的变化或者噪声较大的时间序列数据。但是对于具有较长历史趋势的数据，MA模型可能无法像AR模型那样捕捉到这些趋势。MA模型相信“时间序列是相对稳定的，时间序列的波动是由偶然因素影响决定的”，但现实中的时间序列很难一直维持“稳定”这一假设。</p></li></ul><p>基于以上两个模型的优缺点，我们引入了ARIMA模型，这是一种结合了AR模型和MA模型优点的模型，可以处理更复杂的时间序列问题。ARIMA模型主要由三部分构成，分别为自回归模型（AR）、差分过程（I）和移动平均模型（MA）           </p><ul><li>ARIMA模型的基本思想是利用数据本身的历史信息来预测未来。一个时间点上的标签值既受过去一段时间内的标签值影响，也受过去一段时间内的偶然事件的影响，这就是说，ARIMA模型假设：标签值是围绕着时间的大趋势而波动的，其中趋势是受历史标签影响构成的，波动是受一段时间内的偶然事件影响构成的，且大趋势本身不一定是稳定的</li></ul><p>暂时不考虑差分（即假设d&#x3D;0），那么ARIMA模型可以被看作是AR模型和MA模型的直接结合，也也就是利用AR模型对MA模型的$\mu$建模，形式上看，ARIMA模型的公式可以表示为：<br>$$Y_t&#x3D;c+\varphi_1Y_{t-1}+\varphi_2Y_{t-2}+\ldots+\varphi_pY_{t-p}+\theta_1\epsilon_{t-1}+\theta_2\epsilon_{t-2}+\ldots+\theta_q\epsilon_{t-q}+\epsilon_t$$</p><p>如果考虑差分，那么完整的ARIMA表示为：<br>$$\Delta^dY_t&#x3D;\phi_1Y_{t-1}+\phi_2Y_{t-2}+\cdots+\phi_pY_{t-p}+\epsilon_t+\theta_1\epsilon_{t-1}+\theta_2\epsilon_{t-2}+\cdots+\theta_q\epsilon_{t-q}$$</p><ul><li><p>$\Delta^dY_t$表示进行了$d$次差分后的平稳序列；</p></li><li><p>$\phi_1,\phi_2,\ldots,\phi_p$是自回归项的系数；</p></li><li><p>$\theta_1,\theta_2,\ldots,\theta_q$是移动平均项的系数；</p></li><li><p>$\epsilon_t$是随机误差项。</p></li></ul><h3 id="参数选取"><a href="#参数选取" class="headerlink" title="参数选取"></a>参数选取</h3><p><img src="https://img2024.cnblogs.com/blog/2835440/202410/2835440-20241015132419578-739473141.png"></p><p>模型有三个可调参数p,q,d</p><ul><li>p 代表 “自回归部分 (Autoregressive)”： 这部分描述了模型中使用的观测值的滞后值（即前面 p 个期的值）。自回归模型的出发点是认为观测值是它前面的 p 个值的线性组合。</li><li>q 代表 “移动平均部分 (Moving Average)”：这部分描述了模型中使用的错误项的滞后值（即前面 q 个期的值）。移动平均模型是将当前值和过去的白噪声之间建立关系。</li><li>d就是差分的阶数。差分的目标是将非平稳序列转变为平稳序列。</li></ul><h3 id="先确定d"><a href="#先确定d" class="headerlink" title="先确定d"></a>先确定d</h3><p> 确定d值（差分次数）：通过平稳性检验（ADF检验）或观察时间序列的自相关图（ACF图）和偏自相关图（PACF图）来判断。若序列非平稳，则进行差分处理，直至序列平稳。 通常采用ADF检验    </p> <figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">import</span> pandas <span class="hljs-keyword">as</span> pd<br><span class="hljs-keyword">from</span> statsmodels.tsa.stattools <span class="hljs-keyword">import</span> adfuller<br><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">plot_sales</span>(<span class="hljs-params">df, title=<span class="hljs-string">&#x27;Sales Data&#x27;</span></span>):<br>    <span class="hljs-string">&quot;&quot;&quot;辅助函数：绘制时间序列图&quot;&quot;&quot;</span><br>    plt.figure(figsize=(<span class="hljs-number">10</span>, <span class="hljs-number">6</span>))<br>    plt.plot(df.index, df[<span class="hljs-string">&#x27;Sales&#x27;</span>], marker=<span class="hljs-string">&#x27;o&#x27;</span>, label=<span class="hljs-string">&#x27;Sales&#x27;</span>)<br>    plt.title(title)<br>    plt.xlabel(<span class="hljs-string">&#x27;Year&#x27;</span>)<br>    plt.ylabel(<span class="hljs-string">&#x27;Sales&#x27;</span>)<br>    plt.grid(<span class="hljs-literal">True</span>)<br>    plt.legend()<br>    plt.show()<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">adf_test</span>(<span class="hljs-params">series, signif=<span class="hljs-number">0.05</span>, name=<span class="hljs-string">&#x27;&#x27;</span></span>):<br>    <span class="hljs-string">&quot;&quot;&quot;辅助函数：执行ADF单位根检验并打印结果&quot;&quot;&quot;</span><br>    result = adfuller(series.dropna(), autolag=<span class="hljs-string">&#x27;AIC&#x27;</span>)  <span class="hljs-comment"># 使用AIC准则选择滞后长度</span><br>    output = pd.Series(result[<span class="hljs-number">0</span>:<span class="hljs-number">4</span>], index=[<span class="hljs-string">&#x27;Test Statistic&#x27;</span>, <span class="hljs-string">&#x27;p-value&#x27;</span>, <span class="hljs-string">&#x27;Lags Used&#x27;</span>, <span class="hljs-string">&#x27;Number of Observations&#x27;</span>])<br>    <span class="hljs-keyword">for</span> key, value <span class="hljs-keyword">in</span> result[<span class="hljs-number">4</span>].items():<br>        output[<span class="hljs-string">f&#x27;Critical Value (<span class="hljs-subst">&#123;key&#125;</span>)&#x27;</span>] = value<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;\nADF Test Result (<span class="hljs-subst">&#123;name&#125;</span>):&#x27;</span>)<br>    <span class="hljs-built_in">print</span>(output.to_string())<br>    <br>    p_value = result[<span class="hljs-number">1</span>]<br>    <span class="hljs-keyword">if</span> p_value &lt;= signif:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot; =&gt; Null Hypothesis REJECTED - Data <span class="hljs-subst">&#123;name&#125;</span> has no unit root and is stationary.&quot;</span>)<br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot; =&gt; Null Hypothesis ACCEPTED - Data <span class="hljs-subst">&#123;name&#125;</span> has a unit root and is non-stationary.&quot;</span>)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">find_optimal_differences</span>(<span class="hljs-params">series, max_d=<span class="hljs-number">2</span>, plot=<span class="hljs-literal">True</span></span>):<br>    <span class="hljs-string">&quot;&quot;&quot;确定最佳差分阶数d&quot;&quot;&quot;</span><br>    original_series = series.copy()<br>    <span class="hljs-keyword">for</span> d <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(max_d + <span class="hljs-number">1</span>):<br>        <span class="hljs-keyword">if</span> d &gt; <span class="hljs-number">0</span>:<br>            series = series.diff().dropna()<br>            <span class="hljs-keyword">if</span> plot:<br>                plot_sales(pd.DataFrame(&#123;<span class="hljs-string">&#x27;Sales&#x27;</span>: series&#125;), <span class="hljs-string">f&#x27;Differenced Time Series (Order <span class="hljs-subst">&#123;d&#125;</span>)&#x27;</span>)<br>        <br>        adf_test(series, name=<span class="hljs-string">f&#x27;after <span class="hljs-subst">&#123;d&#125;</span> difference(s)&#x27;</span>)<br>        <br>        <span class="hljs-comment"># 检查是否已经达到了平稳性</span><br>        <span class="hljs-keyword">if</span> adfuller(series)[<span class="hljs-number">1</span>] &lt;= <span class="hljs-number">0.05</span>:<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;\nThe optimal differencing order is <span class="hljs-subst">&#123;d&#125;</span>.&quot;</span>)<br>            <span class="hljs-keyword">break</span><br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;\nCould not achieve stationarity within <span class="hljs-subst">&#123;max_d&#125;</span> differences.&quot;</span>)<br>    <br>    <span class="hljs-keyword">return</span> d, series<br><br><span class="hljs-comment"># 创建年度销量数据并转换为DataFrame</span><br>data = &#123;<br>    <span class="hljs-string">&#x27;Year&#x27;</span>: <span class="hljs-built_in">list</span>(<span class="hljs-built_in">range</span>(<span class="hljs-number">1985</span>, <span class="hljs-number">2022</span>)),<br>    <span class="hljs-string">&#x27;Sales&#x27;</span>: [<br>        <span class="hljs-number">100</span>, <span class="hljs-number">101.6</span>, <span class="hljs-number">103.3</span>, <span class="hljs-number">111.5</span>, <span class="hljs-number">116.5</span>, <span class="hljs-number">120.1</span>, <span class="hljs-number">120.3</span>, <span class="hljs-number">100.6</span>, <span class="hljs-number">83.6</span>, <span class="hljs-number">84.7</span>,<br>        <span class="hljs-number">88.7</span>, <span class="hljs-number">98.9</span>, <span class="hljs-number">111.9</span>, <span class="hljs-number">122.9</span>, <span class="hljs-number">131.9</span>, <span class="hljs-number">134.2</span>, <span class="hljs-number">131.6</span>, <span class="hljs-number">132.2</span>, <span class="hljs-number">139.8</span>, <span class="hljs-number">142</span>,<br>        <span class="hljs-number">140.5</span>, <span class="hljs-number">153.1</span>, <span class="hljs-number">159.2</span>, <span class="hljs-number">162.3</span>, <span class="hljs-number">159.1</span>, <span class="hljs-number">155.1</span>, <span class="hljs-number">161.2</span>, <span class="hljs-number">171.5</span>, <span class="hljs-number">168.4</span>, <span class="hljs-number">180.4</span>,<br>        <span class="hljs-number">201.6</span>, <span class="hljs-number">218.7</span>, <span class="hljs-number">247</span>, <span class="hljs-number">253.7</span>, <span class="hljs-number">261.4</span>, <span class="hljs-number">273.2</span>, <span class="hljs-number">279.4</span><br>    ]<br>&#125;<br>df = pd.DataFrame(data).set_index(<span class="hljs-string">&#x27;Year&#x27;</span>)<br><br><span class="hljs-comment"># 绘制原始时间序列图</span><br>plot_sales(df, <span class="hljs-string">&#x27;Original Time Series&#x27;</span>)<br><br><span class="hljs-comment"># 查找最优差分阶数</span><br>optimal_d, final_series = find_optimal_differences(df[<span class="hljs-string">&#x27;Sales&#x27;</span>], max_d=<span class="hljs-number">2</span>)<br><br><span class="hljs-comment"># 如果需要可以在这里继续使用final_series进行进一步分析...</span><br> ```    <br><br><span class="hljs-comment">### 确定q,p</span><br><br>一种方法是使用拖尾，截尾法，但是主观性强，通常使用AIC和BIC网格搜索.<br>```py<br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">import</span> pandas <span class="hljs-keyword">as</span> pd<br><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br><span class="hljs-keyword">from</span> mpl_toolkits.mplot3d <span class="hljs-keyword">import</span> Axes3D<br><span class="hljs-keyword">from</span> statsmodels.tsa.arima.model <span class="hljs-keyword">import</span> ARIMA<br><span class="hljs-keyword">from</span> tqdm <span class="hljs-keyword">import</span> tqdm<br><span class="hljs-keyword">import</span> warnings<br><br><br><span class="hljs-comment"># 忽略警告信息</span><br>warnings.filterwarnings(<span class="hljs-string">&quot;ignore&quot;</span>)<br><br><br><span class="hljs-comment"># 创建年度销量数据</span><br>data = &#123;<br>    <span class="hljs-string">&#x27;Year&#x27;</span>: [<br>        <span class="hljs-number">1985</span>, <span class="hljs-number">1986</span>, <span class="hljs-number">1987</span>, <span class="hljs-number">1988</span>, <span class="hljs-number">1989</span>, <span class="hljs-number">1990</span>, <span class="hljs-number">1991</span>, <span class="hljs-number">1992</span>, <span class="hljs-number">1993</span>, <span class="hljs-number">1994</span>, <br>        <span class="hljs-number">1995</span>, <span class="hljs-number">1996</span>, <span class="hljs-number">1997</span>, <span class="hljs-number">1998</span>, <span class="hljs-number">1999</span>, <span class="hljs-number">2000</span>, <span class="hljs-number">2001</span>, <span class="hljs-number">2002</span>, <span class="hljs-number">2003</span>, <span class="hljs-number">2004</span>,<br>        <span class="hljs-number">2005</span>, <span class="hljs-number">2006</span>, <span class="hljs-number">2007</span>, <span class="hljs-number">2008</span>, <span class="hljs-number">2009</span>, <span class="hljs-number">2010</span>, <span class="hljs-number">2011</span>, <span class="hljs-number">2012</span>, <span class="hljs-number">2013</span>, <span class="hljs-number">2014</span>, <br>        <span class="hljs-number">2015</span>, <span class="hljs-number">2016</span>, <span class="hljs-number">2017</span>, <span class="hljs-number">2018</span>, <span class="hljs-number">2019</span>, <span class="hljs-number">2020</span>, <span class="hljs-number">2021</span><br>    ],<br>    <span class="hljs-string">&#x27;Sales&#x27;</span>: [<br>        <span class="hljs-number">100</span>, <span class="hljs-number">101.6</span>, <span class="hljs-number">103.3</span>, <span class="hljs-number">111.5</span>, <span class="hljs-number">116.5</span>, <span class="hljs-number">120.1</span>, <span class="hljs-number">120.3</span>, <span class="hljs-number">100.6</span>, <span class="hljs-number">83.6</span>, <span class="hljs-number">84.7</span>, <br>        <span class="hljs-number">88.7</span>, <span class="hljs-number">98.9</span>, <span class="hljs-number">111.9</span>, <span class="hljs-number">122.9</span>, <span class="hljs-number">131.9</span>, <span class="hljs-number">134.2</span>, <span class="hljs-number">131.6</span>, <span class="hljs-number">132.2</span>, <span class="hljs-number">139.8</span>, <span class="hljs-number">142</span>,<br>        <span class="hljs-number">140.5</span>, <span class="hljs-number">153.1</span>, <span class="hljs-number">159.2</span>, <span class="hljs-number">162.3</span>, <span class="hljs-number">159.1</span>, <span class="hljs-number">155.1</span>, <span class="hljs-number">161.2</span>, <span class="hljs-number">171.5</span>, <span class="hljs-number">168.4</span>, <span class="hljs-number">180.4</span>,<br>        <span class="hljs-number">201.6</span>, <span class="hljs-number">218.7</span>, <span class="hljs-number">247</span>, <span class="hljs-number">253.7</span>, <span class="hljs-number">261.4</span>, <span class="hljs-number">273.2</span>, <span class="hljs-number">279.4</span><br>    ]<br>&#125;<br><br><br><span class="hljs-comment"># 将数据转化为Pandas DataFrame</span><br>df = pd.DataFrame(data)<br>df.set_index(<span class="hljs-string">&#x27;Year&#x27;</span>, inplace=<span class="hljs-literal">True</span>)<br><br><br><span class="hljs-comment"># 定义差分阶数 d</span><br>d = <span class="hljs-number">1</span>  <span class="hljs-comment"># 根据ADF准则求出的最佳差分阶数  </span><br><br><br><span class="hljs-comment"># 对数据进行 d 阶差分操作</span><br>df_diff = df[<span class="hljs-string">&#x27;Sales&#x27;</span>]<br><span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(d):<br>    df_diff = df_diff.diff().dropna()<br><br><br><span class="hljs-comment"># 准备存储AIC和BIC值</span><br>aic_values = []<br>bic_values = []<br>p_values = <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>,<span class="hljs-number">7</span>)  <span class="hljs-comment"># 选择不同的AR阶数</span><br>q_values = <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>,<span class="hljs-number">7</span>)  <span class="hljs-comment"># 选择不同的MA阶数</span><br><br><br><span class="hljs-comment"># 存储AIC和BIC值的矩阵</span><br>aic_matrix = np.zeros((<span class="hljs-built_in">len</span>(p_values), <span class="hljs-built_in">len</span>(q_values)))<br>bic_matrix = np.zeros((<span class="hljs-built_in">len</span>(p_values), <span class="hljs-built_in">len</span>(q_values)))<br><br><br><span class="hljs-comment"># 遍历不同的AR和MA阶数，拟合ARIMA模型并记录AIC和BIC值</span><br><span class="hljs-keyword">with</span> tqdm(total=<span class="hljs-built_in">len</span>(p_values) * <span class="hljs-built_in">len</span>(q_values)) <span class="hljs-keyword">as</span> pbar:<br>    <span class="hljs-keyword">for</span> i, p <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(p_values):<br>        <span class="hljs-keyword">for</span> j, q <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(q_values):<br>            <span class="hljs-keyword">try</span>:<br>                model = ARIMA(df_diff, order=(p, <span class="hljs-number">1</span>, q))  <span class="hljs-comment"># 这里d=1代表差分</span><br>                results = model.fit()<br>                aic_matrix[i, j] = results.aic<br>                bic_matrix[i, j] = results.bic<br>                aic_values.append((p, q, results.aic))<br>                bic_values.append((p, q, results.bic))<br>            <span class="hljs-keyword">except</span>:<br>                <span class="hljs-keyword">pass</span><br>            pbar.update(<span class="hljs-number">1</span>)<br><br><br><span class="hljs-comment"># 找到AIC最小值对应的(p, q)</span><br>aic_min_index = np.argmin(np.array(aic_values)[:, <span class="hljs-number">2</span>])<br>p_aic_min, q_aic_min, aic_min_value = np.array(aic_values)[aic_min_index]<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;Optimal ARIMA order (p, q) using AIC: (<span class="hljs-subst">&#123;p_aic_min&#125;</span>, 1, <span class="hljs-subst">&#123;q_aic_min&#125;</span>)&quot;</span>)<br><br><br><span class="hljs-comment"># 找到BIC最小值对应的(p, q)</span><br>bic_min_index = np.argmin(np.array(bic_values)[:, <span class="hljs-number">2</span>])<br>p_bic_min, q_bic_min, bic_min_value = np.array(bic_values)[bic_min_index]<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;Optimal ARIMA order (p, q) using BIC: (<span class="hljs-subst">&#123;p_bic_min&#125;</span>, 1, <span class="hljs-subst">&#123;q_bic_min&#125;</span>)&quot;</span>)<br><br><span class="hljs-comment"># 创建一个新的图形，设置为3D</span><br>fig = plt.figure(figsize=(<span class="hljs-number">15</span>, <span class="hljs-number">7</span>))<br><br><br><span class="hljs-comment"># 绘制AIC的3D图</span><br>ax1 = fig.add_subplot(<span class="hljs-number">121</span>, projection=<span class="hljs-string">&#x27;3d&#x27;</span>)<br>p_grid, q_grid = np.meshgrid(p_values, q_values)<br>surf_aic = ax1.plot_surface(p_grid, q_grid, aic_matrix, cmap=<span class="hljs-string">&#x27;viridis&#x27;</span>)<br>ax1.set_title(<span class="hljs-string">&#x27;AIC Criterion for ARIMA(p, d=1, q)&#x27;</span>)<br>ax1.set_xlabel(<span class="hljs-string">&#x27;AR order (p)&#x27;</span>)<br>ax1.set_ylabel(<span class="hljs-string">&#x27;MA order (q)&#x27;</span>)<br>ax1.set_zlabel(<span class="hljs-string">&#x27;AIC Value&#x27;</span>)<br>fig.colorbar(surf_aic, ax=ax1, label=<span class="hljs-string">&#x27;AIC Value&#x27;</span>)<br><br><br><span class="hljs-comment"># 绘制BIC的3D图</span><br>ax2 = fig.add_subplot(<span class="hljs-number">122</span>, projection=<span class="hljs-string">&#x27;3d&#x27;</span>)<br>surf_bic = ax2.plot_surface(p_grid, q_grid, bic_matrix, cmap=<span class="hljs-string">&#x27;plasma&#x27;</span>)<br>ax2.set_title(<span class="hljs-string">&#x27;BIC Criterion for ARIMA(p, d=1, q)&#x27;</span>)<br>ax2.set_xlabel(<span class="hljs-string">&#x27;AR order (p)&#x27;</span>)<br>ax2.set_ylabel(<span class="hljs-string">&#x27;MA order (q)&#x27;</span>)<br>ax2.set_zlabel(<span class="hljs-string">&#x27;BIC Value&#x27;</span>)<br>fig.colorbar(surf_bic, ax=ax2, label=<span class="hljs-string">&#x27;BIC Value&#x27;</span>)<br><br><br>plt.tight_layout()<br>plt.show()<br><br></code></pre></td></tr></table></figure><h2 id="最后进行预测即可"><a href="#最后进行预测即可" class="headerlink" title="最后进行预测即可"></a>最后进行预测即可</h2>]]></content>
    
    
    <categories>
      
      <category>数学建模</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>TOPSIS模版/灰色关联度分析</title>
    <link href="/2025/03/21/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1/TOPSIS/"/>
    <url>/2025/03/21/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1/TOPSIS/</url>
    
    <content type="html"><![CDATA[<h1 id="step1-评价矩阵标准化-归一化"><a href="#step1-评价矩阵标准化-归一化" class="headerlink" title="step1 评价矩阵标准化+归一化"></a>step1 评价矩阵标准化+归一化</h1><p>已有正向化处理之后的矩阵<br> $\begin{aligned}&amp; X&#x3D;\begin{bmatrix}x_{11}&amp;x_{12}&amp;\cdots&amp;x_{1m}\x_{21}&amp;x_{22}&amp;\cdots&amp;x_{2m}\\varvdots&amp;\varvdots&amp;\ddots&amp;\varvdots\x_{21}&amp;\cdots&amp;x_{2m}\end{bmatrix}\end{aligned}$</p><p>设标准化的矩阵为$Z$,那么$Z$中的每一个元素：$\tilde{z}<em>{ij}&#x3D;\frac{x</em>{ij}}{\sqrt{\sum_{i&#x3D;1}^nx_{ij}^2}}$</p><p>得到标准化矩阵<br>$$\tilde{Z}&#x3D;\begin{bmatrix}\tilde{z}<em>{11}&amp;\tilde{z}</em>{12}&amp;\cdots&amp;\tilde{z}<em>{1m}\\tilde{z}</em>{21}&amp;\tilde{z}<em>{22}&amp;\cdots&amp;\tilde{z}</em>{2m}\\vdots&amp;\vdots&amp;\ddots&amp;\vdots\\tilde{z}<em>{n1}&amp;\tilde{z}</em>{n2}&amp;\cdots&amp;\tilde{z}_{nm}\end{bmatrix}$$</p><p>标准化之后记得<br>$$\frac{x-\min}{\max-\min}$$<br>进行归一化</p><h1 id="step2-用优劣解打分"><a href="#step2-用优劣解打分" class="headerlink" title="step2 用优劣解打分"></a>step2 用优劣解打分</h1><p>上一步得到了矩阵<br>$$Z&#x3D;\begin{bmatrix}z_{11}&amp;z_{12}&amp;\cdots&amp;z_{1m}\z_{21}&amp;z_{22}&amp;\cdots&amp;z_{2m}\\varvdots&amp;\varvdots&amp;\ddots&amp;\varvdots\z_{n1}&amp;z_{n2}&amp;\cdots&amp;z_{nm}\end{bmatrix}$$</p><p>寻找每一个评价指标中出现的最大值与最小值，写成向量的形式，也就是</p><p>$$Z^+&#x3D;(Z_1^+,Z_2^+,\cdotp\cdotp\cdotp,Z_m^+)&#x3D;(\max{z_{11},z_{21},\cdotp\cdotp\cdotp,z_{n1}},\max{z_{12},z_{22},\cdotp\cdotp\cdotp,z_{n2}},\cdotp\cdotp\cdotp,\max{z_{1m},z_{2m},\cdotp\cdotp\cdotp,z_{nm}})\Z^-&#x3D;(Z_1^-,Z_2^-,\cdotp\cdotp\cdotp,Z_m^-)&#x3D;(\min\left{z_{11},z_{21},\cdotp\cdotp\cdotp,z_{n1}\right},\min\left{z_{12},z_{22},\cdotp\cdotp\cdotp,z_{n2}\right},\cdotp\cdotp\cdotp,\min\left{z_{1m},z_{2m},\cdotp\cdotp\cdotp,z_{nm}\right})$$</p><p>遍历每一个评价对象，计算它每个指标相对于所有对象中该指标最大值的距离，$D_i^+&#x3D;\sqrt{\sum_{j&#x3D;1}^m(Z_j^+-z_{ij})^2}(i&#x3D;1,2,…,n)$，</p><p>同样的计算与最小值的距离$D_i^-&#x3D;\sqrt{\sum_{j&#x3D;1}^m\left(Z_j^–z_{ij}\right)^2}$，</p><p>然后取$S_i&#x3D;\frac{D_i^-}{D_i^++D_i^-}$作为该对象得分。</p><h1 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h1><p><img src="https://pic.imge.cc/2024/07/27/66a498d945fc0.png" alt="1722063061332.png"></p><h1 id="灰色关联度分析"><a href="#灰色关联度分析" class="headerlink" title="灰色关联度分析"></a>灰色关联度分析</h1><h1 id="step1确定评价序列"><a href="#step1确定评价序列" class="headerlink" title="step1确定评价序列"></a>step1确定评价序列</h1><ul><li>参考数列(母序列):能反映系统行为特征的数据序列.记作$x_0$                       </li><li>比较数列：子序列影响系统行为的因素组成的数据序列.记作$x_i\left(i&#x3D;1,2,…,n\right)$</li></ul><p>例如结婚率就是参考数列，房价、人均收入、女性失业数就是比较数列.</p><p>可以这样理解，参考数列就类似于因变量$y$,比较数列是自变量$x.$</p><h1 id="step2数据预处理-归一化或标准化"><a href="#step2数据预处理-归一化或标准化" class="headerlink" title="step2数据预处理&#x2F;归一化或标准化"></a>step2数据预处理&#x2F;归一化或标准化</h1><p>比如都除以平均值，或者采用之前定义的标准化方法。</p><h1 id="step3确定灰色关联系数"><a href="#step3确定灰色关联系数" class="headerlink" title="step3确定灰色关联系数"></a>step3确定灰色关联系数</h1><p>$\text{定义两级最小差}a&#x3D;\min_s\min_t|x_0(t)-x_s(t)|,\text{两级最大差}b&#x3D;\max_s\max_t|x_0(t)-x_s(t)|.$</p><p>其实就是计算一整个表格与某一个标准序列的的差，然后取最大与最小</p><p>对表中每一个元素求<br>$$\gamma(x_0(k),x_i(k))&#x3D;\frac{a+\rho b}{|x_0(k)-x_i(k)|+\rho b}$$<br>各个指标取平均值就得到灰色关联度<br>$$\gamma(x_0,x_i)&#x3D;\frac1n\sum_{k&#x3D;1}^n\gamma(x_0(k),x_i(k))$$</p>]]></content>
    
    
    <categories>
      
      <category>数学建模</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>51单片机（三）</title>
    <link href="/2025/03/21/EE/51%E5%8D%95%E7%89%87%E6%9C%BA%EF%BC%88%E4%B8%89%EF%BC%89/"/>
    <url>/2025/03/21/EE/51%E5%8D%95%E7%89%87%E6%9C%BA%EF%BC%88%E4%B8%89%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h2 id="8-串口通信"><a href="#8-串口通信" class="headerlink" title="8 串口通信"></a>8 串口通信</h2><h3 id="通信的基本概念"><a href="#通信的基本概念" class="headerlink" title="通信的基本概念"></a>通信的基本概念</h3><p><strong>串行通信</strong> 使用一条数据线，将数据一位一位地依次传输，每一位数据占<br>据一个固定的时间长度。其只需要少数几条线就可以在系统间交换信息，特别适<br>用于计算机与计算机、计算机与外设之间的远距离通信。<br><strong>并行通信</strong> 将数据字节的各位用多条数据线同时进行传送，通常是 8<br>位、16 位、32 位等数据一起传输。控制简单、传输速度快；由于传输线较多，长距离传送时成本高且接收方的各位同时接收存在困难，抗干扰能力差。<br><strong>异步通信</strong> 异步通信是指通信的发送与接收设备使用各自的时钟控制数据的发送和接<br>收过程。为使双方的收发协调，要求发送和接收设备的时钟尽可能一致。<br>异步通信是以字符（构成的帧）为单位进行传输，字符与字符之间的间隙（时<br>间间隔）是任意的，但每个字符中的各位是以固定的时间传送的，即字符之间不<br>一定有“位间隔”的整数倍的关系，但同一字符内的各位之间的距离均为“ 位<br>间隔”的整数倍。如下图所示：<br><img src="https://picst.sunbangyan.cn/2024/02/01/0c54c179b959c354a1f7ad4b0aae6ae8.jpeg">      </p><p><strong>同步通信</strong> 同步通信时要建立发送方时钟对接收方时钟的直接控制，使双方达到完全同<br>步。此时，传输数据的位之间的距离均为“位间隔”的整数倍，同时传送的字符<br>间不留间隙，即保持位同步关系，也保持字符同步关系。发送方对接收方的同步<br>可以通过两种方法实现。<br><img src="https://picdm.sunbangyan.cn/2024/02/01/cf1a5919bea388120ab120ee50efb104.jpeg"><br><strong>单工通信</strong><br>单工是指数据传输仅能沿一个方向，不能实现反向传输。<br><strong>半双工通信</strong> 数据传输可以沿两个方向，但需要分时进行。（共用一根线）<br><strong>双工通信</strong> 数据可以同时进行双向传输。</p><h3 id="通信速率"><a href="#通信速率" class="headerlink" title="通信速率"></a>通信速率</h3><p><strong>比特率</strong>  比特率是每秒钟传输二进制代码的位数，单位是：位／秒（ bps）。如<br>每秒钟传送 240 个字符，而每个字符格式包含 10 位(1 个起始位、1 个停止位、<br>8 个数据位)，这时的比特率为：<br>                    $10 位×240 个&#x2F;秒 &#x3D; 2400 bps$<br><strong>波特率</strong>   它表示每秒钟传输了多少个码元。而<br>码元是通信信号调制的概念，通信中常用时间间隔相同的符号来表示一个二进制<br>数字，这样的信号称为码元。如常见的通信传输中，用 0V 表示数字 0，5V 表<br>示数字 1，那么一个码元可以表示两种状态 0 和 1，所以一个码元等于一个二<br>进制比特位，此时波特率的大小与比特率一致；如果在通信传输中，有 0V、2V、<br>4V 以及 6V 分别表示二进制数 00、 01、 10、 11，那么每个码元可以表示四<br>种状态，即两个二进制比特位，所以码元数是二进制比特位数的一半，这个时候<br>的波特率为比特率的一半。由于很多常见的通信中一个码元都是表示两种状态，<br>所以我们常常直接以波特率来表示比特率。         </p><h3 id="相关寄存器"><a href="#相关寄存器" class="headerlink" title="相关寄存器"></a>相关寄存器</h3><p>串口通信的接口标准有很多，常用的是 RS-232 和 RS-485，下面是相关的寄存器。<br>串口控制寄存器SCON<br><img src="https://krseoul.imgtbl.com/i/2024/02/16/65cf20b9908b8.png">           </p>]]></content>
    
    
    <categories>
      
      <category>EE</category>
      
      <category>51单片机</category>
      
    </categories>
    
    
    <tags>
      
      <tag>51单片机</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>高数梳理</title>
    <link href="/2025/03/21/%E6%95%B0%E5%AD%A6/%E9%AB%98%E6%95%B0%E7%AC%94%E8%AE%B0/"/>
    <url>/2025/03/21/%E6%95%B0%E5%AD%A6/%E9%AB%98%E6%95%B0%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<p>2<br><a href="https://www.freeimg.cn/i/2024/06/06/66608ee9e223e.jpg"><img src="https://www.freeimg.cn/i/2024/06/06/66608ee9e223e.jpg" alt="1"></a><br>3<br><a href="https://www.freeimg.cn/i/2024/06/06/66608eea705d2.jpg"><img src="https://www.freeimg.cn/i/2024/06/06/66608eea705d2.jpg" alt="1836d142572eb6f93f48cc9d6973289.jpg"></a><br>4<br><a href="https://www.freeimg.cn/i/2024/06/06/66608eea93f67.jpg"><img src="https://www.freeimg.cn/i/2024/06/06/66608eea93f67.jpg" alt="6c9cf4b1ee3af26709ca0557dcc85ef.jpg"></a></p><p>5<br><a href="https://www.freeimg.cn/i/2024/06/06/66608eea9860b.jpg"><img src="https://www.freeimg.cn/i/2024/06/06/66608eea9860b.jpg" alt="53c308f467bcd4c5e659a60d388add3.jpg"></a></p><p>6<br><a href="https://www.freeimg.cn/i/2024/06/06/66608eea9f75b.jpg"><img src="https://www.freeimg.cn/i/2024/06/06/66608eea9f75b.jpg" alt="e13d54a2a0e1f9d099cea3101a9174a.jpg"></a></p><p>7<br><a href="https://www.freeimg.cn/i/2024/06/06/66608eea94177.jpg"><img src="https://www.freeimg.cn/i/2024/06/06/66608eea94177.jpg" alt="71eec761c59643b40e810d220d983dd.jpg"></a><br>8<br><a href="https://www.freeimg.cn/i/2024/06/06/66608eeacb04f.jpg"><img src="https://www.freeimg.cn/i/2024/06/06/66608eeacb04f.jpg" alt="42fb1f77ab610a81d5e3e4056f4c455.jpg"></a><br>9<br><a href="https://www.freeimg.cn/i/2024/06/06/66608eeb58001.jpg"><img src="https://www.freeimg.cn/i/2024/06/06/66608eeb58001.jpg" alt="4a468a547d2b3f0fa5c3757bfbe4244.jpg"></a></p><p>10<br><a href="https://www.freeimg.cn/i/2024/06/06/66608eec66630.jpg"><img src="https://www.freeimg.cn/i/2024/06/06/66608eec66630.jpg" alt="f9821774194806e45c39a9732642db7.jpg"></a></p><p>11<br><a href="https://www.freeimg.cn/i/2024/06/06/66608eec5f917.jpg"><img src="https://www.freeimg.cn/i/2024/06/06/66608eec5f917.jpg" alt="de3b599548e8ca4dc7c7ed60fcf4f15.jpg"></a></p><p>12<br><a href="https://www.freeimg.cn/i/2024/06/06/66608eec67a6a.jpg"><img src="https://www.freeimg.cn/i/2024/06/06/66608eec67a6a.jpg" alt="cf49990ec82d312662c3104115227cc.jpg"></a></p><p>13<br><a href="https://www.freeimg.cn/i/2024/06/06/66608eec5b8a8.jpg"><img src="https://www.freeimg.cn/i/2024/06/06/66608eec5b8a8.jpg" alt="2213487e5c821da6744d2d85dbebea5.jpg"></a></p><p>14<br><a href="https://www.freeimg.cn/i/2024/06/06/66608eec4dfff.jpg"><img src="https://www.freeimg.cn/i/2024/06/06/66608eec4dfff.jpg" alt="5c58acbb0eb0c4f3ce7849480d9d7a9.jpg"></a></p>]]></content>
    
    
    <categories>
      
      <category>数学</category>
      
      <category>微积分</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>凸函数</title>
    <link href="/2025/03/21/%E6%95%B0%E5%AD%A6/%E5%87%B8%E4%BC%98%E5%8C%96/%E5%87%B8%E5%87%BD%E6%95%B0/"/>
    <url>/2025/03/21/%E6%95%B0%E5%AD%A6/%E5%87%B8%E4%BC%98%E5%8C%96/%E5%87%B8%E5%87%BD%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="凸函数的四种判别"><a href="#凸函数的四种判别" class="headerlink" title="凸函数的四种判别"></a>凸函数的四种判别</h1><h3 id="第一定义"><a href="#第一定义" class="headerlink" title="第一定义"></a>第一定义</h3><p>$f$是凸函数，当且仅当其定义域为凸集，且</p><p>$$\forall x, y\in S, \forall \theta \in [ 0, 1],f( \theta x+ ( 1- \theta ) y) \leq \theta f( x) + ( 1- \theta ) f( y)$$</p><h3 id="第二定义"><a href="#第二定义" class="headerlink" title="第二定义"></a>第二定义</h3><p>$dom f$ 为凸,且 $\forall x \in dom f, \forall v, g(t) &#x3D; f(x+tv)$ 为凸函数</p><p>几何意义是用一个超平面去截凸函数，截面一定也是凸函数</p><h3 id="一阶条件"><a href="#一阶条件" class="headerlink" title="一阶条件"></a>一阶条件</h3><p>设$f: R^{n}\to R$可微，则$f$为凸函数等价于以下两点同时成立      </p><ul><li>$dom f$为凸集</li><li>$f(y)\geq f(x)+\nabla f^{T}(x)(y-x), \forall x,y\in dom f$</li></ul><p><img src="https://www.freeimg.cn/i/2024/08/30/66d17900db001.png"></p><p><a href="https://zhuanlan.zhihu.com/c_1280779583399882752">证明从略，复习点击此处</a></p><h3 id="二阶条件"><a href="#二阶条件" class="headerlink" title="二阶条件"></a>二阶条件</h3><p>若$f$二阶可微，则$f$为凸函数等价于</p><p>$$\nabla^{2}f(x)\succeq0, \forall x\in dom f$$</p><h3 id="凸函数的扩展"><a href="#凸函数的扩展" class="headerlink" title="凸函数的扩展"></a>凸函数的扩展</h3><p>$f:$ $R^{n}\to R$为凸函数，dom $f:$ $C\subseteq R^{n}$</p><p>$\tilde{f} &#x3D; \begin{cases} f( x) :&amp; x\in dom:f\ \infty :&amp; x\notin dom:f&amp; \end{cases}$, $\tilde{f} :$ $R^n\to R$, dom $\tilde{f} :$ $R$,即将 f 的定义域由 C 扩展到 R，此函数依然为凸函数</p><h1 id="常见凸函数与凹函数"><a href="#常见凸函数与凹函数" class="headerlink" title="常见凸函数与凹函数"></a>常见凸函数与凹函数</h1><h3 id="仿射函数"><a href="#仿射函数" class="headerlink" title="仿射函数"></a>仿射函数</h3><p>$f(x)&#x3D;Ax+b$,显然$\nabla^2f(x)&#x3D;0$,因此仿射函数非凸非凹</p><h3 id="指数函数"><a href="#指数函数" class="headerlink" title="指数函数"></a>指数函数</h3><p>$f(x)&#x3D;e^{ax}, x\in R, \nabla^{2}f(x)&#x3D;a^{2}e^{ax}\geq0$，凸函数</p><h3 id="幂函数"><a href="#幂函数" class="headerlink" title="幂函数"></a>幂函数</h3><p>$f(x)&#x3D;x^{a}, x\in R_{++}$<br>$$\nabla^2f(x)&#x3D;a(a-1)x^{a-2}&#x3D;\begin{cases}\ge0&amp;a\ge1, a\le0&amp;\text{凸}\\\le0&amp;a\in[0,1]&amp;\text{凹}\end{cases}$$</p><h3 id="负熵"><a href="#负熵" class="headerlink" title="负熵"></a>负熵</h3><p>$f(x)&#x3D;xlogx, x\in R_{++}, f’’(x)&#x3D;\frac{1}{x}&gt;0$，凸函数</p><h3 id="范数"><a href="#范数" class="headerlink" title="范数"></a>范数</h3><p>函数$P(x)$要想能称为范数，等价于满足以下三个条件</p><ul><li>$P(ax)&#x3D;|a|P(x)$</li><li>$P(x+y)\leq P(x)+P(y)$</li><li>$P(x)&#x3D;0\Leftrightarrow x&#x3D;0$<br>由第二条性质可以容易的证明范数是凸函数</li></ul><h3 id="极大值函数"><a href="#极大值函数" class="headerlink" title="极大值函数"></a>极大值函数</h3><p>$f(x)&#x3D;\max{x_1,\ldots,x_n}, x\in R^n$</p><p>证明:<br>$$\begin{aligned}&amp;\forall x,y\in R^n, \forall\theta\in[0,1]\&amp;f(\theta x+(1-\theta)y)&#x3D;max{\theta x_i+(1-\theta)y_i, i&#x3D;1,\ldots,n}\leq\theta\max{x_i}+(1-\theta)\max{y_i}\end{aligned}$$</p><h3 id="log-aum-up函数"><a href="#log-aum-up函数" class="headerlink" title="log-aum-up函数"></a>log-aum-up函数</h3><p>$f(x)&#x3D;\log(e^{x_1}+\cdots+e^{x_n}),x\in R^n$是凸的<br>由于极大函数往往不可导，log-sum-up函数其实就是对极大函数的解析逼近，<br>$$\max{x_1,\cdots,x_n}\leq f(x)\leq\max{x_1+\cdots+x_n}+\log n$$</p><p>讨论该函数的海森矩阵<br>$$H_{ij}&#x3D;\begin{cases}\frac{\partial^2f}{\partial x_i\partial x_j}&#x3D;\frac{-e^{x_i}e^{x_j}}{(e^{x_1}+\cdots+e^{x_n})^2}&amp;\quad i\neq j\[2ex]\frac{\partial^2f}{\partial x_i\partial x_i}&#x3D;\frac{-e^{x_i}e^{x_i}+e^{x_i}(e^{x_1}+\cdots+e^{x_n})}{(e^{x_1}+\cdots+e^{x_n})^2}&amp;\quad i&#x3D;j\end{cases}$$</p><p>$$\left.H&#x3D;\frac{1}{(e^{x_1}+\cdots+e^{x_n})^2}\left{\left[\begin{array}{ccc}e^{x_1}(e^{x_1}+\cdots+e^{x_n})&amp;\cdots&amp;0\\vdots&amp;\ddots&amp;\vdots\0&amp;\cdots&amp;e^{x_n}(e^{x_1}+\cdots+e^{x_n})\end{array}\right.\right]-\left[\begin{array}{c}e^{x_1}\\vdots\e^{x_n}\end{array}\right]\cdot\left[\begin{array}{ccc}e^{x_1}&amp;\cdots&amp;e^{x_n}\end{array}\right]\right}$$</p><p>令$z&#x3D;[e^{x_{1}},\ldots,e^{x_{n}}]$，则上式可以写为</p><p>$$H&#x3D;\frac{1}{(1\cdot z)^{2}}\left((1^{T}\cdot z) diag{z}-z\cdot z^{T}\right)$$</p><p>欲证明log-sum-up为凸，只需利用二阶条件证明 Hessian 矩阵的半正定性 计算$v^THv$</p><p>$$\begin{aligned}&amp;&#x3D;(1^{T}\cdot z) v^{T}diag{z}v-v^{T}z\cdot z^{T}v\&amp;&#x3D;(\sum_{i}z_{i})(\sum_{i}v_{i}^{2} z_{i})-(\sum_{i}v_{i} z_{i})^{2}\end{aligned}$$</p><p>$$\begin{aligned}&amp;\text{令 }a_i&#x3D;v_i\sqrt{z_i}, b_i&#x3D;\sqrt{z_i}\&amp;&#x3D;(b^Tb)(a^Ta)-(a^Tb)^2\geq0\quad[Cauchy-Schwarz\text{不等式,得证}]\end{aligned}$$</p><h3 id="行列式的对数"><a href="#行列式的对数" class="headerlink" title="行列式的对数"></a>行列式的对数</h3><p>凹函数<br>$f(x)&#x3D;log det(x), dom f &#x3D; S_{++}^{n}$</p><p>我们常使用定义二来证明高维的凸函数情况</p><p>$$\forall z\in S_{++}^{n}, \forall t\in R, \forall v\in R^{n\times n}, z+tv\in S_{++}^{n} &#x3D; dom f$$</p><p>$$\begin{aligned}<br>g(t)&#x3D;f(z+tv)&amp; &#x3D;log det(z+tv) \<br>&amp;&#x3D;log det{z^{\frac12}(I+tz^{-\frac12}vz^{-\frac12})z^{\frac12}} \<br>&amp;&#x3D;log det{z}+log det(I+tz^{-\frac12}vz^{-\frac12})<br>\end{aligned}$$</p><p>对后半部分做对称分解，有$log det(QQ^{T}+tQ\Lambda Q^{T})&#x3D;log det(I+t\Lambda)$</p><p>$$&#x3D;log det{z}+\sum^nlog(1+t\lambda_i)\quad[\lambda_i\text{是}tz^{-\frac12}vz^{-\frac12}\text{的第 i 个特征根}]$$</p><p>$$\begin{aligned}g’(t)&#x3D;\sum_i\frac{\lambda_i}{1+t\lambda_i},\quad g’’(x)&#x3D;\sum_i\frac{-\lambda_i}{(1+t\lambda_i)^2}\leq0\end{aligned}$$</p><h1 id="保凸映射"><a href="#保凸映射" class="headerlink" title="保凸映射"></a>保凸映射</h1><h3 id="非负加权和"><a href="#非负加权和" class="headerlink" title="非负加权和"></a>非负加权和</h3><ul><li><p>若$f_1,\ldots,f_m$都是凸函数，则$f&#x3D;\sum_iw_if_i$为凸，其中$w_i\geq0,\forall i$<br>加权和函数定义域dom $f&#x3D;\cap_idom$ $f_i$</p></li><li><p>求和推广到积分也成立$g(x)&#x3D;\int w(y)f(x,y)dy,w(y)\geq0$</p></li></ul><h3 id="仿射映射和凸映射的复合函数"><a href="#仿射映射和凸映射的复合函数" class="headerlink" title="仿射映射和凸映射的复合函数"></a>仿射映射和凸映射的复合函数</h3><p>若$f(x)$为凸函数</p><ul><li>$g(x)&#x3D;f(Ax+b)$是凸函数</li><li>$g(x)&#x3D;A^T\begin{bmatrix}f_1(x)\\vdots\f_n(x)\end{bmatrix}+b$是凸的，其中$A\in R^{n},b\in R.$</li></ul><h3 id="凸函数的极大值函数"><a href="#凸函数的极大值函数" class="headerlink" title="凸函数的极大值函数"></a>凸函数的极大值函数</h3><p>若 $f_1,f_2$为凸函数,则极大值函数$f(x)&#x3D;\max_x{f_1(x),f_2(x)}$也为凸函数,其定义域为$domf&#x3D;domf_1\cap domf_2\text{。}$</p><p>$$\begin{aligned}<br>f(\theta x+(1-\theta)y)&#x3D;&amp; \begin{aligned}\max{f_{1}(\theta x+(1-\theta)y),f_{2}(\theta x+(1-\theta)y)}\end{aligned} \<br>&amp;\leq\max{\theta f_1(x)+(1-\theta)f_1(y),\theta f_2(x)+(1-\theta)f_2(y)} \<br>&amp;\leq\max{\theta f_1(x),\theta f_2(x)}+(1-\theta)\max{(1-\theta)f_1(y),(1-\theta)f_2(y)} \<br>&amp;&#x3D;\theta f(x)+(1-\theta)f(y)<br>\end{aligned}$$<br><img src="https://www.freeimg.cn/i/2024/08/30/66d189a7cd984.png"></p><p>自然地，推广到无穷个凸函数的极大值函数依然成立，因为无穷个凸函数的比较总可以看为多次进行函数之间的两两比较。</p><p>即：如果对于任意的$y\in A$,函数$f(x,y)$都是关于$x$的凸函数，则函数$g(x)&#x3D;\sup_{y\in\mathcal{A}}f(x,y)$关于$x$也是凸的<br>其中$sup$为逐点取最大操作，称为上确界。</p><p>Q：求实对称矩阵的最大特征值，$f(x)&#x3D;\lambda_{max}(x), dom f&#x3D;S^{m}$<br>A：<br>$$\begin{aligned}&amp;Xy&#x3D;\lambda y\Rightarrow y^TXy&#x3D;\lambda y^Ty&#x3D;\lambda|y|_2^2\Rightarrow\lambda&#x3D;\frac{y^TXy}{|y|_2^2}\&amp;\text{令 }|y|<em>2^2&#x3D;1\text{,则 }\lambda&#x3D;y^TXy\&amp;f(x)&#x3D;\lambda</em>{max}(x)&#x3D;\sup{y^TXy\mid|y|_2^2&#x3D;1}\&amp;\text{注意到 }y^TXy\text{ 是关于 x 的线性组合(将 }y^2\text{ 看作系数),同时 }\sup\text{保凸,所以该函数为凸函数}\end{aligned}$$</p><h3 id="推导出：逐点上确界也是保凸映射1"><a href="#推导出：逐点上确界也是保凸映射1" class="headerlink" title="推导出：逐点上确界也是保凸映射1"></a>推导出：逐点上确界也是保凸映射1</h3><h3 id="复合函数"><a href="#复合函数" class="headerlink" title="复合函数"></a>复合函数</h3><p>$f&#x3D;h(g(x))$<br>当函数都为一元函数时，$f^{\prime\prime}&#x3D;h^{\prime\prime}g^{\prime2}+h^{\prime}g^{\prime\prime}$,分析这个式子与0的大小，可得</p><ul><li>若$h$为不降的凸函数，$g$为凸函数，则$f$为凸函数</li><li>若$h$为不增的凸函数，$g$为凹函数，则$f$为凸函数</li><li>若$h$为不降的凹函数，$g$为凹函数，则$f$为凹函数</li><li>若$h$为不增的凹函数，$g$为凸函数，则$f$为凹函数</li></ul><p>多元函数时，情况类似，需要对函数$f$的定义域做出扩展，例如</p><ul><li>若$g$为凸，则$\exp{g(x)}$为凸，因为满足上述1式 ·</li><li>若$g$为凹，则$\log{g(x}$为凹，因为满足上述3式</li><li>若$g$为凹，$g(x)&gt;0$,则$1&#x2F;g(x)$为凸，因为满足上述2式</li><li>若$g$为凸，$g(x)\geq0$,$p\geq1$,则$g(x)^p$为凸，因为满足上述1式</li></ul><h3 id="函数的透视"><a href="#函数的透视" class="headerlink" title="函数的透视"></a>函数的透视</h3><p>$$\begin{aligned}f: R^{n}&amp;\to R, g: R^{n}\times R_{++}\to R\&amp;g(x,t)&#x3D;tf(\frac{x}{t})\quad dom g&#x3D;{(x,t)\mid t\in R_{++},\frac{x}{t}\in dom f}\end{aligned}$$</p><p>函数的透视有一个很重要的性质，若f为凸函数，则g也为凸函数，且对(x,t)是联合凸的，若f<br>为凹函数，则g对(x,t) 联合凹</p><p>由此导出的一些常用函数的凸性：<br>加权负对数是凸的<br>$$u,v\in R_{++}^n,g(u,v)&#x3D;\sum_{i&#x3D;1}^nu_i\log\frac{u_i}{v_i}$$<br>KL-Divergence是凸的（凸+线性&#x3D;凸）<br>$$D_{KL}(u,v)\triangleq\sum_{i&#x3D;1}^{n}u_{i}log\frac{u_{i} }{v_{i} }-u_{i}+v_{i}$$</p><h1 id="函数的共轭"><a href="#函数的共轭" class="headerlink" title="函数的共轭"></a>函数的共轭</h1><p>函数$f:R^n\to R$的共轭$f^*:R^n\to R$表示为<br>$$f^*(y)&#x3D;\sup_{x\in domf}{y^Tx-f(x)}$$</p><p><strong>性质</strong></p><ul><li>无论$f$是否凸，$f^*(y)$总是凸的(相当于无数条线取max，因此恒为凸)</li><li>$f(x)$如果可微，则$f^*(y)$对应的$x$就是$f^{‘}(x)&#x3D;y$的点($[f^{*}(y)]_{x}^{\prime}&#x3D;y-f^{\prime}(x)&#x3D;0$)</li></ul><p>对于函数而言常常说共轭，对于问题而言常常说对偶</p><p>举几个求函数共轭的例子</p><p><strong>求$f(x)&#x3D;ax+b \ ,dom \ f&#x3D;R$的共轭函数</strong><br>$$f^*(y)&#x3D;\sup\limits_{x\in dom}\left(yx-(ax+b)\right)&#x3D;\sup\limits_{x\in dom}\left((y-a)x+b\right)&#x3D;\begin{cases}-b&amp;\quad y&#x3D;a\[2ex]+\infty&amp;\quad y\neq a\end{cases}$$</p><p><strong>求$f(x)&#x3D;-logx, dom f&#x3D;R_{++}$的共轭函数</strong></p><p>$$\begin{aligned}\text{利用 }[f^*(x)]<em>x’&amp;&#x3D;y+\frac1x&#x3D;0\text{,将 }x&#x3D;-\frac1y\text{ 回代有 }-1-log(-y)\f^*(y)&amp;&#x3D;\sup</em>{x&gt;0} (yx+logx)&#x3D;\begin{cases}-1-log(-y)&amp;\quad y&lt;0\\+\infty&amp;\quad y\ge0\end{cases}\end{aligned}$$</p><p><strong>求二次函数$f(x)&#x3D;\frac{1}{2}x^{T}Q x, Q\in S_{++}^{n}, dom f&#x3D;R^{n}$的共轭函数</strong></p><p>$$f^*(y)&#x3D;\sup (y^Tx-\frac{1}{2}x^TQx), [f^*(y)]_x^{\prime}&#x3D;y-Qx&#x3D;0$$<br>回带消去$x$，$y^Tx-\frac{1}{2}x^TQx$化为<br>$$\begin{aligned}y^TQ^{-1}y-\frac{1}{2}y^TQ^{-1}Q^TQ^{-1}y&#x3D;\frac{1}{2}y^TQ^{-1}y\end{aligned}$$</p><p>对于数而言，共轭的共轭为其自身，而这对函数并不成立，因为函数的共轭一定是凸函数，凹函数<br>的共轭的共轭一定不为自身<br>只有在f 为凸函数，并且为闭函数时，f的共轭的共轭才为自身</p><h1 id="拟凸函数"><a href="#拟凸函数" class="headerlink" title="拟凸函数"></a>拟凸函数</h1><p>$\alpha$-sublevel-set (下水平集):任意函数 $f:R^n\to R$的 $\alpha$-sublevel-set 为：<br>$$C_\alpha&#x3D;{x\in domf|f(x)\leq\alpha}.$$</p><h3 id="定义一"><a href="#定义一" class="headerlink" title="定义一"></a>定义一</h3><p>对于任意的$\alpha$,其$\alpha$-sublevel set均为凸集的函数为拟凸函数，又叫做单模态函数。</p><h3 id="定义二"><a href="#定义二" class="headerlink" title="定义二"></a>定义二</h3><p>$$\forall x,y\in dom f, \theta\in[0,1], \max{f(x),f(y)}\geq f(\theta x+(1-\theta)y)$$</p><p><img src="https://www.freeimg.cn/i/2024/08/30/66d1d3d7d661b.png" alt="1725027283614.png"></p><p>例子：<strong>向量的长度</strong>，向量$x \in R^n$，即</p><p>$$f(x)&#x3D;\left{\begin{array}{ll}\max{i,x_i\neq0},&amp;x\neq0\0,&amp;x&#x3D;0\end{array}\right.$$</p><p>$$S_\alpha&#x3D;{f(x)\leq\alpha}\Rightarrow \forall i&#x3D;\lfloor i\rfloor+1\ldots n, x_i&#x3D;0$$</p><p>相当于取子空间，$S_{\alpha}$代表的是一些轴上取零，其余轴上的值任意，为凸集，因此$f(x)$为拟凸函数</p><p>例子：<strong>线性分数函数</strong> $\begin{aligned}f(x)&#x3D;\frac{a^Tx+b}{c^Tx+d}, dom f&#x3D;{x\mid c^Tx+d&gt;0}\end{aligned}$</p><p>$$S_{\alpha}&#x3D;{x\mid c^{T}x+d&gt;0, \frac{a^{T}x+b}{c^{T}x+d}&lt;\alpha}&#x3D;{x\mid c^{T}x+d&gt;0, ax+b\leq\alpha(c^{T}x+d)}$$</p><p>该集合表示一个多面体，为凸集，因此f(x)为拟凸函数</p><h3 id="优化性质分析"><a href="#优化性质分析" class="headerlink" title="优化性质分析"></a>优化性质分析</h3><p>一般来说凸函数能用的算法拟凸函数也能用，拟凸函数是相对比较好做的非凸优化问题，不过与凸优化问题不同的是，他往往很难找到多项式时间内可以求解的算法</p><h3 id="凸松弛"><a href="#凸松弛" class="headerlink" title="凸松弛"></a>凸松弛</h3><p>例，向量的零范数$x\in\mathbb{R}^n\textit{,}f(x)&#x3D;|x|_0$</p><p> 一维情况，函数图像如下，不是凸函数，是拟凸函数<br><img src="https://www.freeimg.cn/i/2024/08/30/66d1e402469f1.png" alt="1725031149696.png"></p><p>  二维情况，函数图像如下，下水平集不是凸集，不是拟凸函数</p><p><img src="https://www.freeimg.cn/i/2024/08/30/66d1e4038e3a2.png" alt="1725031417805.png"></p><p>通常求解稀疏约束问题时，可将零范数放缩、松弛为1范数</p><p><img src="https://www.freeimg.cn/i/2024/08/30/66d1e42caf796.png" alt="1725031464851.png"></p><p>有的人会使用性质更好的函数去近似一范数</p><p><img src="https://www.freeimg.cn/i/2024/08/30/66d1e46138e80.png" alt="1725031517660.png"></p><h3 id="一阶条件-1"><a href="#一阶条件-1" class="headerlink" title="一阶条件"></a>一阶条件</h3><p>$$f\text{ 拟凸}\Leftrightarrow domf\text{ 凸,且若}f(y)\leq f(x)\text{,则 }\nabla^Tf(x)(y-x)\leq0.$$</p><p>以上公式文字表述为：拟凸函数只有一个极小值点。</p><p>拟凸函数梯度为0的点不一定是极小值点<br><img src="https://www.freeimg.cn/i/2024/08/30/66d1e559ce465.png" alt="1725031765905.png"></p><h3 id="二阶条件-1"><a href="#二阶条件-1" class="headerlink" title="二阶条件"></a>二阶条件</h3><p>$$dom f\text{ 为凸,且 }y^T\nabla f(x)\geq0\Rightarrow y^T\nabla^2f(x)y\geq0$$</p><ul><li>log 凸：$f(x)&gt;0$,若$\log f$为凸函数，则$f$为log凸函数       </li><li>log 凹：$f(x)&gt;0$,若$\log f$为凹函数，则$f$为log凹函数       </li><li>若$f$为log凸，则$f$为凸。(提示：用复合函数凹凸性可判断) </li><li>若$f$为凹，则$\log f$为log凹</li></ul><h1 id="参考文献-blog"><a href="#参考文献-blog" class="headerlink" title="参考文献&#x2F;blog"></a>参考文献&#x2F;blog</h1><ul><li><a href="https://www.bilibili.com/video/BV19M411T7S7?p=20&vd_source=84b977d2834d5eca6c0ca78bd619156f%EF%BC%8C%E4%B8%AD%E7%A7%91%E5%A4%A7/%E5%87%8C%E9%9D%92%E3%80%8A%E5%87%B8%E4%BC%98%E5%8C%96%E3%80%8B%EF%BC%8Cchapter9-20">https://www.bilibili.com/video/BV19M411T7S7?p=20&amp;vd_source=84b977d2834d5eca6c0ca78bd619156f，中科大/凌青《凸优化》，chapter9-20</a></li><li>知乎专栏，<a href="https://www.zhihu.com/column/c_1492543238217478144">https://www.zhihu.com/column/c_1492543238217478144</a></li><li>知乎专栏，<a href="https://zhuanlan.zhihu.com/c_1280779583399882752">https://zhuanlan.zhihu.com/c_1280779583399882752</a></li><li>《ConvexOptimizationnotes》，<a href="https://github.com/ZxyGed/ConvexOptimization%EF%BC%8CConvex_Function">https://github.com/ZxyGed/ConvexOptimization，Convex_Function</a> pdf笔记</li></ul>]]></content>
    
    
    <categories>
      
      <category>数学</category>
      
      <category>凸优化</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>凸问题</title>
    <link href="/2025/03/21/%E6%95%B0%E5%AD%A6/%E5%87%B8%E4%BC%98%E5%8C%96/%E5%87%B8%E9%97%AE%E9%A2%98/"/>
    <url>/2025/03/21/%E6%95%B0%E5%AD%A6/%E5%87%B8%E4%BC%98%E5%8C%96/%E5%87%B8%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h1 id="问题定义"><a href="#问题定义" class="headerlink" title="问题定义"></a>问题定义</h1><h3 id="凸优化问题"><a href="#凸优化问题" class="headerlink" title="凸优化问题"></a>凸优化问题</h3><p>一般优化问题的描述：</p><p>$$\begin{array}{lll}\min&amp;f_0(x)\\s.t.&amp;f_i(x)\leq0&amp;i&#x3D;1,\ldots,m\\&amp;h_i(x)&#x3D;0&amp;i&#x3D;1,\ldots,p\end{array}$$</p><p>广义凸问题：凸目标，凸集约束<br>狭义凸问题：    </p><p>$$\begin{aligned}&amp;\min\quad f_{0}(x)&amp;&amp;f_{0}(x)\text{为凸}\&amp;s.t.\quad f_{i}(x)\leq0\quad i&#x3D;1,\ldots,m&amp;&amp;f_{i}(x)\text{均为凸}\&amp;a_{i}^{T}x&#x3D;b_{i}\quad i&#x3D;1,\ldots,p&amp;&amp;\text{等式约束为仿射函数}\end{aligned}$$</p><h3 id="常用定义"><a href="#常用定义" class="headerlink" title="常用定义"></a>常用定义</h3><ul><li><p>**优化问题的域(domain)**：$\text{D&#x3D;}\bigcap\limits_{i&#x3D;0}^mdom f_i \cap \bigcap\limits_{i&#x3D;1}^pdom h_i$</p></li><li><p>**可行解集(feasibleset)**：$X_{f}&#x3D;{x\mid x\in D, f_{i}(x)\leq0,i&#x3D;1,\dots,m, h_{i}(x)&#x3D;0,i&#x3D;1,\dots,p}$</p></li><li><p>**最优值(optimizationvalue)*<em>：$p^</em>&#x3D;\inf\left{f_0(x)\mid x\in X_f\right]$</p></li><li><p>*<em>最优解(optimizationpoint&#x2F;solution)*<em>：$\text{若 }x^</em>\text{ 可行,且 }f_0(x^*)&#x3D;p^</em>\text{,称 }x^*\text{ 为最优解}$</p></li><li><p><strong>局部最优解(locallyoptional)</strong>:$f_0(x)&#x3D;\inf \left{\begin{array}{ll} \quad \quad \quad f_i(x)\leq0,i&#x3D;1,\dots,m\[1ex]f_0(z)    | \quad  h_i(z)&#x3D;0,i&#x3D;1,\dots,p\ \quad \quad \quad  |z-x|\leq R\end{array}\right}$</p></li></ul><p><img src="https://www.freeimg.cn/i/2024/08/31/66d321b2e0ae2.png" alt="1725112752619.png"></p><h1 id="问题性质"><a href="#问题性质" class="headerlink" title="问题性质"></a>问题性质</h1><h3 id="常用等价变换"><a href="#常用等价变换" class="headerlink" title="常用等价变换"></a>常用等价变换</h3><p><strong>BoxConstraint</strong>(箱约束)转化为标准形式</p><p>$$l_i\leq x\leq u_i\Rightarrow\begin{cases}l_i-x_i\leq0\[2ex]x_i-u_i\leq0\end{cases}$$</p><p><strong>缩放</strong>，给目标函数或约束条件乘上一些正系数，类似于数据清洗</p><p>$$\begin{aligned}\operatorname*{min}&amp; \alpha_0 f_0(x)\[2ex]s.t.&amp; \alpha_i f_i(x)\leq0\quad i&#x3D;1,\dots,m\[2ex]&amp; \beta_i h_i(x)&#x3D;0\quad i&#x3D;1,\dots,p\end{aligned}$$</p><p><strong>消除等式约束</strong>，可以把等式约束当做方程解出来带入其他部分</p><p><strong>引入松弛变量</strong></p><p>$$\begin{aligned}&amp;\operatorname*{min}\quad f_{0}(x)\&amp;s.t.\quad s_{i}\leq0\&amp;f_{i}(x)-s_{i}&#x3D;0\quad i&#x3D;1,\ldots,m\&amp;a_{i}^{T}x&#x3D;b_{i}\quad i&#x3D;1,\ldots,p\end{aligned}$$</p><p>许多优化算法（如线性规划、二次规划等）都是针对具有特定形式（如线性约束、凸目标函数）的问题设计的。通过引入松弛变量，可以将原始问题转化为这些算法能够处理的形式，从而利用这些算法来求解问题。</p><h3 id="局部最优即是全局最优"><a href="#局部最优即是全局最优" class="headerlink" title="局部最优即是全局最优"></a>局部最优即是全局最优</h3><p>证明：若找到了局部最优解$x$,用反证法证明$x$一定是全局最优解<br>$$\begin{aligned}&amp;\text{设 x 不是全局最优,那么必然}\exists y\in X_f, s.t. f_0(y)&lt;f_0(x)\&amp;\because\text{x 为局部最优,}\Rightarrow|y-x|_2&gt;R\&amp;\text{令 }z&#x3D;\theta y+(1-\theta)x\text{,取 }\theta&#x3D;\frac R{2|y-x|_2}\in[0,1]\&amp;\therefore\text{z 为凸组合,}z\in X_f\text{ 且 }f_0(z)\leq\theta f_0(y)+(1-\theta)f_0(x)\&amp;|z-x|_2&#x3D;\theta|x-y|_2&#x3D;\frac R2&lt;R\text{,由 x 局部最优有 }f_0(x)\leq f_0(z)\&amp;\text{由此应该有 }f_0(y)&lt;f_0(x)\leq f_0(z)\text{ (两条结论矛盾,因此原假设成立)}\end{aligned}$$</p><p>对千拟凸优化问题，局部最优解是全局朵优解这一性质不成立</p><h3 id="最优解处的一阶条件"><a href="#最优解处的一阶条件" class="headerlink" title="最优解处的一阶条件"></a>最优解处的一阶条件</h3><p>设凸优化问题的目标函数是可微的，记最优解为$x^*$,可行域为$X_f$对于任意的$y \in X_f$,均满足<br>$$\nabla f_{0}^{T}(x^{<em>})(y-x^{</em>})\geq0$$</p><p>简单证明一下，我们都知道凸函数的一阶性质是<br>$$f(y)\geq f(x)+\nabla f^{T}(x)(y-x) \quad \quad （1）$$</p><p>如果最优解处的一阶条件是满足$\nabla f_{0}^{T}(x^{<em>})(y-x^{</em>})\geq0$的，那么代入（1）可以得到$f(y) \geq f(x^*)$,符合$x^*$是最优解得要求</p><p>如果最优解处的一阶条件不满足$\nabla f_{0}^{T}(x^{<em>})(y-x^{</em>})\geq0$<br>考虑点 $z(t) &#x3D; ty + (1- t)x$, 其中 $t \in (0, 1]$ 为参数。因为 $z(t)$ 在 $x$ 和 $y$ 之间的线段上，<br>而可行集是凸集，因此 $z(t)$ 可行。我们可断言对于总有小正数$t$, 使得$f_0(z(t) ) &lt; f_0(x)$, 这证<br>明了x不是最优的。为说明这一点，注意<br>$$\left.\frac{d}{dt}f_0(z(t))\right|_{t&#x3D;0}&#x3D;\nabla f_0(x)^T(y-x)&lt;0,$$</p><p>综上所述，最优解处的一阶条件成立</p><p><img src="https://www.freeimg.cn/i/2024/08/31/66d326a5b97e5.png"></p><p>看看上述式子的几何意义，设$X$为可行域，$x$为最优解，图中虚线簇为优化函数$f_0$的等高线，则最优解处的一阶条件给出了一个超平面$\nabla f_0(x)^T(y-x)&#x3D;0$，可行域作为一个凸集总在超平面的一侧,也就是$\nabla f_0(x)^T(y-x)&lt;0$</p><h3 id="仅有等式约束"><a href="#仅有等式约束" class="headerlink" title="仅有等式约束"></a>仅有等式约束</h3><p>$$\begin{array}{ll}\min&amp;f_0(x)\quad dom\mathrm{~}f_0&#x3D;\mathbb{R}^n\s.t.&amp;Ax&#x3D;b\end{array}$$</p><p>带入一阶最优条件<br>$$\text{令}v&#x3D;y-x^<em>\text{,}约束条件化为\nabla f_0^T(x^</em>)v\geq0\text{,}v\in\mathcal{N}(A)\text{,则 }\nabla f_0^T(x^*)\perp v$$</p><p>为何由$\nabla f_0^T(x^*)v\geq0$便可以断言$\nabla f_0^T(x^*)\perp v$?,不妨从几何的角度来理解。图上看结果是：最优解处函数梯度垂直于$A$的化零空间</p><p><img src="https://www.freeimg.cn/i/2024/08/31/66d32867cbc98.png" alt="1725114468739.png"></p><p>可以想象:无论如何调整$\nabla f_0(t)$方向，也无法使所有的$v\in\mathcal{N}(A)$(对应$Ax&#x3D;0$)都做到$\nabla f_0^T(x^*)v\geq0$,因此只能是<br>$$\nabla f_0^T(x^*)\perp v$$</p><h3 id="仅有非负约束"><a href="#仅有非负约束" class="headerlink" title="仅有非负约束"></a>仅有非负约束</h3><p>$$\begin{aligned}&amp;\min f_0(x)\&amp;s.t. x\geq0\&amp;\nabla f_0^T(x^*)y-\nabla f_0^T(x^*)x^*\geq0 \quad \quad (1)\end{aligned}$$</p><p>上式是关于任意$y \geq 0$的线性函数($y$的约束与x相同)，若想要(1)式子大于等于0恒成立，则系数必然有<br>$$\nabla f_0(x^*)\geq0  \quad \quad (2)$$<br>为什么？倘若$\nabla f^T_0(x^*)$有负数分量$\nabla f^T_{0i}(x^*)$,由于$y$在正数范围内任取，令$y_i$取到足够大的正无穷，其余分量为0，则(1)不成立。因此$\nabla f^T_0(x^*)$是不能有负数分量的</p><p>再看看其他有用的性质，令$y&#x3D;0$，由(1)可以得到.$-\nabla f_0^T(x^*)x^*\geq0 \quad \quad (3)$</p><p>结合(2)(3)和$x$非负的约束，可以得到$\nabla f_0^T(x^*)x^*&#x3D;0$，这两项内积为0，且都非负，所以$(\nabla f_0(x^*))<em>ix_i^*&#x3D;0,\forall i\text{。}$，注意这里得出了一个重要性质，最优解处考察每一个维度，要么梯度值分量为0，要么约束取等号，这个条件叫做互补条件(complementary)。以下图为例检验一下,蓝色线为目标函数等高线，约束为第一象限$\mathbb{R}^2</em>{++}$，此时满足互补条件</p><p><img src="https://www.freeimg.cn/i/2024/08/31/66d32b2a6d859.png" alt="1725115176564.png"></p><h1 id="问题举例"><a href="#问题举例" class="headerlink" title="问题举例"></a>问题举例</h1><h3 id="线性规划"><a href="#线性规划" class="headerlink" title="线性规划"></a>线性规划</h3><p>$$\begin{aligned}<br>&amp;\mathrm{min} c^{T}x+d \<br>&amp;s.t. Gx+s&#x3D;h \<br>&amp;Ax&#x3D;b \<br>&amp;s\geq0<br>\end{aligned}$$</p><p>等价变换</p><p>$$\begin{aligned}&amp;\mathrm{min}&amp;&amp;c^{T}x^{+}-c^{T}x^{-}+d\&amp;s.t.&amp;&amp;Gx^{+}-Gx^{-}+s&#x3D;h\&amp;&amp;&amp;Ax^{+}-Ax^{-}&#x3D;b\&amp;&amp;&amp;s\geq0, x^{+}\geq0, x^{-}\geq0\end{aligned}$$</p><p>其中$x^+$和$x^-$是只有0分量和正分量的向量，举个例子：<br>x&#x3D;[-2,1,-2,3],则$x^+$&#x3D;[0,1,0,3],$x^-$&#x3D;[2,0,2,0]</p><p>通过这种变换能够将问题化为线性约束以及非负约束，这方便使用函数(linprog)进行求解。<br>根据一阶最优条件线性规划的解在边界上</p><p><img src="https://www.freeimg.cn/i/2024/09/01/66d3cf7abef7c.png" alt="1725157239220.png"></p><h3 id="线性分数规划"><a href="#线性分数规划" class="headerlink" title="线性分数规划"></a>线性分数规划</h3><p>$$\begin{aligned}<br>&amp;\mathrm{min}&amp;&amp; \frac{c^{T}x+d}{e^{T}x+f} \<br>&amp;s.t.&amp;&amp; Gx\leq h \<br>&amp;&amp;&amp;Ax&#x3D;b \<br>&amp;&amp;&amp;e^{T}x+f&gt;0<br>\end{aligned}$$<br>这个问题不是凸优化问题，但是可以化为线性规划问题</p><p>取$y&#x3D;\frac{x}{e^{T}x+f}, z&#x3D;\frac{1}{e^{T}x+f}$，得到等价问题</p><p>$$\begin{aligned}<br>&amp;\mathrm{min}&amp;&amp; c^{T}y+dz \<br>&amp;s.t.&amp;&amp; Gy-hz\leq0 \<br>&amp;&amp;&amp;Ay-bz&#x3D;0 \<br>&amp;&amp;&amp;e^{T}y+fz&#x3D;1 \<br>&amp;&amp;&amp;z\geq0<br>\end{aligned}$$</p><p>【如何判断两个优化问题等价？】              </p><p>【在一个优化问题里面找一个可行解，使得能在另一个那里找到对应的可行集，且这两个解对应的目标函数值是相等的】</p><h3 id="二次规划"><a href="#二次规划" class="headerlink" title="二次规划"></a>二次规划</h3><p>(quadratic programming, QP)目标函数为二次函数，约束为放射约束</p><p>$$\begin{array}{rl}\min&amp;\frac{1}{2}X^TPX+q^Tx+r\\s.t.&amp;Qx\leq h\quad P\in S_+^n\\&amp;Ax&#x3D;b\end{array}$$</p><p>线性规划问题的最优解只能在边界点取到，二次规划问题的最优解可能在内部取到</p><p><img src="https://www.freeimg.cn/i/2024/09/01/66d3d1d153953.png" alt="1725157839000.png"></p><p><strong>二次约束的二次规划(Quadratically Constrained Quadratic Programing, QCQP)</strong></p><p>$$\begin{aligned}&amp;\text{min}&amp;&amp;\frac{1}{2}X^{T}PX+q^{T}x+r\&amp;s.t.&amp;&amp;\frac{1}{2}X^{T}P_{i}X+q_{i}^{T}x+r\leq0&amp;&amp;P\in S_{++}^{n}\&amp;&amp;&amp;Ax&#x3D;b&amp;&amp;P_{i}\in S_{+}^{n}, i&#x3D;1,\ldots,m\end{aligned}$$</p><h3 id="稀疏约束的最小二乘"><a href="#稀疏约束的最小二乘" class="headerlink" title="稀疏约束的最小二乘"></a>稀疏约束的最小二乘</h3><p>之前提到可以使用1范数取代0范数</p><p>$$\begin{array}{ll}\hat{x}&#x3D;\arg\min_x&amp;|b-Ax|_2^2+\lambda_0|x|_0\\&#x3D;\arg\min_x&amp;|b-Ax|_2^2+\lambda_1|x|_1&amp;(l_1-regularized least squares)\end{array}$$</p><p>但是带有绝对值的目标函数显然是不好优化的，为此做一些变换</p><p>令$x&#x3D;x^+-x^-$,则$\lambda_{1}|x^{+}-x^{-}|<em>{1}&#x3D;\lambda</em>{1}1^{T}x^{+}+\lambda_{1}1^{T}x^{-}$，从而消除绝对值，化为二次规划的问题</p><p>$$\begin{array}{rl}\hat{x}&#x3D;\arg\min_x&amp;|b-Ax^+-Ax^-|_2^2+\lambda_11^Tx^++\lambda_11^Tx^-\\s.t.&amp;x^+,x^-\geq0\end{array}$$</p><h3 id="半正定规划"><a href="#半正定规划" class="headerlink" title="半正定规划"></a>半正定规划</h3><p>半正定规划有两种形式，一种是矩阵形式，一种是向量形式<br>半正定规划的矩阵形式，这实际上是矩阵空间的线性规划（因为trace 的操作实际上是线性操作，<br>可从特例对角矩阵理解）</p><p>$$\begin{array}{rl}\mathrm{min}&amp;tr(CX)\\s.t.&amp;tr(A_iX)&#x3D;b_i, i&#x3D;1,\ldots,p\\&amp;X\succeq0, X\in S_{+}^{n}, C\in R^{n\times n}, A_{i}\in R^{n\times n}, b_{i}\in R\end{array}$$</p><p>向量形式</p><p>$$\begin{array}{ll}\min&amp;c^Tx\\s.t.&amp;x_1A_1+\cdots+x_nA_n\preceq B\\&amp;x\in R^n, B,A_1,\ldots,A_n\in S^k, C\in R^n\end{array}$$</p><p>经典的问题：谱范数(最大奇异值)问题<br>谱范数指的是矩阵的最大奇异值<br>求$A(x)&#x3D;A+x_1A_1+\cdots+x_nA_n,A_i\in\mathbb{R}^{p\times q}$最小谱范数？<br>由于谱范数恒正，记优化函数为$\sqrt{S}$,问题表述为</p><p>$$\begin{aligned}<br>\mathrm{min}&amp; \sqrt{S} (\text{非凸})\quad\Leftrightarrow\quad S (\text{凸}) \<br>s.t.&amp; A(x)^TA(x)\preceq SI \<br>\Rightarrow\mathrm{min}&amp; \text{t} \<br>s.t.&amp; A(x)^TA(x)\preceq t^2I, t\geq0 \<br>\Rightarrow\mathrm{min}&amp; \text{t} \<br>s.t.&amp; \left.\left[\begin{array}{cc}tI&amp;A(x)\\A^T(x)&amp;tI\end{array}\right.\right]\succeq0, t\geq0 \<br>&amp;&amp;\Rightarrow\mathrm{min} t \text{:} \<br>s.t.&amp; Y&#x3D;\left[\begin{array}{cc}tI&amp;A(x)\[0.3em]A^T(x)&amp;tI\end{array}\right], Y\succeq0, t\geq0<br>\end{aligned}$$</p><p>具体的等价证明参见附录</p><h3 id="多目标优化"><a href="#多目标优化" class="headerlink" title="多目标优化"></a>多目标优化</h3><ul><li>例如，投资要在总成本限制下，最小化风险，最大化收益；发展要在一定资源限制下，最大化发展速度与发展质量。</li><li>此时有多个目标，通常在某个指标上变好，就会在另外一个指标上变差，权衡不同目标，得出最优解的集合称为帕累托曲面(Pareto front)</li></ul><p><img src="https://www.freeimg.cn/i/2024/09/01/66d41b08d3956.png" alt="1725176582131.png"></p><p>帕累托曲面通常很难找到，因此多目标优化事实上是个很难做的问题，我们一般会定住某些目标将问题变为单目标优化问题，比如使用罚函数的思想。以岭回归为例<br>$$\begin{array}{l}\min|b-Ax|_2^2\text{,}\min|x|_2^2\\min|b-Ax|_2^2+\lambda|x|_2^2\end{array}$$</p><p>遍历不同的超参数$\lambda$即可得到帕累托曲面</p><p><img src="https://www.freeimg.cn/i/2024/09/01/66d41b9700b6b.png" alt="1725176724670.png"></p>]]></content>
    
    
    <categories>
      
      <category>数学</category>
      
      <category>凸优化</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>凸集</title>
    <link href="/2025/03/21/%E6%95%B0%E5%AD%A6/%E5%87%B8%E4%BC%98%E5%8C%96/%E5%87%B8%E9%9B%86/"/>
    <url>/2025/03/21/%E6%95%B0%E5%AD%A6/%E5%87%B8%E4%BC%98%E5%8C%96/%E5%87%B8%E9%9B%86/</url>
    
    <content type="html"><![CDATA[<h1 id="仿射"><a href="#仿射" class="headerlink" title="仿射"></a>仿射</h1><h3 id="仿射集-Affine-Sets"><a href="#仿射集-Affine-Sets" class="headerlink" title="仿射集(Affine Sets)"></a>仿射集(Affine Sets)</h3><p>等价定义1: 若对集合$C$中的任意两点$x_1,x_2$,都有过$x_1,x_2$的直线也在$C$中，则称$C$为仿射集<br>即：<br>$$\forall x_1,x_2\in C,\forall\theta\in R\Rightarrow y&#x3D;\theta x_1+(1-\theta)x_2\in C.$$</p><p>等价定义2：设 $x_1,\ldots,x_k\in C,\forall\theta_1,\ldots,\theta_k\in R$,且$\sum_{i&#x3D;1}^k\theta_i&#x3D;1$,有$\sum_{i&#x3D;1}^k\theta_kx_k\in C$,则称$C$ 为<br>仿射集.</p><p>例如：直线是仿射集，全空间是仿射集，线段不是仿射集。线性方程组的解$C \ {x|Ax&#x3D;b}$是仿射集，且齐次线性方程组的解$V \ { x|Ax&#x3D;0 }$满足更好的性质，即<br>$$\forall x,y\in V,\alpha,\beta\in R\text{,有 }\alpha x+\beta y\in V\text{,而不必要求 }\alpha+\beta&#x3D;1$$<br>通常称$V$是$C$的仿射子空间</p><h3 id="仿射组合"><a href="#仿射组合" class="headerlink" title="仿射组合"></a>仿射组合</h3><p>仿射组合：设$x_1, \ldots , x_k\in C$, $\theta <em>1, \ldots , \theta <em>k\in R, \theta <em>1+ \cdots + \theta <em>k&#x3D; 1$, $\theta <em>1x_1+ \cdots + \theta <em>kx_k$称为仿射组合<br>$\Rightarrow$若 C 为仿射集，则仿射组合也在 C 内，证明如下<br>$$\begin{aligned}&amp;\frac{\theta</em>{1}}{\theta</em>{1}+\theta</em>{2}}x</em>{1}+\frac{\theta</em>{2}}{\theta</em>{1}+\theta_{2}}x_{2}\in C\&amp;(\theta_{1}+\theta_{2})\left(\frac{\theta_{1}}{\theta_{1}+\theta_{2}}x_{1}+\frac{\theta_{2}}{\theta_{1}+\theta_{2}}x_{2}\right)+(1-\theta_{1}-\theta_{2})x_{3}\in C\&amp;\Leftrightarrow\theta_{1}x_{1}+\theta_{2}x_{2}+\theta_{3}x_{3}\in C,\quad\theta_{1}+\theta_{2}+\theta_{3}&#x3D;1\end{aligned}$$<br>按照此思路可以递归的证明到多个点进行仿射组合的情况</p><h3 id="仿射包"><a href="#仿射包" class="headerlink" title="仿射包"></a>仿射包</h3><p>对于任意集合$C$,仿射包$aff \ C$是包含$C$的最小仿射集，<br>$$aff \ C&#x3D;{\theta_1x_1+\dots+\theta_kx_k|\forall x_1,\dots,x_k\in C,\theta_1+\dots+\theta_k&#x3D;1}$$</p><p>不管集合$C$是什么, $aff \ C$都一定是仿射集, 且是所有包含$C$的仿射集中最小的仿射集.也就是说我们可以从任意集合中构造一个特殊的仿射集。<br>举个例子<br><img src="https://www.freeimg.cn/i/2024/08/28/66cf39f2b4c3b.png" alt="仿射包"><br>${x_1,x_2 }$的仿射包是连接两点的直线，${x_1,x_2,x_3 }$的仿射包是$R^2$</p><h1 id="凸"><a href="#凸" class="headerlink" title="凸"></a>凸</h1><h3 id="凸集"><a href="#凸集" class="headerlink" title="凸集"></a>凸集</h3><p>一个集合$C$为凸集，当且仅当任意连接$C$内两点的线段也在$C$内，即<br>$$\forall x_{1},x_{2}\in C, \forall\theta\in[0,1], \theta x_{1}+(1-\theta)x_{2}\in C$$<br>等价定义为$C$中任意多个元素的凸组合也在$C$内</p><h3 id="凸组合"><a href="#凸组合" class="headerlink" title="凸组合"></a>凸组合</h3><p>$x_1, \ldots , x_k\in C$, $\theta _1, \ldots , \theta _k\in [ 0, 1]$, $\theta _1+ \cdots + \theta _k&#x3D; 1$, $\theta _1x_1+ \cdots + \theta _kx_k$<br>凸集包含其任意元素的凸组合      </p><h3 id="凸包"><a href="#凸包" class="headerlink" title="凸包"></a>凸包</h3><p>对任意集合$C$,包含$C$的最小凸集称为C的凸包<br> $Conv( C) &#x3D; { \theta <em>{1}x</em>{1}+ \cdots + \theta <em>{k}x</em>{k}| x_{1}, \ldots , x_{k}\in C$, $\theta _{1}, \ldots , \theta _{k}\in [ 0, 1]$, $\theta _{1}+ \cdots + \theta _{k}&#x3D; 1}$<br>凸包的几何意义由下图清晰地展示。<br> <img src="https://www.freeimg.cn/i/2024/08/28/66cf3c7206d3f.png" alt="集合与其凸包"></p><h1 id="锥"><a href="#锥" class="headerlink" title="锥"></a>锥</h1><ul><li><p>椎：$\forall x\in C$, $\theta \geq 0\Rightarrow \theta x\in C$</p></li><li><p>凸锥$\forall x_1, x_{2}\in C$, $\theta _{1}, \theta _{2}\geq 0\Rightarrow \theta <em>{1}x</em>{1}+ \theta <em>{2}x</em>{2}\in C$</p></li><li><p>凸锥组合：$\theta <em>{1}x</em>{1}+ \cdots + \theta <em>{k}x</em>{k}$, $\theta _{1}, \ldots , \theta _{k}\geq 0$</p></li><li><p>凸锥包：${\theta_{1}x_{1}+\cdots+\theta_{k}x_{k}|x_{1},\ldots,x_{k}\in C,\theta_{1},\ldots,\theta_{k}\geq0}$</p></li><li><p><img src="https://www.freeimg.cn/i/2024/08/28/66cf3d7d48949.png" alt="凸锥的几何意义感受"><br><img src="https://www.freeimg.cn/i/2024/08/28/66cf3d7d47a57.png" alt="凸锥包的几何意义感受"></p></li></ul><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>设 $x_1,\ldots,x_k\in C,\forall\theta_1,\ldots,\theta_k\in C$,在下表对应的情况下，</p><p>$$\begin{array}{|c|c|c|}\hline\text{仿射集}&amp;\text{凸集}&amp;\text{凸锥}\\hline\theta_1+\cdots+\theta_k&#x3D;1&amp;\theta_1+\cdots+\theta_k&#x3D;1\\theta_1,\ldots,\theta_k\in R&amp;\theta_1,\ldots,\theta_k\in[0,1]&amp;\theta_1,\ldots,\theta_k\geq0\\hline\end{array}$$</p><p>有$\sum_{i&#x3D;1}^k\theta_kx_k\in C$，则$C$为仿射集&#x2F;凸集&#x2F;凸锥。</p><h1 id="凸集举例"><a href="#凸集举例" class="headerlink" title="凸集举例"></a>凸集举例</h1><ul><li><p>$R^n$空间，$R^n$空间的子空间</p></li><li><p>任意直线(若过原点也为凸锥),任意线段，射线${x_0+\theta v|\theta\geq0,x\in R^n,\theta\in R,v\in R^n}$</p></li><li><p>超平面与半空间</p></li><li><p>球和椭球</p></li><li><p>多面体(Polyhedron)和单纯形(Simplex)</p></li><li><p>对称矩阵集合，对称半正定矩阵集合，对称正定矩阵集合</p></li></ul><h3 id="超平面"><a href="#超平面" class="headerlink" title="超平面"></a>超平面</h3><ul><li>超平面(hyperplane)${x\mid a^{T}x&#x3D;b}$为平面在高维空间中的扩展  ，它是凸集，是仿射集，若否过原点则是凸锥</li><li>半空间(halfspace)${a^Tx\geq b\text{或}a^Tx\leq b}$为由超平面分开的全空间的一半，它是凸集，非仿射集，若过原点则是凸锥<br><img src="https://www.freeimg.cn/i/2024/08/28/66cf403822d39.png" alt="1724858421543.png"></li></ul><h3 id="球"><a href="#球" class="headerlink" title="球"></a>球</h3><p>$B(x_{c},r)&#x3D;{x\mid|x-x_{c}|<em>{2}\leq r}&#x3D;{x\mid\sqrt{(x-x</em>{c})^{T}(x-x_{c})}\leq r}$是凸集<br>证：<br>$$\begin{aligned}&amp;\forall\theta\in[0,1]\text{,取 }f(x)&#x3D;|x-x_c|<em>2\&amp;|\theta x_1+(1-\theta)x_2-x_c|<em>2&#x3D;|\theta(x_1-x_c)+(1-\theta)(x_2-x_c)|<em>2\&amp;\leq \theta|x</em>{1}-x</em>{c}|</em>{2}+(1-\theta)|x_{2}-x_{c}|_{2}\end{aligned}$$</p><h3 id="椭球"><a href="#椭球" class="headerlink" title="椭球"></a>椭球</h3><p>$$\varepsilon(x_{c},P)&#x3D;{x\mid(x-x_{c})^{T}P^{-1}(x-x_{c})\leq1}, x_{c}\in R^{n}, P\in S_{++}^{n}$$<br>其中P为对角矩阵，对角线上为矩阵的奇异值的平方，矩阵的奇异值对应了椭球的半轴长</p><h3 id="多面体"><a href="#多面体" class="headerlink" title="多面体"></a>多面体</h3><p>多面体(polyhedron)是半空间与超平面的交集，为凸集。<br>$${x\mid a_{j}^{T}x\leq b_{j}, j&#x3D;1,\ldots,m, c_{j}^{T}x&#x3D;d_{j}, j&#x3D;1,\ldots,p}$$<br>当然多个条件也可以一起排列写成矩阵的形式，简单来说只有若干个线性不等式和等式的约束代表的凸集即是多面体，注意多面体不一定封闭。</p><h3 id="单纯形"><a href="#单纯形" class="headerlink" title="单纯形"></a>单纯形</h3><p>在$\mathbb{R}^{n}$空间中选择$k+1$个仿射无关的点$v_0,v_1,\ldots,v_k ,$（也就是满足$v_1-v_0,v_2-v_0,\ldots,v_k-v_0$线性无关），我们称点$v_1,\ldots v_k$的凸包为单纯形<br>$$C&#x3D;conv{v_1,\ldots,v_k}&#x3D;{\theta^Tv|\theta\geq0,\sum_i\theta_i&#x3D;1}$$<br>例如，在$\mathbb{R}^{n}$<br>空间中，由两个点构造的凸包(线段)与三个点组成凸包(三角形)算是单纯形。但是四个点组成的凸包不是单纯形，因为在二维空间$\mathbb{R}^{n}$<br>中，四个点无法仿射独立。如下图</p><p><img src="https://www.freeimg.cn/i/2024/08/28/66cf43c764829.png" alt="例子"></p><p>求证：单纯形是多面体的一种          </p><p>定义</p><p>$$ y&#x3D;[\theta_{1},\ldots,\theta_{k}], y\geq0, 1^{T}y\leq1(因为y中舍弃了\theta_0) $$</p><p>$$B&#x3D;[v_{1}-v_{0},\ldots,v_{k}-v_{0}]\in R^{n\times k}$$</p><p>则单纯形中的点$x&#x3D;\theta_{0}v_{0}+\cdots+\theta_{k}v_{k}$可以写为<br>$$x&#x3D;\theta_{0}v_{0}+\cdots+\theta_{k}v_{k}&#x3D;v_{0}+\theta_{1}(v_{1}-v_{0})+\cdots+\theta_{k}(v_{k}-v_{0})&#x3D;v_{0}+By \quad (1)$$<br>由于$B$是列满秩的，也即$rank(B)&#x3D;k$,也就是说我们总能通过初等行变换把$B$变为$B&#x3D;\left[\begin{array}{c}{ {I_{k} } }\{0}\end{array}\right]$<br>用数学的语言描述，我们总能找到可逆矩阵$A$，使得<br>$$A&#x3D;\left[\begin{array}{c}{A_{1} }\{}\{A_{2} }\end{array}\right]\in R^{n\times n}, \left[\begin{array}{c}{A_{1} }\{}\{A_{2} }\end{array}\right]B&#x3D;\left[\begin{array}{c}{I_{k} }\{0}\end{array}\right]$$<br>1式两边左乘$A$<br>$$\left.Ax&#x3D;Av_0+ABy\Rightarrow\left[\begin{array}{c}A_1\\A_2\end{array}\right.\right]x&#x3D;\left[\begin{array}{c}A_1\\A_2\end{array}\right]v_0+\left[\begin{array}{c}I_k\\0\end{array}\right]y$$<br>利用$y\geq 0$, $1^{T}y\leq 1$,有$A_1x\geq A_{1}v_{0}$, $1^{T}A_{1}x\leq 1^{T}Av_{0}+ 1$<br>则单纯形中的 x 可以表示为${x\mid A_1x\geq A_1v_0$, 1$^TA_1x\leq1^TAv_0+1,A_2x&#x3D;A_2v_0}$</p><h3 id="一些矩阵"><a href="#一些矩阵" class="headerlink" title="一些矩阵"></a>一些矩阵</h3><ul><li>对称矩阵集合：$S^{n}&#x3D;{x\in R^{n\times n}\mid X&#x3D;X^{T}}$</li><li>半正定矩阵集合：$S_{+}^{n}&#x3D;{x\in R^{n\times n}\mid X&#x3D;X^{T}, X\succeq0}$</li><li>正定矩阵集合:$S_{++}^{n}&#x3D;{x\in R^{n\times n}\mid X&#x3D;X^{T}, X\succ0}$</li></ul><h1 id="保凸运算举例"><a href="#保凸运算举例" class="headerlink" title="保凸运算举例"></a>保凸运算举例</h1><h3 id="任意多个凸集的交集"><a href="#任意多个凸集的交集" class="headerlink" title="任意多个凸集的交集"></a>任意多个凸集的交集</h3><p>若$S_0$为凸集，$\forall a\in A$,则$\bigcap_{a\in A}S_a$为凸集</p><h3 id="仿射函数"><a href="#仿射函数" class="headerlink" title="仿射函数"></a>仿射函数</h3><p>当$f&#x3D; Ax+ b$, $A\in R^{m\times n}$, $b\in R^m$<br>若$S\in R^n$为凸，则$f(S)&#x3D;{f(x)\mid x\in S}$为凸，我们称$f:R^n\to R^m$ 是仿射的 (线性映射)</p><h3 id="缩放和移位"><a href="#缩放和移位" class="headerlink" title="缩放和移位"></a>缩放和移位</h3><p>$$\alpha S&#x3D;{\alpha x\mid x\in S}\quad S+a&#x3D;{x+a\mid x\in S}$$</p><h3 id="透视函数"><a href="#透视函数" class="headerlink" title="透视函数"></a>透视函数</h3><p>透视函数(perspective function):$P:R^{n+1}\to R^n,domP:R^n\times R_{++}$<br>$P( z, t) &#x3D; \frac zt$, $z\in R^n$, $t\in R_{+ + }$,凸集通过透视变换仍为凸集。</p><p>形象的理解P：一个n+1维向量保留前n维，同时除以被扔掉的n+1维得到新的向量</p><p>证明任意线段经过透视还是线段:</p><p>$x &#x3D; (\tilde{x},x_{n+1}), y &#x3D; (\tilde{y},y_{n+1}), \tilde{x},\tilde{y} \in R^{n}, x_{n+1},y_{n+1} \in R_{++}, \theta \geq 0$<br>$$\begin{aligned}<br>\begin{aligned}P(\theta x+(1-\theta)y)\end{aligned}&amp; \begin{aligned}&#x3D;\frac{\theta\tilde{x}+(1-\theta)\tilde{y}}{\theta x_{n+1}+(1-\theta)y_{n+1}}\end{aligned} \<br>&amp;\begin{aligned}&amp;&#x3D;\frac{\theta x_{n+1}}{\theta x_{n+1}+(1-\theta)y_{n+1}}\frac{\tilde{x}}{x_{n+1}}+\frac{(1-\theta)y_{n+1}}{\theta x_{n+1}+(1-\theta)y_{n+1}}\frac{\tilde{y}}{y_{n+1}}\end{aligned} \<br>&amp;&#x3D;\mu P(x)+(1-\mu)P(y)<br>\end{aligned}$$</p><h3 id="线性分数函数"><a href="#线性分数函数" class="headerlink" title="线性分数函数"></a>线性分数函数</h3><p>$A\in R^{m\times n},b\in R^{m},C\in R^{n},d\in R$，线性分数函数定义为<br>$$\begin{aligned}f(x)&#x3D;\frac{Ax+b}{cx+d}, domf&#x3D;{x\mid c^Tx+d&gt;0}\end{aligned}$$<br>这可以看成是对$x$进行两次集合运算得到的结果，先进行仿射变换<br>$$\delta(x)&#x3D;\left[\begin{array}{c}{A}\{c^{T}}\\end{array}\right]x+\left[\begin{array}{c}{b}\{d}\\end{array}\right]$$<br>再进行透视变换$P: R^{m+1}\to R^m$，因此两次保凸运算得到的结果依然是凸集</p><h1 id="参考文献-blog"><a href="#参考文献-blog" class="headerlink" title="参考文献&#x2F;blog"></a>参考文献&#x2F;blog</h1><ul><li><a href="https://www.bilibili.com/video/BV19M411T7S7?p=20&vd_source=84b977d2834d5eca6c0ca78bd619156f%EF%BC%8C%E4%B8%AD%E7%A7%91%E5%A4%A7/%E5%87%8C%E9%9D%92%E3%80%8A%E5%87%B8%E4%BC%98%E5%8C%96%E3%80%8B%EF%BC%8Cchapter1-9">https://www.bilibili.com/video/BV19M411T7S7?p=20&amp;vd_source=84b977d2834d5eca6c0ca78bd619156f，中科大/凌青《凸优化》，chapter1-9</a></li><li>知乎专栏，<a href="https://www.zhihu.com/column/c_1492543238217478144">https://www.zhihu.com/column/c_1492543238217478144</a></li><li>知乎专栏，<a href="https://zhuanlan.zhihu.com/c_1280779583399882752">https://zhuanlan.zhihu.com/c_1280779583399882752</a></li><li>《ConvexOptimizationnotes》，<a href="https://github.com/ZxyGed/ConvexOptimization%EF%BC%8CConvex_Sets">https://github.com/ZxyGed/ConvexOptimization，Convex_Sets</a> pdf笔记</li></ul>]]></content>
    
    
    <categories>
      
      <category>数学</category>
      
      <category>凸优化</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>对偶</title>
    <link href="/2025/03/21/%E6%95%B0%E5%AD%A6/%E5%87%B8%E4%BC%98%E5%8C%96/%E5%AF%B9%E5%81%B6/"/>
    <url>/2025/03/21/%E6%95%B0%E5%AD%A6/%E5%87%B8%E4%BC%98%E5%8C%96/%E5%AF%B9%E5%81%B6/</url>
    
    <content type="html"><![CDATA[<h1 id="对偶问题"><a href="#对偶问题" class="headerlink" title="对偶问题"></a>对偶问题</h1><h3 id="对偶问题定义"><a href="#对偶问题定义" class="headerlink" title="对偶问题定义"></a>对偶问题定义</h3><p>考虑一个一般的优化问题：</p><p>$$\begin{aligned}&amp;\min_x\quad f_0(x)\&amp;s.t.\quad f_i(x_0)\leq0,i&#x3D;1,\ldots,m\&amp;h_j(x)&#x3D;0,j&#x3D;1,\ldots,p\&amp;x\in R^n\end{aligned}$$</p><p>定义其<strong>拉格朗日函数</strong>为<br>$$L(x,\lambda,v)&#x3D;f_0(x)+\sum_{i&#x3D;1}^m\lambda_if_i(x)+\sum_{j&#x3D;1}^pv_jh_j(x),\lambda\in R^m,v\in R^p$$</p><p>拉格朗日<strong>对偶函数</strong>为<br>$$g(\lambda,v)&#x3D;\inf_{x\in D}L(x,\lambda,v)$$</p><p>我们可以观察到对偶函数的两条优良性质：</p><ul><li><strong>对偶函数一定为凹函数，不论原来的优化问题里面的函数是什么东西</strong>，因为对偶函数是由关于$\lambda$,$v$的仿射函数逐点取最小得到的，由上一节的知识我们知道凸函数逐点取最大依然是凸的，凹函数逐点取最小依然是凹的，而仿射函数作为凹函数与凸函数的分界函数，对它逐点取最大即可得到凸函数，对它逐点取最小即可得到凹函数。既然对偶函数是凹的，那么对其求$max$就一定是个凸问题了。</li><li>记$p^*$为原始问题的最优值，则$\forall\lambda\geq0,\forall v,$ 一定有$g(\lambda,v)\leq p^*$。这是容易理解的，因为$\forall\lambda\geq0$,必然有$\sum_{i&#x3D;1}^m\lambda_if_i(x)+\sum_{j&#x3D;1}^pv_jh_j(x) \leq 0$,自然得到$g(\lambda,v)\leq p^*$</li></ul><p>所以我们将对偶问题定义为<br>$$\begin{aligned}\max_{\lambda,v}&amp;&amp;g(\lambda,v)\s.t.&amp;&amp;\lambda\geq0\end{aligned}$$</p><p>【对偶函数为原问题的最优值定义了一个下界，而求解$max \ g(λ,v)$就是求解$p^*$的一个最好的下界。如果条件再好一点的话，这个下界还会等于$p^*$本身，这样就相当于把非凸问题转化为凸问题求解了。】</p><p>这里我们也可以理解为何要令$\lambda \geq 0$,因为只有这样才能满足$g(\lambda,v)\leq p^*$恒成立，才能使$max \ g(\lambda,v)$这一问题有意义，若是$\lambda &lt; 0$的话，$g(\lambda,v)$总可以取到正无穷，对偶问题也失去了意义。</p><h3 id="对偶问题举例"><a href="#对偶问题举例" class="headerlink" title="对偶问题举例"></a>对偶问题举例</h3><p>写出对偶问题关键在于消去$x$,一般采用求导的方法即可，举个例子<br>$$<br>\begin{aligned}<br>&amp;\min x^Tx \<br>&amp;s.\textit{t. }Ax&#x3D;b \<br>&amp;x\in R^n,b\in R^p.A\in R^{p\times n} \<br>&amp;\Rightarrow L(x,\lambda)&#x3D;x^Tx+v^T(Ax-b) \<br>&amp;\Rightarrow g(v)&#x3D;\inf_x{x^Tx+v^T(Ax-b)} \<br>&amp;&#x3D;\inf_x{x^Tx+v^TAx-v^Tb} \<br>&amp;&#x3D;-\frac14v^TAA^Tv-b^Tv<br>\end{aligned} $$</p><p> $min \ c^Tx$<br> $s. t.$ $Ax&#x3D; b$ $x\geq0$<br>$$L(x,\lambda,\eta)&#x3D;c^Tx-\lambda^Tx+\eta^T(Ax-b)$$<br>$$g(\lambda,\eta)&#x3D;\inf_{x\in\mathcal{D}}L(x,\lambda,\eta)$$<br>$$&#x3D;\inf_{x\in\mathcal{D}}c^Tx-\lambda^Tx+\eta^T(Ax-b)$$<br>$g(\lambda,\eta)$中是关于$x$的线性函数，如果系数不为0，则最小值为负无穷大，若系数为0，则<br>$g(\lambda,\eta)&#x3D;-\eta^Tb$这里对偶函数仍然是凹函数</p><h3 id="对偶问题性质"><a href="#对偶问题性质" class="headerlink" title="对偶问题性质"></a>对偶问题性质</h3><p>记原问题(Prime Problem)为$P$,<br>原问题对应的最优值记为$p^*$<br>记对偶问题为$D$,对偶问题对应的最优值为$d^*$</p><p>由上文我们已经知道$d^* \leq p^*$总是成立的，它被称为弱对偶性Weak Dual。当$d^*&#x3D;p^*$的时候，就叫做强对偶性(Strong Dual)。一个问题的对偶间隙(Dual Gap)指的就是$p^*-d^*$，是大于0的。</p><h1 id="slater条件"><a href="#slater条件" class="headerlink" title="slater条件"></a>slater条件</h1><p>我们不禁要问，什么时候才能满足强对偶条件呢？下面给出一个常用的判断强对偶关系的充分不必要条件:slater条件。为了方便阐述，先介绍一个定义:$D$的相对内部：$RelintD&#x3D;{x\in D|B(x,r)\cap affD\subset D,\exists r&gt;0}$，这里的定义不必深究，其几何意义指的是一个把$D$的边界去掉的开集</p><h3 id="1-slater条件"><a href="#1-slater条件" class="headerlink" title="1.slater条件"></a>1.slater条件</h3><p>若有凸问题（注意等式约束要是仿射的）<br>$$\begin{aligned}&amp;\min f_0(x)\&amp;s.t. f_i(x)\leq0,i&#x3D;1,\ldots,m\&amp;Ax&#x3D;b\end{aligned}$$<br>若$\exists x\in RelintD,s.t.f_i(x)&lt;0,i&#x3D;1,\ldots,m,Ax&#x3D;b$时，有$p^*&#x3D;d^*$<br>Slater条件就是说：如果你能从可行域$D$<br>的相对内部里能够找到一个点，使得这个点它严格可行的话(不等式严格成立)，那么强对偶性成立。</p><h3 id="2-弱slater条件"><a href="#2-弱slater条件" class="headerlink" title="2.弱slater条件"></a>2.弱slater条件</h3><p>若不等式约束$f_i(x) \leq 0$为仿射约束时，只要可行域非空，一定有$p^*&#x3D;d^*$</p><p><strong>推论：线性规划问题如果可行的话，必有强对偶性成立</strong></p><h3 id="几何解释"><a href="#几何解释" class="headerlink" title="几何解释"></a>几何解释</h3><p>假设当前优化问题为$\min$ $f_0( x) , s. t.$ $f_1( x) \leq 0$<br>$$\text{令}G&#x3D;{(f_1(x),f_0(x))|x\in\mathcal{D}}$$<br>简单起见，这里令$f_1(x)&#x3D;u,f_0(x)&#x3D;t$</p><p>则原问题最优值$p^\star&#x3D;\min t&#x3D;\min{t|(u,t)\in G|u\leq0}$</p><p>对偶问题最优值$d^\star&#x3D;\max_\lambda\min_x{t+\lambda u}$</p><p>这里$(u,t)$点集合$G$如下图所示，从几何关系可知，原问题最优值为$G$左侧最低点的纵坐<br>标。在这个空间中$t+\lambda u$为一条直线，$g(\lambda)$因为是对$x$取逐点最小得来的，所以<br>$t+\lambda u&#x3D;g(\lambda)$为与集合$G$下侧边缘相切的直线(直线从下方向上平移直到与$G$相切)。当$u&#x3D;0$时，$t&#x3D;g(\lambda)$是直线截距，也是对偶问题要最大化的目标。显然这个截距最大为$d^{\star}$ 时，仍然小于等于$p^\star$,所以弱对偶成立。</p><p>$G$形状如下不满足强对偶关系<br><img src="https://www.freeimg.cn/i/2024/09/02/66d5db2403c6c.png" alt="1725291297679.png"></p><p>$G$形状如下满足强对偶关系</p><p><img src="https://www.freeimg.cn/i/2024/09/02/66d5db390c853.png" alt="1725291318808.png"></p><h1 id="KKT条件"><a href="#KKT条件" class="headerlink" title="KKT条件"></a>KKT条件</h1><h3 id="极大极小不等式"><a href="#极大极小不等式" class="headerlink" title="极大极小不等式"></a>极大极小不等式</h3><p>我们都知道，优化问题的原问题可以记为<br>$$\begin{aligned}&amp;\min f_0(x)\&amp;s.t. f_i(x)\leq0\&amp;h_i(x)&#x3D;0\end{aligned}$$<br>在引入拉格朗日乘子后，原问题可以巧妙地写为另一种形式：$sup {  f_0(x)+ \sum\lambda_if_i(x) + \sum\eta_ih_i(x) }$，他事实上是原函数的一种拓展,因为<br>$$\sup_{\lambda\succeq0}{f_0(x)+\sum\lambda_if_i(x)  + \sum\eta_ih_i(x) }&#x3D;\left{\begin{array}{ll}f_0(x),&amp;f_i(x)\leq0\+\infty,&amp;otherwise\end{array}\right.$$<br>因此对原函数求min，可以转化为对上述函数求min，因此原问题的解可以等价的写为<br>$$p^*&#x3D;\inf_x\sup_{\lambda\succeq0}L(x,\lambda,\eta)$$<br>而我们又知道对偶问题的解可以写为<br>$$d^*&#x3D;\sup_{\lambda\succeq0}\inf_xL(x,\lambda,\eta)$$<br>因此自然的得到了不等式<br>$$\sup_{\lambda\succeq0,\eta}\inf_xL(x,\lambda,\eta)\leq\inf_x\sup_{\lambda\succeq0,\eta}L(x,\lambda,\eta)$$<br>这便是极大极小不等式，我们把对函数的第一个变量极小的结果记为$L(\tilde{x},\lambda)$,对第二个变量<br>方便起见，把极大的结果记为$L(x,\tilde{\lambda})$,上述不等式可写为<br>$$\sup_\lambda L(\tilde{x},\lambda)\leq\inf_xL(x,\tilde{\lambda})$$<br>如果一个点满足对函数第一个变量极大再对第二个变量极小的值等于先对第二个变量极大再<br>对第一个变量极小，那么这个点就称为这个函数的鞍点。也就是$\exists(\tilde{x},\tilde{\lambda}),s.t.{:}$<br>$$\sup_\lambda L(\tilde{x},\lambda)&#x3D;L(\tilde{x},\tilde{\lambda})&#x3D;\inf_xL(x,\tilde{\lambda})$$<br>从鞍点的定义就可以看出：如果一个优化问题的强对偶性成立，那么最优解就是拉格朗日函数的一个鞍点，反过，拉格朗日函数的鞍点就是使得强对偶性成立的点，所以是最优解，因此鞍点就等价于强对偶性成立的点等价于最优解。</p><h3 id="kkt条件"><a href="#kkt条件" class="headerlink" title="kkt条件"></a>kkt条件</h3><p>在强对偶关系满足的情况下，有以下几条性质。</p><ul><li><p>首先必须满足原问题的约束<br>假设该问题满足强对偶关系$p^\star&#x3D;d^\star$,且所有函数可微。则$x^\star,\lambda^\star,\eta^\star$是原问题、对偶问<br>题的最优解，满足如下可行条件(primal&#x2F;dual feasibility):<br>$$f_i(x^\star)\leq0$$<br>$$h_i(x^\star)&#x3D;0$$<br>$$\lambda^{\star}\geq0$$</p></li><li><p>根据强对偶关系进行不等式分析。<br>$$\begin{aligned}<br>&amp;d^{\star}&#x3D;\sup_{\lambda\geq0,\eta}\inf_{x\in\mathcal{D}}L(x,\lambda,\eta) \<br>&amp;\leq L(x^\star,\lambda^\star,\eta^\star) \<br>&amp;&#x3D;f(x^\star)+\sum_i\lambda_i^\star f_i(x^\star) \<br>&amp;\leq f(x^\star)&#x3D;p^\star<br>\end{aligned}$$<br>因此$\sum_i\lambda_i^\star f_i(x^\star)&#x3D;0$，这一条件叫做互补松弛条件。求和的每一项都是非负数与非正数的乘积，乘积结果必然非正数，现在求和结果为0，说明求和的每一项都是0，即两项的乘积项中至少有一项为0    </p></li><li><p>在上面的推导中，<br>第三行的不等式取了等号，这表明$x^\star$是$L(x,\lambda^\star)$的极小值点，则这点处偏导数为0。因此得到<br>$$\frac{\partial L(x,\lambda^\star,\eta^\star)}{\partial x}|_{x&#x3D;x^\star}&#x3D;0$$<br>这个条件叫做稳定点(stationary)<br>上面所讲的三个条件就是KKT条件</p></li></ul><p>我们此时梳理一下前面的推导，发现两件事实</p><ul><li>1.前面推导没有任何凸函数的假设，因此不论是否为凸问题，如果满足强对偶性，那么最优解一定满足 KKT 条件。</li><li>2.但是反过来不一定成立，也即 KKT 条件的解不一定是最优解，因为如果$L(x,\lambda^\star,\nu^\star)$不是凸的，那么$\nabla_xL&#x3D;0$并不能保证$g(\lambda^\star,\nu^\star)&#x3D;\inf_xL(x,\lambda^\star,\nu^\star)\neq L(x^\star,\lambda^\star,\nu^\star)$,也即不能保证 $x^\star,\lambda^\star,\nu^\star$ 就是鞍点。</li></ul><p>因此我们可以画出下面的图。<br><img src="https://www.freeimg.cn/i/2024/09/07/66dc4ee4ae279.png" alt="解集关系示意图"></p><p>当原问题为凸问题、各个函数可微、强对偶关系满足时，KKT条件是最优解的充要条件。举几个例子</p><p>例1：$\min$ $0.5x^TPx+q^Tx+r,P\in S_+^n$<br> $s. t.$ $Ax&#x3D; b$</p><p> 可行条件$Ax^\star&#x3D;b$</p><p>稳定点$\frac\partial{\partial x}{0.5x^TPx+q^Tx+r+(Ax-b)^T\eta^\star}|_{x&#x3D;x^\star}&#x3D;0$<br>$$Px^\star+q+A^T\eta^\star&#x3D;0$$<br> 将这两个等式写为线性方程组的形式<br>$$\begin{bmatrix}P&amp;A^T\A&amp;0\end{bmatrix}\begin{bmatrix}x^\star\\eta^\star\end{bmatrix}&#x3D;\begin{bmatrix}-q\b\end{bmatrix}$$<br> 解这个线性方程组即得到最优解</p><h3 id="敏感性分析"><a href="#敏感性分析" class="headerlink" title="敏感性分析"></a>敏感性分析</h3><p>如果我们求出了最优解，但是突然想对最优解做一些改动，看看有什么变化时，或者我们求不出最优解，想求一个差不多的解，，所以想看看理论上离最优解比较近的点它的最优值有什么特点时，就要从优化问题出发，分析问题的敏感性&#x2F;扰动分析。</p><p>原问题<br>$$\begin{aligned}&amp;\&amp;\min:f_0(x)\&amp;s.t.:f_i(x)\leq0,i&#x3D;1:m\&amp;h_i(x)&#x3D;0,i&#x3D;1:p\end{aligned}$$<br>干扰问题</p><p>$\min f_0(x)$</p><p>$s. t.$ $f_i\left ( x\right ) \leq u_i, i&#x3D; 1: m$<br>$h_i(x)&#x3D;w_i,i&#x3D;1:p$<br>考虑最优值可变化从$p^\star(0,0)$变为$p^\star(u,w)$<br>约束变化后，有以下性质：<br>性质1：若原问题为凸问题，则$p^\star(u,w)$为$(u,w)$的凸函数</p><p>性质2：若原问题为凸问题，且满足Slater条件，$\lambda^\star,\eta^\star$为对偶问题最优解，则<br>$$p^\star(u,w)\geq p^\star(0,0)-(\lambda^\star)^Tu-(\eta^\star)^Tw$$<br>这个性质有以下用法</p><ul><li>1)若$\lambda_i^\star$很大，且加紧第$i$项约束，则$p^\star(u,w)$急剧增加</li><li>2)若$\eta_i^*$为很大的正值，$w_i&lt;0$下降，或者相反若$\eta_i^\star$为很大的负值，$w_i&gt;0$上升，则<br>$p^{\star}(u,w)$急剧增加</li><li>3)若$\lambda_i^\star$很小，且$u_i&gt;0$,则$p^\star(u,w)$几乎不变</li><li>4)若$\eta_i^\star$为很小的正值，$w_i&gt;0$增加，或$\eta_i^\star$为很小的负值，$w_i&lt;0$下降，则$p^\star(u,w)$<br>几乎不变</li></ul><p>性质3：(局部敏感性)若原问题为凸问题，满足强对偶关系，且$p^\star(u,w)$在(0,0)处可<br>微<br>$$\lambda_i^\star&#x3D;-\frac{\partial p^\star(u,w)}{\partial u_i}\big|<em>{(0,0)}$$<br>$\eta</em>{i}^{\star}&#x3D;-\frac{\partial p^{\star}(u,w)}{\partial w_{i}}\left|_{(0,0)}\right.$</p><p>$p^{\star}(u,w)&#x3D;p^{\star}(0,0)-(\lambda^{\star})^Tu-(\eta^{\star})^Tw$</p><h1 id="罚函数法"><a href="#罚函数法" class="headerlink" title="罚函数法"></a>罚函数法</h1><p>在原约束条件不好处理的情况下，我们采用放松的约束方法添加罚函数项去近似该项约束。</p><p>一种是把约束惩罚到目标函数上去，比如范数平方，log-barrier，这种我感觉更多的像是一种求近似解的手段。当约束不太好的时候，罚到目标函数上去，变成无约束优化问题，也许它的对偶问题就好求了。而且一般加到目标函数会带一个惩罚因子，一方面是为了保证最优值不变，另一方面也会影响新问题和原问题最优解之间的关系。另一种是单纯的额外加一个罚项，就像是针对自变量xxx增加的一种约束，使得变量的各个分量之间距离不会太大&#x2F;稀疏。</p><h3 id="平方项罚函数"><a href="#平方项罚函数" class="headerlink" title="平方项罚函数"></a>平方项罚函数</h3><p>$\min f_0(x)$</p><p>$s. t.$ $Ax- b&#x3D; 0$</p><p>把约束惩罚到目标函数</p><p>$\operatorname* { min} f_{0}( x) + \frac \alpha 2| Ax- b| _{2}^{2}$, $\alpha \geq 0$</p><p>假设新问题的最优解为$\tilde{x}$,则$\nabla f_0(\tilde{x})+\alpha A^T(A\tilde{x}-b)&#x3D;0$<br>而这样的话$\tilde{x}$就也会是$\min$ $f_0( x) + \alpha ( A\tilde{x} - b) ^T( Ax- b)$的最优解。<br>现在计算下原问题的对偶函数$g(v)&#x3D;\inf_x{f_0(x)+v^TAx-v^Tb}$,知如果<br>$v&#x3D;\alpha(A\tilde{x}-b)$时，对偶函数$g(v)$就和$f_0(x)+\alpha(A\tilde{x}-b)^T(Ax-b)$等价了。又因为<br>对偶问题最优解$d^<em>\geq g(v)$,因此可以得到<br>$$f_0(x^</em>)&#x3D;p^*&#x3D;d^*\geq g(\alpha(A\tilde{x}-b))&#x3D;f_0(\tilde{x})+\alpha|A\tilde{x}-b|_2^2\geq f_0(\tilde{x})$$</p><h3 id="log-barrier法"><a href="#log-barrier法" class="headerlink" title="log-barrier法"></a>log-barrier法</h3><p>$$<br>\begin{aligned}<br>&amp;\min f_0(x) \<br>&amp;s.t. Ax\geq b,x\in R^m,A\in R^{m\times n},b\in R^m \<br>&amp;\text{log-barrier法:} \<br>&amp;\min f_0(x)-\sum_{i&#x3D;1}^mu\log(a^Tx-b_i)<br>\end{aligned}<br>$$</p>]]></content>
    
    
    <categories>
      
      <category>数学</category>
      
      <category>凸优化</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>template:base</title>
    <link href="/2025/02/11/%E7%AE%97%E6%B3%95/%E5%9F%BA%E7%A1%80%E6%A8%A1%E7%89%88/"/>
    <url>/2025/02/11/%E7%AE%97%E6%B3%95/%E5%9F%BA%E7%A1%80%E6%A8%A1%E7%89%88/</url>
    
    <content type="html"><![CDATA[<h1 id="快排"><a href="#快排" class="headerlink" title="快排"></a>快排</h1><p>一般使用c++ stl即可，同时可以使用自定义cmp函数。<code>std::sort</code>在最坏情况下保持$O(n log n)$时间复杂度，主流编译器采用<code>introsort</code>（快速排序+堆排序混合算法）实现</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> a%<span class="hljs-number">3</span> &lt; b%<span class="hljs-number">3</span>; <span class="hljs-comment">// 按模3余数升序</span><br>&#125;<br><span class="hljs-built_in">sort</span>(a, a+n, cmp);<br></code></pre></td></tr></table></figure><h1 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h1><p>所谓归并，先递归，再合并。递归的解决两个子数组的排序的子问题，再合并出最终答案。<br>每一层需要合并n个元素。比如，第一层是合并两个n&#x2F;2的数组，总共有n个元素。不管层数如何，每一层的合并操作都是$O(n)$的时间。而总共有$log n$层，所以总的时间复杂度应该是$O(n log n)$<br><a href="https://imgse.com/i/pEnTeWd"><img src="https://s21.ax1x.com/2025/02/11/pEnTeWd.md.jpg" alt="pEnTeWd.md.jpg"></a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//用于存放合并结果，开一个数组temp</span><br><span class="hljs-type">int</span> temp[N];<br><span class="hljs-comment">//解决[l,r]区间内a数组的排序问题</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">merge_sort</span><span class="hljs-params">(<span class="hljs-type">int</span> a[],<span class="hljs-type">int</span> l,<span class="hljs-type">int</span> r)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//设置出口</span><br>    <span class="hljs-keyword">if</span>(l&gt;=r) <span class="hljs-keyword">return</span>;<br><br>    <span class="hljs-comment">//划分数组</span><br>    <span class="hljs-type">int</span> mid=l+r&gt;&gt;<span class="hljs-number">1</span>;<br><br>    <span class="hljs-comment">//递归到子问题-&gt;变区间</span><br>    <span class="hljs-built_in">merge_sort</span>(a,l,mid);<br>    <span class="hljs-built_in">merge_sort</span>(a,mid<span class="hljs-number">+1</span>,r);<br><br>    <span class="hljs-comment">//此时子问题已经解决，合并两个有序数组</span><br>    <span class="hljs-type">int</span> k=<span class="hljs-number">0</span>,i=l,j=mid<span class="hljs-number">+1</span>;<br>    <span class="hljs-comment">//同时遍历两个有序数组，依次把小元素填入temp中</span><br>    <span class="hljs-keyword">while</span>(i&lt;=mid&amp;&amp;j&lt;=r)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(a[i]&lt;a[j]) temp[k++]=a[i++];<br>        <span class="hljs-keyword">else</span> temp[k++]=a[j++];<br>    &#125;<br><br>    <span class="hljs-comment">//哪个数组还有剩余，直接填入temp</span><br>    <span class="hljs-keyword">while</span>(i&lt;=mid) temp[k++]=a[i++];<br>    <span class="hljs-keyword">while</span>(j&lt;=r) temp[k++]=a[j++];<br><br>    <span class="hljs-comment">//此时temp存储了[l,r]区间内a数组的排序结果，填回a数组的[l,r]区间即可</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>,j=l;j&lt;=r;i++,j++) a[j]=temp[i];<br>&#125;<br></code></pre></td></tr></table></figure><p>归并排序的经典应用是求给定数组中数组逆序对的个数                  </p><p>采用归并的思想，<br>注意到逆序对可以分成<strong>三类</strong>：</p><ul><li>两个元素都在左边；</li><li>两个元素都在右边；</li><li>两个元素一个在左一个在右；</li></ul><p>归的过程依然包含了前两种逆序对<br>因此我们在并的过程中考虑<strong>两个元素一个在左一个在右</strong>这一情况贡献的新逆序对即可</p><p>注意我们在统计逆序对的过程中要同时进行排序，这样做的好处是保持左右子数组有序的同时，可以快速判断剩余元素的逆序关系:当 $a[i] &gt; a[j]$ 时,逆序对增量&#x3D; $mid - i + 1$.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">1e5</span><span class="hljs-number">+10</span>;<br><span class="hljs-type">int</span> temp[N];<br><span class="hljs-function"><span class="hljs-type">long</span> <span class="hljs-type">long</span> <span class="hljs-title">merge_sort</span><span class="hljs-params">(<span class="hljs-type">int</span> a[],<span class="hljs-type">int</span> l,<span class="hljs-type">int</span> r)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//设置出口</span><br>    <span class="hljs-keyword">if</span>(l&gt;=r) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">//划分数组</span><br>    <span class="hljs-type">int</span> mid = (r+l)&gt;&gt;<span class="hljs-number">1</span>;<br><br>    <span class="hljs-comment">//递归到子问题，统计子问题的独立逆序对</span><br>    <span class="hljs-type">long</span> <span class="hljs-type">long</span> cnt=<span class="hljs-built_in">merge_sort</span>(a,l,mid)+<span class="hljs-built_in">merge_sort</span>(a,mid<span class="hljs-number">+1</span>,r);<br><br>    <span class="hljs-comment">//统计两个子问题的互逆序对</span><br>    <span class="hljs-type">int</span> k=<span class="hljs-number">0</span>,i=l,j=mid<span class="hljs-number">+1</span>;<br>    <span class="hljs-keyword">while</span>(i&lt;=mid&amp;&amp;j&lt;=r)<br>    &#123;<br>        <span class="hljs-comment">//正序，不贡献新的逆序对</span><br>        <span class="hljs-keyword">if</span>(a[i]&lt;=a[j]) temp[k++]=a[i++];<br>        <span class="hljs-comment">//i,j逆序，则从此序号i开始到mid必然都与j形成逆序对逆序对，共计贡献mid-1+1个逆序对</span><br>        <span class="hljs-keyword">else</span>&#123;<br>            cnt+=mid-i<span class="hljs-number">+1</span>;<br>            temp[k++]=a[j++];<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">//剩余处理</span><br>    <span class="hljs-keyword">while</span>(i&lt;=mid) temp[k++]=a[i++];<br>    <span class="hljs-keyword">while</span>(j&lt;=r) temp[k++]=a[j++];<br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>,j=l;j&lt;=r;i++,j++) a[j]=temp[i];<br>    <span class="hljs-keyword">return</span> cnt;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>逆序对可以做很多事，比如最少交换次数问题:</p><p>超市货架上商品当前排列顺序为 [5,3,2,4,1]（商品ID），目标顺序为 [1,2,3,4,5]。每次只能交换相邻商品，求最小交换次数?</p><p>因为每次交换相邻元素最多减少1个逆序对，所以此问题只需要求出逆序对个数即可。</p><h1 id="二分"><a href="#二分" class="headerlink" title="二分"></a>二分</h1><p>二分法是基于解空间单调性提出的经典算法<br>二分是重要且朴素的思想，大致分为浮点二分和整数二分问题<br>浮点二分很好写，不断判断l和r谁更新为mid即可     </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//求三次方根</span><br><span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">b_search</span><span class="hljs-params">(<span class="hljs-type">double</span> n)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">double</span> l=<span class="hljs-number">-10000</span>,r=<span class="hljs-number">10000</span>,mid=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>((r-l)&gt;<span class="hljs-number">1e-8</span>)<br>    &#123;<br>        <span class="hljs-type">double</span> mid =(l+r)/<span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span>(mid*mid*mid&gt;n) r=mid;<br>        <span class="hljs-keyword">else</span> l=mid;<br>    &#125;<br>    <span class="hljs-keyword">return</span> r;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>整数二分需要考虑边界问题，对应有两种模版在下面写出。笔者认为采用一种名为”自然写法的”编码方式逻辑更清楚。所谓自然写法，意指写好check函数后自然地判断其后跟随的更新法则，根据$r&#x3D;mid$还是$l&#x3D;mid$,判断下一句是$l&#x3D;mid+1$亦或$r&#x3D;mid-1$,这种逻辑上的必然性是由<code>check</code>函数必须是闭集合的约定带来的。这样做有三个好处。</p><ul><li>递归结束后必然有$l&#x3D;r&#x3D;mid$</li><li>两种不同写法都可找到满足题目需求的解，同时使用两种模版可以解决一种区间问题（见其后的例题）</li><li>只需要记忆:当<code>check</code>后面跟的是<code>l=mid</code>，则前面$mid$的更新需要$+1$变为(<code>mid = (l+r+1)&gt;&gt;1</code>)，如此便可以完全防止死循环!</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c++"><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">check</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<span class="hljs-comment">/* ... */</span>&#125; <br><span class="hljs-comment">// 检查x是否满足某种性质(与mid相关联)，这个检查逻辑应该包含我们所需要的逻辑，是一个闭区间。</span><br><span class="hljs-comment">// 举个例子，如果寻找升序数组中5的位置，那么check应该写为a[mid]&gt;=5或者a[mid]&lt;=5，而不是a[mid]&gt;5或者a[mid]&lt;5</span><br><br><span class="hljs-comment">// 这种写法事实上对应:区间[l, r]被划分成[l, mid]和[mid + 1, r]</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">bsearch_1</span><span class="hljs-params">(<span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">while</span> (l &lt; r)<br>    &#123;<br>        <span class="hljs-type">int</span> mid = l + r &gt;&gt; <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">check</span>(mid)) r = mid;    <span class="hljs-comment">// check()判断mid是否满足性质</span><br>        <span class="hljs-keyword">else</span> l = mid + <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> l;<br>&#125;<br><span class="hljs-comment">// 这种写法事实上对应:区间[l, r]被划分成[l, mid - 1]和[mid, r]</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">bsearch_2</span><span class="hljs-params">(<span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">while</span> (l &lt; r)<br>    &#123;<br>        <span class="hljs-type">int</span> mid = l + r + <span class="hljs-number">1</span> &gt;&gt; <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">check</span>(mid)) l = mid;<br>        <span class="hljs-keyword">else</span> r = mid - <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> l;<br>&#125;<br></code></pre></td></tr></table></figure><p>考虑一道经典的问题  </p><p>给定一个按照升序排列的长度为 n的整数数组，以及 q个查询。<br>对于每个查询，返回一个元素 k的起始位置和终止位置（位置从 0开始计数）。<br>如果数组中不存在该元素，则返回 -1 -1。</p><h4 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h4><p>第一行包含整数 n 和 q，表示数组长度和询问个数。<br>第二行包含 n个整数（均在 1∼10000范围内），表示完整数组。<br>接下来 q 行，每行包含一个整数 k，表示一个询问元素。     </p><h4 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h4><p>共 q行，每行包含两个整数，表示所求元素的起始位置和终止位置。<br>如果数组中不存在该元素，则返回 -1 -1<br>一般模版</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cmath&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">1e5</span><span class="hljs-number">+10</span>;<br><span class="hljs-type">int</span> n,q,a[N];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">bl_search</span><span class="hljs-params">(<span class="hljs-type">int</span> k)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> l=<span class="hljs-number">0</span>,r=n<span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">while</span>(r&gt;l)<br>    &#123;<br>        <span class="hljs-type">int</span> mid=r+l&gt;&gt;<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span>(a[mid]&gt;=k) r=mid;<br>        <span class="hljs-keyword">else</span> l=mid<span class="hljs-number">+1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> l;<br>&#125;<br><span class="hljs-comment">//check写成a[mid]&lt;=k,则区间被分为区间[l, r]被划分成[l, mid-1和[mid, r],为什么呢</span><br>    <span class="hljs-comment">//如果check满足，则mid作为左区间可以保留</span><br>    <span class="hljs-comment">//如果check不满足，则mid作为右区间必然满足，需要-1</span><br>    <span class="hljs-comment">//我们自然地写出了</span><br>    <span class="hljs-comment">/*if(a[mid]&gt;=k) l=mid;</span><br><span class="hljs-comment">        else r=mid-1; */</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">br_search</span><span class="hljs-params">(<span class="hljs-type">int</span> k)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> l=<span class="hljs-number">0</span>,r=n<span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">while</span>(r&gt;l)<br>    &#123;<br>        <span class="hljs-type">int</span> mid = l+r<span class="hljs-number">+1</span>&gt;&gt;<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span>(a[mid]&lt;=k) l=mid;<br>        <span class="hljs-keyword">else</span> r=mid<span class="hljs-number">-1</span>;<br><br>    &#125;<br>    <span class="hljs-keyword">return</span> l;<br>&#125;<br><span class="hljs-comment">//如何判断谁输出了左右边界？看谁在左右边界的取舍更保守，更准确即可，事实上我们可以发现else后跟的语句是严格的边界判断，check后跟的是正确但未必在边界上的判断</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">(<span class="hljs-type">int</span> k)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> l=<span class="hljs-built_in">bl_search</span>(k);<br>    <span class="hljs-keyword">if</span> (a[l]!=k) &#123;<br>        cout&lt;&lt;<span class="hljs-string">&quot;-1 -1\n&quot;</span>;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d %d\n&quot;</span>,<span class="hljs-built_in">bl_search</span>(k),<span class="hljs-built_in">br_search</span>(k));<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;n,&amp;q);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++) <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;a[i]);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;q;i++)<br>    &#123;<br>        <span class="hljs-type">int</span> k;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;k);<br>        <span class="hljs-built_in">solve</span>(k);<br>    &#125;<br><br>&#125;<br><br></code></pre></td></tr></table></figure><h1 id="前缀与差分"><a href="#前缀与差分" class="headerlink" title="前缀与差分"></a>前缀与差分</h1><p>不用刻意背，作为一种思路可以写出来，记住要写前缀或者差分的时候，下标从1开始</p><h4 id="一维前缀和-——-模板题-AcWing-795-前缀和"><a href="#一维前缀和-——-模板题-AcWing-795-前缀和" class="headerlink" title="一维前缀和 —— 模板题 AcWing 795. 前缀和"></a>一维前缀和 —— 模板题 AcWing 795. 前缀和</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c">S[i] = a[<span class="hljs-number">1</span>] + a[<span class="hljs-number">2</span>] + ... a[i]<br>a[l] + ... + a[r] = S[r] - S[l - <span class="hljs-number">1</span>]<br></code></pre></td></tr></table></figure><h4 id="二维前缀和-——-模板题-AcWing-796-子矩阵的和"><a href="#二维前缀和-——-模板题-AcWing-796-子矩阵的和" class="headerlink" title="二维前缀和 —— 模板题 AcWing 796. 子矩阵的和"></a>二维前缀和 —— 模板题 AcWing 796. 子矩阵的和</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c">S[i, j] = 第i行j列格子左上部分所有元素的和<br>以(x1, y1)为左上角，(x2, y2)为右下角的子矩阵的和为：<br>S[x2, y2] - S[x1 - <span class="hljs-number">1</span>, y2] - S[x2, y1 - <span class="hljs-number">1</span>] + S[x1 - <span class="hljs-number">1</span>, y1 - <span class="hljs-number">1</span>]<br></code></pre></td></tr></table></figure><h4 id="一维差分-——-模板题-AcWing-797-差分"><a href="#一维差分-——-模板题-AcWing-797-差分" class="headerlink" title="一维差分 —— 模板题 AcWing 797. 差分"></a>一维差分 —— 模板题 AcWing 797. 差分</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">给区间[l, r]中的每个数加上c：B[l] += c, B[r + <span class="hljs-number">1</span>] -= c<br></code></pre></td></tr></table></figure><h4 id="二维差分-——-模板题-AcWing-798-差分矩阵"><a href="#二维差分-——-模板题-AcWing-798-差分矩阵" class="headerlink" title="二维差分 —— 模板题 AcWing 798. 差分矩阵"></a>二维差分 —— 模板题 AcWing 798. 差分矩阵</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c">给以(x1, y1)为左上角，(x2, y2)为右下角的子矩阵中的所有元素加上c：<br>S[x1, y1] += c, S[x2 + <span class="hljs-number">1</span>, y1] -= c, S[x1, y2 + <span class="hljs-number">1</span>] -= c, S[x2 + <span class="hljs-number">1</span>, y2 + <span class="hljs-number">1</span>] += c<br></code></pre></td></tr></table></figure><h1 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++">求n的第k位数字(n从第零位开始计): n &gt;&gt; k &amp; <span class="hljs-number">1</span><br>返回n的最后一位<span class="hljs-number">1</span>：<span class="hljs-built_in">lowbit</span>(n) = n &amp; -n<br></code></pre></td></tr></table></figure><h1 id="双指针算法"><a href="#双指针算法" class="headerlink" title="双指针算法"></a>双指针算法</h1><p>双指针算法的本质是利用了问题的某种单调性，使得两个指针仅有可能单向移动，对大循环搜索进行了优化,将时间复杂度从$O(n^2)$优化至$O(n)$<br>我们需要考虑的是，如何移动指针，可以利用上问题的某种单调性。写法的基本框架就是在某一个指针的大循环下写另一个指针的while移动</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>, j = <span class="hljs-number">0</span>; i &lt; n; i ++ )<br>&#123;<br>    <span class="hljs-keyword">while</span> (j &lt; i &amp;&amp; <span class="hljs-built_in">check</span>(i, j)) j ++ ;<br><br>    <span class="hljs-comment">// 具体问题的逻辑</span><br>&#125;<br></code></pre></td></tr></table></figure><p>一类问题是两个指针遍历两个区间：<br>给定两个升序排序的有序数组$A$和$B$,以及一个目标值$x$。</p><p>数组下标从 0 开始。</p><p>请你求出满足$A[i]+B[j]&#x3D;x$的数对$(i,j)$。<br>(保证问题只有一个解)               </p><p>基本思路为:维护两个指针i,j,分别用于正序，倒序遍历a，b。外层大循环递增i，对于当前的i判断<code>a[i]+b[j]</code>与<code>x</code>的关系，当<code>a[i]+b[j])&gt;x</code>时，不断递减j直到<code>a[i]+b[j])&lt;=x</code>,此时判断:若<code>a[i]+b[j])==x</code>则答案已经找到。若<code>a[i]+b[j])&lt;x</code>则说明当下的i没有对应的j组成答案，需要对下一个i进行判断。</p><p>问题的单调性在于对于之前的i抛弃的j，新递增出来的i也依然用不上这些j。这是升序数组带来的显然结果。因此我们可以保证，i和j只需要单向移动。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//双指针算法的本质是利用了问题的某种单调性，使得两个指针仅有可能单向移动。</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1e5</span><span class="hljs-number">+10</span>;<br><span class="hljs-type">int</span> a[N],b[N],n,m,x;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d&quot;</span>,&amp;n,&amp;m,&amp;x);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++) <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;a[i]);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;m;i++) <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;b[i]);<br>    <span class="hljs-type">int</span> j=m<span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)<br>    &#123;<br>        <span class="hljs-keyword">while</span>((a[i]+b[j])&gt;x) j--;<br>        <span class="hljs-keyword">if</span>((a[i]+b[j])==x) <br>        &#123;<br>            cout&lt;&lt;i&lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;j;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        <br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><p>另一类问题是用两个指针维护某一个区间，比如经典的求<strong>最长不重复子序列的长度</strong>问题</p><p>基本思路</p><p>我们需要维护一个状态数组<code>s[N]</code>表示当前维护的区间里某个数出现了多少次       </p><p>维护两个指针i,j分别代表当前区间的左右端点。初始i&#x3D;0,j&#x3D;0。令j一次一次的往外扩展，每一次扩展都要判断扩展后区间是否有重复，如果有，则令i向前扩展，直到追上j或者把重复的元素排出了当前区间为止。</p><p>重复上述操作，循环内不断更新最大数组长度res</p><p>本问题中我们使用到的单调性来源于连续不重复这一约定，这致使i,j有且仅有可能单向向左移动。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1e5</span><span class="hljs-number">+10</span>;<br><span class="hljs-type">int</span> n,a[N],s[N]=&#123;<span class="hljs-number">0</span>&#125;;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cin&gt;&gt;n;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++) cin&gt;&gt;a[i];<br>    <span class="hljs-type">int</span> i=<span class="hljs-number">0</span>,res=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;n;j++)<br>    &#123;<br>        s[a[j]]++;<br>        <span class="hljs-keyword">if</span>(s[a[j]]&gt;<span class="hljs-number">1</span>)<br>        &#123;<br>            <span class="hljs-keyword">while</span>(i&lt;j&amp;&amp;s[a[j]]&gt;<span class="hljs-number">1</span>)<br>            &#123;<br>                s[a[i]]--;<br>                i++;  <br>            &#125;<br>        &#125;<br>        res=<span class="hljs-built_in">max</span>(res,j-i<span class="hljs-number">+1</span>);<br>    &#125;<br>    cout&lt;&lt;res;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="离散化-坐标映射"><a href="#离散化-坐标映射" class="headerlink" title="离散化(坐标映射)"></a>离散化(坐标映射)</h1><p>离散化的思想是映射，把大数映射到小数，无穷映射到有穷，笔者比较喜欢直接使用<code>c++stl</code>的<code>hash</code>来做   </p><p>看一道题         </p><p>假定有一个无限长的数轴，数轴上每个坐标上的数都是0。<br>现在，我们首先进行$n$次操作，每次操作将某一位置$x$上的数加$c$。<br>接下来，进行$m$次询问，每个询问包含两个整数$l$和$r$,你需要求出在区间$[l,r]$之间的所有数的和</p><h4 id="输入格式-1"><a href="#输入格式-1" class="headerlink" title="输入格式"></a>输入格式</h4><p>第一行包含两个整数$n$和$m$。<br>接下来$n$行，每行包含两个整数$x$和$c$。<br>再接下来$m$行，每行包含两个整数$l$和$r$。<br> 输出格式<br>共$m$行，每行输出一个询问中所求的区间内数字和。</p><h4 id="解答："><a href="#解答：" class="headerlink" title="解答："></a>解答：</h4><p>把所有坐标直接存下来？太大，不现实。我们事实上用到的坐标是什么？其实是每一组r,l,x 因此把所有的r,l,x都存到一个数组里面按升序排列好，取数组的脚标为新的坐标并排列好，原来的r，l处赋值为0，x处赋值+&#x3D;c，求前缀和即可<br>有了思路，想想我们要开多少vector或者hashmap来存储需要的数据与关系？<br><code>unordered_map&lt;int,int&gt; vtoi</code> 记录大坐标与小坐标的映射关系</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">typedef</span> pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt; pii;<br>vector&lt;<span class="hljs-type">int</span>&gt; alls; 记录用到的所有坐标<br>vector&lt;pii&gt; query; 记录所有要求的区间和<br>vector&lt;pii&gt; adds; 记录所有要加c的x<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1e6</span>;<br><span class="hljs-type">int</span> a[N]=&#123;<span class="hljs-number">0</span>&#125;,s[N]=&#123;<span class="hljs-number">0</span>&#125;;<br>unordered_map&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt; vtoi;<br><span class="hljs-keyword">typedef</span> pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt; pii;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n,m;<br>    cin&gt;&gt;n&gt;&gt;m;<br>    vector&lt;<span class="hljs-type">int</span>&gt; alls;<br>    vector&lt;pii&gt; query;<br>    vector&lt;pii&gt; adds;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)<br>    &#123;<br>        <span class="hljs-type">int</span> x,c;<br>        cin&gt;&gt;x&gt;&gt;c;<br>        alls.<span class="hljs-built_in">push_back</span>(x);<br>        adds.<span class="hljs-built_in">push_back</span>(&#123;x,c&#125;);<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;m;i++)<br>    &#123;<br>        <span class="hljs-type">int</span> l,r;<br>        cin&gt;&gt;l&gt;&gt;r;<br>        alls.<span class="hljs-built_in">push_back</span>(l);<br>        alls.<span class="hljs-built_in">push_back</span>(r);<br>        query.<span class="hljs-built_in">push_back</span>(&#123;l,r&#125;);<br><br>    &#125;<br>    <span class="hljs-comment">//排序并去重</span><br>    <span class="hljs-built_in">sort</span>(alls.<span class="hljs-built_in">begin</span>(),alls.<span class="hljs-built_in">end</span>());<br>    alls.<span class="hljs-built_in">erase</span>(<span class="hljs-built_in">unique</span>(alls.<span class="hljs-built_in">begin</span>(),alls.<span class="hljs-built_in">end</span>()),alls.<span class="hljs-built_in">end</span>());<br><br>    <span class="hljs-comment">//因为要使用前缀和，这里脚标映射为i+1</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;alls.<span class="hljs-built_in">size</span>();i++)<br>    &#123;<br>        vtoi[alls[i]]=i<span class="hljs-number">+1</span>;<br>    &#125;<br>    <span class="hljs-comment">//为有穷坐标赋值</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> add:adds)<br>    &#123;<br>        <span class="hljs-type">int</span> x = add.first;<br>        <span class="hljs-type">int</span> c = add.second;<br>        a[vtoi[x]]+=c;<br>    &#125;<br>    <span class="hljs-comment">//求前缀和</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=alls.<span class="hljs-built_in">size</span>();i++)<br>    &#123;<br>        s[i]=s[i<span class="hljs-number">-1</span>]+a[i];<br>    &#125;<br>    <span class="hljs-comment">//解决问题</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> q:query)<br>    &#123;<br>        <span class="hljs-type">int</span> l =vtoi[q.first];<br>        <span class="hljs-type">int</span> r =vtoi[q.second];<br>        cout &lt;&lt;s[r]-s[l<span class="hljs-number">-1</span>]&lt;&lt;endl;<br>    &#125;<br><br>&#125;<br><br></code></pre></td></tr></table></figure><h1 id="区间合并"><a href="#区间合并" class="headerlink" title="区间合并"></a>区间合并</h1><p>给n个区间，求n个区间合并之后的区间个数？<br>基本思路，先cin所有区间，利用sort优先左端点排序。<br>然后定义ed为我们此时维护的区间的末尾，每次如果ed大于a[i].first,则此ai可以合并，更新ed<br>否则，此ai不可合并，更新ed并ans++</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1e5</span><span class="hljs-number">+10</span>;<br><span class="hljs-keyword">typedef</span> pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt; pii;<br>pii a[N];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n;<br>    cin&gt;&gt;n;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++) <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;a[i].first,&amp;a[i].second);<br>    <span class="hljs-built_in">sort</span>(a,a+n);<br>    <span class="hljs-type">int</span> res=<span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> l=a[<span class="hljs-number">0</span>].first,r=a[<span class="hljs-number">0</span>].second;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;n;i++)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(a[i].first&gt;r) <br>        &#123;<br>            res++;<br>            l = a[i].first;<br>            r = a[i].second;<br>        &#125;<br>        r=<span class="hljs-built_in">max</span>(r,a[i].second);<br>    &#125;<br>    res++;<br>    cout&lt;&lt;res;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法竞赛</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ng-决策树</title>
    <link href="/2024/07/12/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/ng%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    <url>/2024/07/12/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/ng%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h2 id="特征选择算法"><a href="#特征选择算法" class="headerlink" title="特征选择算法"></a>特征选择算法</h2><p>我们希望选择具有良好分类能力的特征，为此我们引入信息增益来衡量不纯度</p><p>设$X$是取有限个值的随机变量，则概率分布为<br>$$P(X&#x3D;x_i)&#x3D;p_i,\quad i&#x3D;1,2,\cdots,n$$<br>定义随机变量$X$的熵为<br>$$H(X)&#x3D;-\sum_{i&#x3D;1}^np_i\log p_i$$<br>log以2为底时，熵的单位是比特，以e为底时，熵的单位是纳特。<br>若随机变量只取两个值(伯努利分布)，熵可以写为关于p的函数<br>$$H(p)&#x3D;-p\log p-(1-p)\log(1-p)$$<br><img src="https://www.freeimg.cn/i/2024/07/12/66911e3d36a2e.png" alt="1720786491668.png"></p><h3 id="Information-gain信息增益"><a href="#Information-gain信息增益" class="headerlink" title="Information gain信息增益"></a>Information gain信息增益</h3><p>一般的，定义 (信息增益) 特征$A$对训练数据集$D$的信息增益$g(D,A)$,定义为集<br>合$D$的经验熵$H(D)$与特征$A$给定条件下$D$的经验条件熵$H(D|A)$之差，即<br>$$g(D,A)&#x3D;H(D)-H(D|A)$$</p><ul><li>在决策树的二叉树场景下，上式可写为<br>$$&#x3D;\mathrm{H}(\mathrm{p}_1^{\mathrm{root}}):-\left(w^{\mathrm{left}}H\left(p_1^{\mathrm{left}}\right)+w^{\mathrm{right}}H\left(p_1^{\mathrm{right}}\right)\right)$$</li></ul><p>我们总是选择信息增益更大的决策A用于树的生成。</p><h3 id="数学描述"><a href="#数学描述" class="headerlink" title="数学描述"></a>数学描述</h3><p>设训练数据集为$D$,$|D|$表示其样本容量，即样本个数。设有$K$个类$C_k,k&#x3D;$ $1,2,\cdots,K$,$|C_k|$为属于类$C_k$的样本个数，$\sum|C_k|&#x3D;|D|$。设特征$A$有$n$个不同的<br>$k&#x3D;1$<br>取值${a_1,a_2,\cdots,a_n}$,根据特征$A$的取值将$D$ 划 分 为 $n$个子集$D_1,D_2,\cdots,D_n,|D_i|$ 为$D_i$的样本个数，$\sum_i^n|D_i|&#x3D;|D|$。记子集$D_i$中属于类$C_k$的样本的集合为$D_{ik}$,即<br>$i&#x3D;1$<br>$D_{ik}&#x3D;D_i\cap C_k,\left|D_{ik}\right|$为$D_{ik}$ 的样本个数。于是信息增益的算法如下。</p><p> (1)计算数据集$D$的经验熵$H(D)$，这代表原始数据集的混乱程度（直接按照将要预测特征求熵）<br>$$H(D)&#x3D;-\sum_{k&#x3D;1}^K\frac{|C_k|}{|D|}\log_2\frac{|C_k|}{|D|}$$<br>(2)计算特征$A$对数据集$D$的经验条件熵$H(D|A)$<br>$$H(D|A)&#x3D;\sum_{i&#x3D;1}^n\frac{|D_i|}{|D|}H(D_i)&#x3D;-\sum_{i&#x3D;1}^n\frac{|D_i|}{|D|}\sum_{k&#x3D;1}^K\frac{|D_{ik}|}{|D_i|}\log_2\frac{|D_{ik}|}{|D_i|}$$<br> (3)计算信息增益<br>$$g(D,A)&#x3D;H(D)-H(D|A)$$</p><ul><li>引入信息增益比<br>$$g_R(D,A)&#x3D;\frac{g(D,A)}{H_A(D)}$$<br>其中，$H_A(D)&#x3D;-\sum_{i&#x3D;1}^n\frac{|D_i|}{|D|}\log_2\frac{|D_i|}{|D|},n$是特征$A$取值的个数。<br>这是为因为在决策过程中，算法直接使用信息增益，会导致进行决策倾向于选择分类特征较多的节点，为此引入信息增益比来规避这一问题。</li></ul><h2 id="ID3算法-C4-5算法"><a href="#ID3算法-C4-5算法" class="headerlink" title="ID3算法-&gt;C4.5算法"></a>ID3算法-&gt;C4.5算法</h2><p>用于生成树</p><h2 id="剪枝算法"><a href="#剪枝算法" class="headerlink" title="剪枝算法"></a>剪枝算法</h2><p>决策树的剪枝往往通过极小化决策树整体的损失函数(loss function)或代价函数(cost function)来实现。设树$T$的叶结点个数为$|T|$,$t$是树$T$的叶结点，该叶结点有$N_t$个样本点，其中$k$类的样本点有$N_tk$个，$k&#x3D;1,2,\cdots,K$,$H_t(T)$为叶结点$t$<br>上的经验熵，$\alpha\geqslant0$为参数，则决策树学习的损失函数可以定义为</p><p>$$C_\alpha(T)&#x3D;\sum_{t&#x3D;1}^{|T|}N_tH_t(T)+\alpha|T|$$<br>其中经验熵为<br>$$H_t(T)&#x3D;-\sum_k\frac{N_{tk}}{N_t}\log\frac{N_{tk}}{N_t}$$<br>在损失函数中，将式(5.11)右端的第 1 项记作<br>$$C(T)&#x3D;\sum_{t&#x3D;1}^{|T|}N_tH_t(T)&#x3D;-\sum_{t&#x3D;1}^{|T|}\sum_{k&#x3D;1}^KN_{tk}\log\frac{N_{tk}}{N_t}$$</p><h3 id="这时有"><a href="#这时有" class="headerlink" title="这时有"></a>这时有</h3><p>$$C_\alpha(T)&#x3D;C(T)+\alpha|T|$$</p><p>$\alpha$的大小决定了我们对树的复杂程度的控制。我们为了防止过拟合，需要在C（T）和 T之间取舍。<br>剪枝算法的基本思路就是，从叶节点自下而上的剪枝，如果剪枝后的惩罚函数变小了，则返回剪枝之后的树继续进行剪枝。</p><h2 id="CART算法"><a href="#CART算法" class="headerlink" title="CART算法"></a>CART算法</h2><h3 id="回归树算法"><a href="#回归树算法" class="headerlink" title="回归树算法"></a>回归树算法</h3><p>本质上实在构建一个及其细分的分段函数用于回归算法，每次分段遵循最小的残差平方和进行。<br>采用启发式的方法，选择第$j$个变量$x^{(j)}$ 和它取的值$s$,作为切分变量(splitting variable)和切分点(splitting point),并定义两个区域（事实上遍历j的思路有很多）：<br>$$R_1(j,s)&#x3D;{x|x^{(j)}\leqslant s}\quad\text{和}\quad R_2(j,s)&#x3D;{x|x^{(j)}&gt;s}$$<br>然后寻找最优切分变量$j$和最优切分点$s$。具体地，求解<br>$$\min_{j,s}\left[\min_{c_1}\sum_{x_i\in R_1(j,s)}(y_i-c_1)^2+\min_{c_2}\sum_{x_i\in R_2(j,s)}(y_i-c_2)^2\right]$$<br>算法如下：<br>(1)选择最优切分变量$j$与切分点$s$,求解<br>$$\min_{j,s}\left[\min_{c_1}\sum_{x_i\in R_1(j,s)}(y_i-c_1)^2+\min_{c_2}\sum_{x_i\in R_2(j,s)}(y_i-c_2)^2\right]$$<br>遍历变量$j$,对固定的切分变量$j$扫描切分点$s$,选择使上式达到最小值的对<br>(2)用选定的对$(j,s)$划分区域并决定相应的输出值：<br>$$R_1(j,s)&#x3D;{x|x^{(j)}\leqslant s},\quad R_2(j,s)&#x3D;{x|x^{(j)}&gt;s}$$<br>$$\hat{c}<em>m&#x3D;\frac1{N_m}\sum</em>{x_i\in R_m(j,s)}y_i,\quad x\in R_m,\quad m&#x3D;1,2$$<br>(3)继续对两个子区域调用步骤 (1),(2),直至满足停止条件。(4)将输入空间划分为$M$个区域$R_1,R_2,\cdots,R_M$,生成决策树：<br>$$f(x)&#x3D;\sum_{m&#x3D;1}^M\hat{c}_mI(x\in R_m)$$</p><h3 id="分类树算法"><a href="#分类树算法" class="headerlink" title="分类树算法"></a>分类树算法</h3><p>使用基尼指数作为划分标准，其实和上文的熵趋势上一样。<br>基尼指数<br>$$\mathrm{Gini}(p)&#x3D;\sum_{k&#x3D;1}^Kp_k(1-p_k)&#x3D;1-\sum_{k&#x3D;1}^Kp_k^2$$<br>对于给定的样本，基尼指数为<br>$$\mathrm{Gini}(D)&#x3D;1-\sum_{k&#x3D;1}^K\left(\frac{|C_k|}{|D|}\right)^2$$</p><p><img src="https://www.freeimg.cn/i/2024/07/12/6691384d47f54.png" alt="1720793162035.png"></p><h3 id="one-hot编码"><a href="#one-hot编码" class="headerlink" title="one-hot编码"></a>one-hot编码</h3><p>也可以用到神经网络，逻辑回归等领域，<br><img src="/image-1.png" alt="alt text"><br><img src="/image-2.png" alt="alt text"></p><p>决策树可以处理连续值特征,方法是在每个节点上考虑不同的阈值进行划分,计算信息增益,选择能提供最大信息增益的阈值进行分割。这样可以递归地构建决策树的其余部分。此外,决策树算法还可以扩展到回归问题,预测数字输出。</p><h2 id="实战：预测天气"><a href="#实战：预测天气" class="headerlink" title="实战：预测天气"></a>实战：预测天气</h2><p>代码分两个模块</p><ul><li>数据分析<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-comment">##  基础函数库</span><br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">import</span> pandas <span class="hljs-keyword">as</span> pd<br><span class="hljs-comment">## 绘图函数库</span><br><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br><span class="hljs-keyword">import</span> seaborn <span class="hljs-keyword">as</span> sns<br>data = pd.read_csv(<span class="hljs-string">&#x27;../data/weather.csv&#x27;</span>)<br><span class="hljs-comment"># data.info()</span><br>data = data.fillna(-<span class="hljs-number">1</span>)<br><br><span class="hljs-comment">#k考察数据整体</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">overview</span>():<br>    <span class="hljs-keyword">global</span> data<br>    data.info()<br>    data.describe()<br><br>numerical_features = [x <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> data.columns <span class="hljs-keyword">if</span> data[x].dtype == np.float64]<br>category_features = [x <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> data.columns <span class="hljs-keyword">if</span> data[x].dtype != np.float64 <span class="hljs-keyword">and</span> x != <span class="hljs-string">&#x27;RainTomorrow&#x27;</span>]<br><span class="hljs-comment"># 画箱线图函数</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">boxlinegraph</span>():<br>    <span class="hljs-keyword">global</span> numerical_features<br>    <span class="hljs-keyword">global</span> category_features<br>    <span class="hljs-keyword">for</span> col <span class="hljs-keyword">in</span> data[numerical_features].columns:<br>        <span class="hljs-keyword">if</span> col != <span class="hljs-string">&#x27;RainTomorrow&#x27;</span>:<br>            sns.boxplot(x=<span class="hljs-string">&#x27;RainTomorrow&#x27;</span>, y=col, saturation=<span class="hljs-number">0.5</span>, palette=<span class="hljs-string">&#x27;pastel&#x27;</span>, data=data)<br>            plt.title(col)<br>            plt.show()<br><br><span class="hljs-comment">## 把所有的相同类别的特征编码为同一个值</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">get_mapfunction</span>(<span class="hljs-params">x</span>):<br>    mapp = <span class="hljs-built_in">dict</span>(<span class="hljs-built_in">zip</span>(x.unique().tolist(),<br>         <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(x.unique().tolist()))))   <span class="hljs-comment"># 将这些独特的值与一个范围（从0开始，长度为独特值的数量）配对，创建一个元组列表。每个独特值对应一个唯一的整数。</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">mapfunction</span>(<span class="hljs-params">y</span>):<br>        <span class="hljs-keyword">if</span> y <span class="hljs-keyword">in</span> mapp:<br>            <span class="hljs-keyword">return</span> mapp[y]<br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span><br>    <span class="hljs-keyword">return</span> mapfunction<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> category_features:<br>    data[i] = data[i].apply(get_mapfunction(data[i]))<br><br><br>boxlinegraph()<br><br></code></pre></td></tr></table></figure></li><li>决策树预测<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">import</span> pandas <span class="hljs-keyword">as</span> pd<br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">from</span> sklearn.model_selection <span class="hljs-keyword">import</span> train_test_split<br><span class="hljs-keyword">from</span> xgboost.sklearn <span class="hljs-keyword">import</span> XGBClassifier<br><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br><span class="hljs-keyword">import</span> seaborn <span class="hljs-keyword">as</span> sns<br>data = pd.read_csv(<span class="hljs-string">&#x27;../data/weather.csv&#x27;</span>)<br><span class="hljs-comment"># data.info()</span><br>data = data.fillna(-<span class="hljs-number">1</span>)<br><br>numerical_features = [x <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> data.columns <span class="hljs-keyword">if</span> data[x].dtype == np.float64]<br>category_features = [x <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> data.columns <span class="hljs-keyword">if</span> data[x].dtype != np.float64 ]<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">get_mapfunction</span>(<span class="hljs-params">x</span>):<br>    mapp = <span class="hljs-built_in">dict</span>(<span class="hljs-built_in">zip</span>(x.unique().tolist(),<br>         <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(x.unique().tolist()))))   <span class="hljs-comment"># 将这些独特的值与一个范围（从0开始，长度为独特值的数量）配对，创建一个元组列表。每个独特值对应一个唯一的整数。</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">mapfunction</span>(<span class="hljs-params">y</span>):<br>        <span class="hljs-keyword">if</span> y <span class="hljs-keyword">in</span> mapp:<br>            <span class="hljs-keyword">return</span> mapp[y]<br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span><br>    <span class="hljs-keyword">return</span> mapfunction<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> category_features:<br>    data[i] = data[i].apply(get_mapfunction(data[i]))<br><br><span class="hljs-comment">## 选择其类别为0和1的样本 （不包括类别为2的样本）</span><br>data_target_part = data[<span class="hljs-string">&#x27;RainTomorrow&#x27;</span>]<br>data_features_part = data[[x <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> data.columns <span class="hljs-keyword">if</span> x != <span class="hljs-string">&#x27;RainTomorrow&#x27;</span>]]<br><span class="hljs-comment">## 测试集大小为20%， 80%/20%分</span><br>x_train, x_test, y_train, y_test = train_test_split(data_features_part, data_target_part, test_size = <span class="hljs-number">0.2</span>, random_state = <span class="hljs-number">2020</span>)<br><span class="hljs-comment">## 定义 XGBoost模型</span><br>clf = XGBClassifier()<br><span class="hljs-comment"># 在训练集上训练XGBoost模型</span><br>clf.fit(x_train, y_train)<br><span class="hljs-comment">## 在训练集和测试集上分布利用训练好的模型进行预测</span><br>train_predict = clf.predict(x_train)<br>test_predict = clf.predict(x_test)<br><span class="hljs-keyword">from</span> sklearn <span class="hljs-keyword">import</span> metrics<br><br><span class="hljs-comment">## 利用accuracy（准确度）【预测正确的样本数目占总预测样本数目的比例】评估模型效果</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;The accuracy of the Logistic Regression is:&#x27;</span>,metrics.accuracy_score(y_train,train_predict))<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;The accuracy of the Logistic Regression is:&#x27;</span>,metrics.accuracy_score(y_test,test_predict))<br><br><span class="hljs-comment">## 查看混淆矩阵 (预测值和真实值的各类情况统计矩阵)</span><br>confusion_matrix_result = metrics.confusion_matrix(test_predict,y_test)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;The confusion matrix result:\n&#x27;</span>,confusion_matrix_result)<br><br><span class="hljs-comment"># 利用热力图对于结果进行可视化</span><br>plt.figure(figsize=(<span class="hljs-number">8</span>, <span class="hljs-number">6</span>))<br>sns.heatmap(confusion_matrix_result, annot=<span class="hljs-literal">True</span>, cmap=<span class="hljs-string">&#x27;Blues&#x27;</span>)<br>plt.xlabel(<span class="hljs-string">&#x27;Predicted labels&#x27;</span>)<br>plt.ylabel(<span class="hljs-string">&#x27;True labels&#x27;</span>)<br>plt.show()<br><br><br></code></pre></td></tr></table></figure></li></ul>]]></content>
    
    
    <categories>
      
      <category>机器学习</category>
      
      <category>ng机器学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>机器学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>矩阵求导技巧</title>
    <link href="/2024/07/08/%E6%95%B0%E5%AD%A6/%E7%9F%A9%E9%98%B5%E6%B1%82%E5%AF%BC/"/>
    <url>/2024/07/08/%E6%95%B0%E5%AD%A6/%E7%9F%A9%E9%98%B5%E6%B1%82%E5%AF%BC/</url>
    
    <content type="html"><![CDATA[<h1 id="前言：定义与布局"><a href="#前言：定义与布局" class="headerlink" title="前言：定义与布局"></a>前言：定义与布局</h1><p>根据求导的自变量和因变量是标量，向量还是矩阵，我们有9种可能的矩阵求导定义，谈谈几种常用的。</p><p>所谓向量对标量的求导，其实就是向量里的每个分量分别对标量求导，最后把求导的结果排列在一起，按一个向量表示而已。类似的结论也存在于标量对向量的求导，向量对向量的求导，向量对矩阵的求导，矩阵对向量的求导，以及矩阵对矩阵的求导等。总而言之，所谓的向量矩阵求导本质上就是多元函数求导，仅仅是把把函数的自变量，因变量以及标量求导的结果排列成了向量矩阵的形式，方便表达与计算，更加简洁而已。一个需要要约定的点是按分量求导后的结果如何进行排布？一般来说有两种布局方式：分子布局与分母布局，无论何种选择方式都是正确的！我们需要根据我们选定的排布方式推导出一套自洽的计算理论即可！诸如：链式法则，微分定义，等等        </p><p>谈谈两种排布方式</p><p>对于分子布局来说，我们求导结果的维度以分子为主<br>对于分母布局来说，我们求导结果的维度以分母为主    </p><p>举一个例子，标量$y$对矩阵$X$求导，那么如果按分母布局，则求导结果的维度和矩阵$X$的维度$m$×$n$是一致的。如果是分子布局，则求导结果的维度为n×m</p><p>一般来说，我们会使用一种叫混合布局的思路：即</p><ul><li>如果是向量或者矩阵对标量求导，则使用分子布局为准  (不常用)</li><li>如果是标量对向量或者矩阵求导，则以分母布局为准。（最常用）</li><li>对于(列)向量对(列)向量求导，有些分歧，下面以分子布局的雅克比矩阵为标准。</li></ul><p>$$\begin{gathered}\frac{\partial\mathbf{y}}{\partial\mathbf{x}}&#x3D;\begin{pmatrix}\frac{\partial y_1}{\partial x_1}&amp;\frac{\partial y_1}{\partial x_2}&amp;\ldots&amp;\frac{\partial y_1}{\partial x_n}\\frac{\partial y_2}{\partial x_1}&amp;\frac{\partial y_2}{\partial x_2}&amp;\ldots&amp;\frac{\partial y_2}{\partial x_n}\\vdots&amp;\vdots&amp;\ddots&amp;\vdots\\frac{\partial y_m}{\partial x_1}&amp;\frac{\partial y_m}{\partial x_2}&amp;\ldots&amp;\frac{\partial y_m}{\partial x_n}\end{pmatrix}\end{gathered}$$</p><p>具体计算时，对y的每一个分量进行标量对向量求导，得到的导数转置后按行排列即是欲求的雅可比矩阵。</p><p>有的资料上会使用$\frac{\partial\mathbf{y}}{\partial\mathbf{x}^\mathbf{T}}$定义雅可比矩阵，数学意义与上式是一样的</p><h1 id="标量对矩阵的求导"><a href="#标量对矩阵的求导" class="headerlink" title="标量对矩阵的求导"></a>标量对矩阵的求导</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>回忆如何表示一个标量的微分，显然，$df$就是所有自变量变化引起的函数变化的总和，也就是<br>$$df&#x3D;\sum_{i&#x3D;1}^n\frac{\partial f}{\partial x_i}dx_i$$</p><ul><li>$dx$为标量时，$df$可以表示为<br>$$df&#x3D;f^{\prime}(x)dx$$</li><li>$dx$为向量时，$df$可以表示为<br>$$df&#x3D;\sum_{i&#x3D;1}^n\frac{\partial f}{\partial x_i}dx_i&#x3D;\frac{\partial f}{\partial\boldsymbol{x}}^Td\boldsymbol{x}$$<br>其中$\frac{\partial f}{\partial\boldsymbol{x}}^T$为$f$的梯度(行向量)，全微分$df$是导数$\frac{\partial f}{\partial x}$与微分向量$dx$的内积        </li><li>$dX$为矩阵时，借助矩阵的迹，$df$可以表示为<br>$$df&#x3D;\sum_{i&#x3D;1}^m\sum_{j&#x3D;1}^n\frac{\partial f}{\partial X_{ij}}dX_{ij}&#x3D;\mathrm{tr}\left(\frac{\partial f}{\partial X}^TdX\right)$$<br>其中全微分$df$是导数$\frac{\partial f}{\partial X}$与微分矩阵$dX$的内积，我们也由此自然地得出了矩阵对标量求导时的分子布局定义：标量f对矩阵原位逐个元素求导后取装置。<br>附：上式证明。<br>$$Proof.\begin{aligned}<br>\mathrm{d}f(\boldsymbol{X})&amp; &#x3D;\frac{\partial f}{\partial x_{11}}\mathrm{d}x_{11}+\frac{\partial f}{\partial x_{12}}\mathrm{d}x_{12}+\cdots+\frac{\partial f}{\partial x_{1n}}\mathrm{d}x_{1n} \<br>&amp;+\frac{\partial f}{\partial x_{21}}\mathrm{d}x_{21}+\frac{\partial f}{\partial x_{22}}\mathrm{d}x_{22}+\cdots+\frac{\partial f}{\partial x_{2n}}\mathrm{d}x_{2n} \<br>&amp;+\ldots \<br>&amp;+\frac{\partial f}{\partial x_{m1}}\mathrm{d}x_{m1}+\frac{\partial f}{\partial x_{m2}}\mathrm{d}x_{m2}+\cdots+\frac{\partial f}{\partial x_{mn}}\mathrm{d}x_{mn} \<br>df&#x3D;&amp;tr(\begin{bmatrix}\frac{\partial f}{\partial x_{11}}&amp;\frac{\partial f}{\partial x_{21}}&amp;\cdots&amp;\frac{\partial f}{\partial x_{m1}}\\frac{\partial f}{\partial x_{12}}&amp;\frac{\partial f}{\partial x_{22}}&amp;\cdots&amp;\frac{\partial f}{\partial x_{m2}}\\vdots&amp;\vdots&amp;\vdots&amp;\vdots\\frac{\partial f}{\partial x_{1n}}&amp;\frac{\partial f}{\partial x_{2n}}&amp;\cdots&amp;\frac{\partial f}{\partial x_{mn}}\end{bmatrix}<em>{n\times m}\begin{bmatrix}\mathrm{d}x</em>{11}&amp;\mathrm{d}x_{12}&amp;\cdots&amp;\mathrm{d}x_{1n}\\mathrm{d}x_{21}&amp;\mathrm{d}x_{22}&amp;\cdots&amp;\mathrm{d}x_{2n}\\vdots&amp;\vdots&amp;\vdots&amp;\vdots\\mathrm{d}x_{m1}&amp;\mathrm{d}x_{m2}&amp;\cdots&amp;\mathrm{d}x_{mn}\end{bmatrix}_{m\times n})<br>\end{aligned}$$</li></ul><h2 id="矩阵微分的性质"><a href="#矩阵微分的性质" class="headerlink" title="矩阵微分的性质"></a>矩阵微分的性质</h2><ul><li>1.加减法：$d(X\pm Y)&#x3D;dX\pm dY$;矩阵乘法：$d(XY)&#x3D;(dX)Y+XdY$;转置：<br>$d(X^T)&#x3D;(dX)^T$;迹：$dtr(X)&#x3D;tr(dX)$。<br>$$ Proof.略$$</li><li>2.逆：$dX^{-1}&#x3D;-X^{-1}dXX^{-1}$。此式可在$XX^-1&#x3D;I$两侧求微分来证明。</li><li>3.行列式：$d|X|&#x3D;\operatorname{tr}(X^{<em>}dX)$,其中$X^{</em>}$表示X的伴随矩阵，在X可逆时又可以写作$d|X|&#x3D;|X|$tr$(X^{-1}dX)$。此式可用Laplace展开来证明</li><li>4.逐元素乘法：$d(X\odot Y)&#x3D;dX\odot Y+X\odot dY$,$\odot$表示尺寸相同的矩阵X，Y逐元素相乘。</li><li>5.逐元素函数：$d\sigma(X)&#x3D;\sigma^{\prime}(X)\odot dX$,$\sigma(X)&#x3D;[\sigma(X_{ij})]$是逐元素标量函数运算，<br>$$\left.\begin{aligned}X&#x3D;\begin{bmatrix}X_{11}&amp;X_{12}\X_{21}&amp;X_{22}\end{bmatrix},d\sin(X)&#x3D;\begin{bmatrix}\cos X_{11}dX_{11}&amp;\cos X_{12}dX_{12}\\cos X_{21}dX_{21}&amp;\cos X_{22}dX_{22}\end{bmatrix}&#x3D;\cos(X)\odot dX\end{aligned}\right.$$</li></ul><h2 id="迹运算技巧"><a href="#迹运算技巧" class="headerlink" title="迹运算技巧"></a>迹运算技巧</h2><ul><li><p>1.标量套上迹：$a&#x3D;\operatorname{tr}(a)$</p></li><li><p>2.转置：tr$(A^T)&#x3D;\operatorname{tr}(A).$</p></li><li><p>3.线性：$\operatorname{tr}(A\pm B)&#x3D;\operatorname{tr}(A)\pm\operatorname{tr}(B).$</p></li><li><p>4.矩阵乘法交换：$\operatorname{tr}(AB)&#x3D;\operatorname{tr}(BA)$,其中$A$与$B^T$尺寸相同。两侧都等于$\sum_i,jA_{ij}B_{ji}$</p></li><li><p>5.矩阵乘法&#x2F;逐元素乘法交换：$\operatorname{tr}(A^T(B\odot C))&#x3D;\operatorname{tr}((A\odot B)^TC)$,其中$A,B,C$尺寸相同。两侧都等于$\sum_{ij}A_{ij}B_{ij}C_{ij}$           </p></li><li><p>若标量函数f是矩阵X经加减乘法、逆、行列式、逐元素函数等运算构成，则使用相应的运算法则对f求微分，再使用迹技巧给df套上迹并将其它项交换至dX左侧，对照导数与微分的联系$df&#x3D;\mathrm{tr}\left(\frac{\partial f}{\partial X}^TdX\right)$即可求得导数.$ati.常常利用性质4，5来进行tr内部的顺序交换。$</p></li></ul><h2 id="求解一些经典问题"><a href="#求解一些经典问题" class="headerlink" title="求解一些经典问题"></a>求解一些经典问题</h2><ul><li>$f&#x3D;\boldsymbol{a}^TX\boldsymbol{b}\text{,求}\frac{\partial f}{\partial X}$   其中$a,b$为列向量，$X$为矩阵。</li></ul><p>$$df&#x3D;a^{T}dXb\df&#x3D;tr(a^{T}dX b)&#x3D;tr(ba^{T}dX)\\frac{\partial f}{\partial x}&#x3D;(ba^{T})^{T}&#x3D;ab^{T}$$</p><ul><li>$f&#x3D;\boldsymbol{a}^T\exp(X\boldsymbol{b})$,求$\frac{\partial f}{\partial X}$。其中$\boldsymbol{a}$是$m\times1$列向量，$X$是$m\times n$矩阵，$\boldsymbol{b}$是$n\times1$列向<br>量，exp表示逐元素求指数，$f$是标量。</li></ul><p>$$<br>\begin{aligned}<br>df &amp;&#x3D; a^{T}(\exp(Xb) \odot d(Xb)) \<br>df &amp;&#x3D; \text{tr}(a^{T}[\exp(Xb) \odot d(Xb)]) \<br>df &amp;&#x3D; \text{tr}((a^{T} \odot \exp(Xb))^{T}d(Xb)) \<br>df &amp;&#x3D; \text{tr}(b(a \odot \exp(Xb))^TdX) &#x3D; \text{tr}(((a \odot \exp(Xb))b^T)^TdX) \<br>&#x3D;&gt;\frac{\partial f}{\partial X} &amp;&#x3D; (\boldsymbol{a} \odot \exp(X\boldsymbol{b}))\boldsymbol{b}^T<br>\end{aligned} $$</p><ul><li><p>$f&#x3D;\operatorname{tr}(Y^TMY),Y&#x3D;\sigma(WX)$,求$\frac{\partial f}{\partial X}$。其中$W$是$l\times m$矩阵，$X$是$m\times n$矩阵，$Y$<br>是$l\times n$矩阵，$M$是$l\times l$对称矩阵，$\sigma$是逐元素函数，$f$是标量。<br>$$ \begin{aligned}<br>df &amp;&#x3D; \operatorname{tr}((dY)^TMY) + \operatorname{tr}(Y^TMdY) \<br>&amp;&#x3D; \operatorname{tr}(Y^TM^TdY) + \operatorname{tr}(Y^TMdY) \<br>&amp;&#x3D; \operatorname{tr}(Y^T(M+M^T)dY) \<br>\frac{\partial f}{\partial Y} &amp;&#x3D; (M+M^T)Y &#x3D; 2MY \<br>df &amp;&#x3D; \operatorname{tr}\left(\frac{\partial f}{\partial Y}^TdY\right) \<br>df &amp;&#x3D; \operatorname{tr}\left(\frac{\partial f}{\partial Y}^T(\sigma^{\prime}(WX)\odot(WdX))\right) \<br>&amp;&#x3D; \operatorname{tr}\left(\left(\frac{\partial f}{\partial Y}\odot\sigma^{\prime}(WX)\right)^TWdX\right) \<br>\frac{\partial f}{\partial X} &amp;&#x3D; W^T\left(\frac{\partial f}{\partial Y}\odot\sigma^{\prime}(WX)\right) &#x3D; W^T\left((2M\sigma(WX))\odot\sigma^{\prime}(WX)\right)<br>\end{aligned} $$</p></li><li><p>$l&#x3D;|X\boldsymbol{w}-\boldsymbol{y}|^2$,求$\boldsymbol{w}$的最小二乘估计，即求$\frac{\partial l}{\partial\boldsymbol{w}}$的零点。其中$\boldsymbol{y}$是$m\times1$<br>列向量，$X$是$m\times n$矩阵，$\boldsymbol{w}$是$n\times1$列向量，$l$是标量。</p></li></ul><p>$$<br>\begin{aligned}<br>l &amp;&#x3D;(X\boldsymbol{w}-\boldsymbol{y})^T(X\boldsymbol{w}-\boldsymbol{y})<br>\dl &amp;&#x3D;(Xd\boldsymbol{w})^T(X\boldsymbol{w}-\boldsymbol{y})+(X\boldsymbol{w}-\boldsymbol{y})^T(Xd\boldsymbol{w})<br>\dl &amp;&#x3D;2(X\boldsymbol{w}-\boldsymbol{y})^TXd\boldsymbol{w}<br>\end{aligned}<br>$$<br>对照导数与微分的联系$dl&#x3D;\frac{\partial l}{\partial\boldsymbol{w}}^Td\boldsymbol{u}$ ,得到$\frac{\partial l}{\partial\boldsymbol{w}}&#x3D;2X^T(X\boldsymbol{w}-\boldsymbol{y})$。$\frac{\partial l}{\partial\boldsymbol{w}}&#x3D;\mathbf{0}$即$X^TX\boldsymbol{w}&#x3D;X^T\boldsymbol{y}$,得到$\boldsymbol{w}$的最小二乘估计为<br>$\boldsymbol{w}&#x3D;(X^TX)^{-1}X^T\boldsymbol{y}.$</p><h1 id="向量对向量的求导"><a href="#向量对向量的求导" class="headerlink" title="向量对向量的求导"></a>向量对向量的求导</h1><h2 id="如何计算"><a href="#如何计算" class="headerlink" title="如何计算"></a>如何计算</h2><p>给一个例子：DNN神经网络中第l层与第l+1层的输入输出$z^{l+1}$与$z^{l}$之间的关系为<br>$$z^{l+1}&#x3D;W^{l+1}a^l+b^{l+1}&#x3D;W^{l+1}\sigma(z^l)+b^{l+1}$$<br>求解:  $\frac{\partial z^{l+1}}{\partial z^l}$ </p><p>先用标量对向量求导的方法，依次求出$z^{l+1}$的每一个分量的导数，再排列成雅可比矩阵。</p><p>考虑$z_{j}^{l+1}$对$z_l$的导数</p><p>$$dz_{j}^{l+1}&#x3D;W^{l+1}\sigma^{‘}(z^l) \odot dz^l $$<br>$$dz_{j}^{l+1}&#x3D;((W^{l+1})^{T} \odot \sigma^{‘}(z^l))^{T}  dz^l $$</p><p>$j&#x3D;1$到$j&#x3D;Nrow(W)$排列成矩阵，最终写为</p><p>$$\frac{\partial z^{l+1}}{\partial z^l}&#x3D;W^{l+1}diag(\sigma^{‘}(z^l))$$</p><h2 id="链式法则："><a href="#链式法则：" class="headerlink" title="链式法则："></a>链式法则：</h2><h3 id="向量对向量的链式求导"><a href="#向量对向量的链式求导" class="headerlink" title="向量对向量的链式求导"></a>向量对向量的链式求导</h3><p>定理：<br>若多个列向量的依赖关系为 $\boldsymbol{x}\to\boldsymbol{y}\to\boldsymbol{z}$且其维数分别为$n,p,m,$则             </p><ul><li>$\frac{\partial z}{\partial x}&#x3D;\frac{\partial z}{\partial y}\frac{\partial y}{\partial x}$ (若使用分子布局),            </li><li>$\frac{\partial z}{\partial x}&#x3D;\frac{\partial y}{\partial x}\frac{\partial z}{\partial y}$ (若使用分母布局)</li></ul><p>对分子布局进行证明:</p><p>$$\frac{\partial z}{\partial x}&#x3D;\begin{bmatrix}\frac{\partial z_1}{\partial x_1}&amp;\frac{\partial z_1}{\partial x_2}&amp;\cdots&amp;\frac{\partial z_1}{\partial x_n}\\vdots&amp;\ddots&amp;&amp;\vdots\\frac{\partial z_m}{\partial x_1}&amp;\frac{\partial z_m}{\partial x_2}&amp;\cdots&amp;\frac{\partial z_m}{\partial x_n}\end{bmatrix}$$</p><p>$$\left.&#x3D;\left[\begin{array}{ccccc}\sum_{i&#x3D;1}^p\frac{\partial z_1}{\partial y_i}\frac{\partial y_i}{\partial x_1}&amp;\sum_{i&#x3D;1}^p\frac{\partial z_1}{\partial y_i}\frac{\partial y_i}{\partial x_2}&amp;\cdots&amp;\sum_{i&#x3D;1}^p\frac{\partial z_1}{\partial y_i}\frac{\partial y_i}{\partial x_n}\\vdots&amp;\ddots&amp;&amp;\vdots\\sum_{i&#x3D;1}^p\frac{\partial z_m}{\partial y_i}\frac{\partial y_i}{\partial x_1}&amp;\sum_{i&#x3D;1}^p\frac{\partial z_m}{\partial y_i}\frac{\partial y_i}{\partial x_2}&amp;\cdots&amp;\sum_{i&#x3D;1}^p\frac{\partial z_m}{\partial y_i}\frac{\partial y_i}{\partial x_n}\end{array}\right.\right]$$</p><p>$$&#x3D;\begin{bmatrix}\frac{\partial z_1}{\partial y_1}&amp;\frac{\partial z_1}{\partial y_2}&amp;\cdots&amp;\frac{\partial z_1}{\partial y_p}\\vdots&amp;\ddots&amp;&amp;\vdots\\frac{\partial z_m}{\partial y_1}&amp;\frac{\partial z_m}{\partial y_2}&amp;\cdots&amp;\frac{\partial z_m}{\partial y_p}\end{bmatrix}\begin{bmatrix}\frac{\partial y_1}{\partial x_1}&amp;\frac{\partial y_1}{\partial x_2}&amp;\cdots&amp;\frac{\partial y_1}{\partial x_n}\\vdots&amp;\ddots&amp;&amp;\vdots\\frac{\partial y_p}{\partial x_1}&amp;\frac{\partial y_p}{\partial x_2}&amp;\cdots&amp;\frac{\partial y_p}{\partial x_n}\end{bmatrix}$$</p><p>$$&#x3D;\frac{\partial z}{\partial y}\frac{\partial y}{\partial x}$$</p><p>证毕，同时推广到n个向量之间的链式法则也自然是成立的，因为多个链式总可以看为上述操作之叠加</p><h3 id="标量对多个向量的链式求导"><a href="#标量对多个向量的链式求导" class="headerlink" title="标量对多个向量的链式求导"></a>标量对多个向量的链式求导</h3><p>定理：<br>标量对更多的向量求导，比如$\mathbf{y_1}\to\mathbf{y_2}\to\ldots\to\mathbf{y_n}\to z$，则有<br>$$\frac{\partial z}{\partial\mathbf{y_1}}&#x3D;(\frac{\partial\mathbf{y_n}}{\partial\mathbf{y_{n-1}}}\frac{\partial\mathbf{y_{n-1}}}{\partial\mathbf{y_{n-2}}}\ldots\frac{\partial\mathbf{y_2}}{\partial\mathbf{y_1}})^T\frac{\partial z}{\partial\mathbf{y_n}}$$</p><h3 id="标量对多个矩阵的链式求导"><a href="#标量对多个矩阵的链式求导" class="headerlink" title="标量对多个矩阵的链式求导"></a>标量对多个矩阵的链式求导</h3><p>定理:在依赖关系$\mathbf{X}\to\mathbf{Y}\to z$下，满足链式法则</p><p>$$\frac{\partial z}{\partial x_{ij}}&#x3D;\sum_{k,l}\frac{\partial z}{\partial Y_{kl}}\frac{\partial Y_{kl}}{\partial X_{ij}}&#x3D;tr((\frac{\partial z}{\partial Y})^T\frac{\partial Y}{\partial X_{ij}})$$</p><p>我们没有给出基于矩阵整体的链式求导法则，主要原因是矩阵对矩阵的求导是比较复杂的定义，我们目前也未涉及。因此只能给出对矩阵中一个标量的链式求导方法。这个方法并不实用，因为我们并不想每次都基于定义法来求导最后再去排列求导结果。</p><p>　　　　虽然我们没有全局的标量对矩阵的链式求导法则，但是对于一些线性关系的链式求导，我们还是可以得到一些有用的结论的。</p><p>我们来看这个常见问题：$A,X,B,Y$都是矩阵，$Z$是标量，其中$z&#x3D;f(Y)&#x3D;f(AX+B)$,我们欲求出<br>$\frac{\partial z}{\partial X}$，这个问题在机器学习中是很常见的。此时，我们并不能直接整体使用矩阵的链式求导法则，因为矩阵对矩阵的求导结果不好处理。</p><p>这里我们回归初心，使用定义法试一试,先使用上面的标量链式求导公式：</p><p>$$\frac{\partial z}{\partial x_{ij}}&#x3D;\sum_{k,l}\frac{\partial z}{\partial Y_{kl}}\frac{\partial Y_{kl}}{\partial X_{ij}}$$</p><p>后半部分</p><p>$$\frac{\partial Y_{kl}}{\partial X_{ij}}&#x3D;\frac{\partial\sum_s(A_{ks}X_{sl})}{\partial X_{ij}}&#x3D;\frac{\partial A_{ki}X_{il}}{\partial X_{ij}}&#x3D;A_{ki}\delta_{lj}$$</p><p>其中$\delta_{lj}$为克罗内克符号，当$l&#x3D;j$的时候为1，否则为0</p><p>那么最终的标签链式求导公式转化为：<br>$$\frac{\partial z}{\partial x_{ij}}&#x3D;\sum_{k,l}\frac{\partial z}{\partial Y_{kl}}A_{ki}\delta_{lj}&#x3D;\sum_k\frac{\partial z}{\partial Y_{kj}}A_{ki}$$</p><p>排列成矩阵即为：</p><p>$$\frac{\partial z}{\partial X}&#x3D;A^T\frac{\partial z}{\partial Y}$$</p><h3 id="总结出四条deeplearning中常用的结论"><a href="#总结出四条deeplearning中常用的结论" class="headerlink" title="总结出四条deeplearning中常用的结论"></a>总结出四条deeplearning中常用的结论</h3><p>$$z&#x3D;f(Y),Y&#x3D;AX+B\to\frac{\partial z}{\partial X}&#x3D;A^T\frac{\partial z}{\partial Y}$$<br>$$z&#x3D;f(\mathbf{y}),\mathbf{y}&#x3D;A\mathbf{x}+\mathbf{b}\to\frac{\partial z}{\partial\mathbf{x}}&#x3D;A^T\frac{\partial z}{\partial\mathbf{y}}$$<br>$$z&#x3D;f(Y),Y&#x3D;XA+B\to\frac{\partial z}{\partial X}&#x3D;\frac{\partial z}{\partial Y}A^T$$</p><p>$$z&#x3D;f(\mathbf{y}),\mathbf{y}&#x3D;X\mathbf{a}+\mathbf{b}\to\frac{\partial z}{\partial\mathbf{X}}&#x3D;\frac{\partial z}{\partial\mathbf{y}}a^T$$</p>]]></content>
    
    
    <categories>
      
      <category>数学</category>
      
      <category>矩阵分析</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ssh密钥失效解决办法</title>
    <link href="/2024/01/21/cs/ssh%E5%AF%86%E9%92%A5%E5%A4%B1%E6%95%88%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/"/>
    <url>/2024/01/21/cs/ssh%E5%AF%86%E9%92%A5%E5%A4%B1%E6%95%88%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h2 id="解决ssh密钥过期等一系列问题"><a href="#解决ssh密钥过期等一系列问题" class="headerlink" title="解决ssh密钥过期等一系列问题"></a>解决ssh密钥过期等一系列问题</h2><p>由于期末考试，大概两三周没有更新博客，再次git提交时出现了如下问题。<br><img src="https://picdm.sunbangyan.cn/2024/01/21/0ddd2812d6dfd55ee3946182163166b8.jpeg"><br>经过一系列搜索，初步判断是由于时间问题，ssh密钥失效，于是重新生成了ssh密钥并提交到github，流程如下。</p><h4 id="重新生成提交ssh密钥"><a href="#重新生成提交ssh密钥" class="headerlink" title="重新生成提交ssh密钥"></a>重新生成提交ssh密钥</h4><p>1 由<code>C:\Users\bradin\.ssh </code>找到.ssh文件夹，删除该文件夹下所有文件<br><img src="https://picdm.sunbangyan.cn/2024/01/21/d6fcfb6e055c4be1b1fa3645b118676d.jpeg"><br>2 查看git全局配置是否正确 在任意位置git bash</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs lua">git <span class="hljs-built_in">config</span> <span class="hljs-comment">--list</span><br></code></pre></td></tr></table></figure><p>如果不正确，通过以下命令修改邮箱或用户名</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs stylus">修改用户名<br>git config <span class="hljs-attr">--global</span> user<span class="hljs-selector-class">.name</span> <span class="hljs-string">&#x27;brandinzhang&#x27;</span><br>修改邮箱<br>git config <span class="hljs-attr">--global</span> user<span class="hljs-selector-class">.email</span> <span class="hljs-string">&#x27;brandin_zhang@163.com&#x27;</span><br></code></pre></td></tr></table></figure><p>3 修改本地ssh</p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs excel">ssh-keygen -<span class="hljs-built_in">t</span> rsa -C <span class="hljs-string">&quot;brandin_zhang@163.com&quot;</span><br></code></pre></td></tr></table></figure><p>一路回车，遇到y&#x2F;n 键入y</p><p>4 打开<code>C:\Users\bradin\.ssh\id_rsa.pub</code> 复制该文件中的密钥内容<br>5 进入github，在settings中找到SSH and GPG keys<br><img src="https://picdm.sunbangyan.cn/2024/01/21/53dffd3b4f3ad71184841a5dfe2ddd10.jpeg"><br>6 删除旧的ssh密钥，加入新的ssh密钥（new ssh key）</p><p><img src="https://picdl.sunbangyan.cn/2024/01/21/781ff758163fc6ce36d851bbb620e077.jpeg"></p><p>将<code>C:\Users\bradin\.ssh\id_rsa.pub</code> 文件中的密钥内容粘贴进来</p><p><img src="https://picst.sunbangyan.cn/2024/01/21/b4f2290ab983b4cd98da541d7294efea.jpeg"><br>7 最后需要连接git与github 在任意位置git bash键入以下内容</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">ssh</span> -T git<span class="hljs-variable">@github</span>.com<br></code></pre></td></tr></table></figure><p>理论上这样就结束了，等待连接成功即可。但是我又出现了新的问题：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"># ssh:<span class="hljs-keyword">connect</span> <span class="hljs-keyword">to</span> host github.com port <span class="hljs-number">22</span>: <span class="hljs-keyword">Connection</span> timed <span class="hljs-keyword">out</span><br></code></pre></td></tr></table></figure><p>也是就说github在端口号22上面的链接超时了。经过搜索最终通过下面方法解决了这一问题</p><h4 id="解决github22-端口超时问题"><a href="#解决github22-端口超时问题" class="headerlink" title="解决github22 端口超时问题"></a>解决github22 端口超时问题</h4><p>参考<br>1 <a href="https://zhuanlan.zhihu.com/p/521340971">坑：ssh: connect to host github.com port 22: Connection refused - 知乎 (zhihu.com)</a><br>2 <a href="https://blog.csdn.net/m0_54944506/article/details/135652028">Git问题：解决“ssh:connect to host github.com port 22: Connection timed out”_github ssh 无法连接-CSDN博客</a><br>得到以下解决方案<br>1 在.ssh文件夹中新建一个config文件</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arduino">touch config<br></code></pre></td></tr></table></figure><p>2 创建完成后打开输入以下内容</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">Host github.com<br><span class="hljs-keyword">User</span> <span class="hljs-title">git</span><br>Hostname ssh.github.com<br>PreferredAuthentications publickey<br>IdentityFile ~/.ssh/id_rsa<br>Port <span class="hljs-number">443</span><br></code></pre></td></tr></table></figure><p>这样ssh连接GitHub的时候就会使用443端口。<br>3 一路回车，提示处输入yes而非y 显示下图就连接成功了<br><img src="https://picdl.sunbangyan.cn/2024/01/21/519523872b41e4084da1588819b2afdd.jpeg"><br>4 回到原来blog目录利用hexo 上传文件</p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs crystal"><span class="hljs-variable">$ </span>hexo clean<br><span class="hljs-variable">$ </span>hexo g<br><span class="hljs-variable">$ </span>hexo d<br></code></pre></td></tr></table></figure><p>即可正常上传</p>]]></content>
    
    
    
    <tags>
      
      <tag>git</tag>
      
      <tag>ssh</tag>
      
      <tag>github</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>51单片机（一）</title>
    <link href="/2024/01/21/EE/51%E5%8D%95%E7%89%87%E6%9C%BA%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <url>/2024/01/21/EE/51%E5%8D%95%E7%89%87%E6%9C%BA%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="51单片机简明笔记（一）"><a href="#51单片机简明笔记（一）" class="headerlink" title="51单片机简明笔记（一）"></a>51单片机简明笔记（一）</h1><p>这一系列blog主要用于记录51单片机的软件学习与部分硬件学习思路，保存代码与模版方便速查。</p><h2 id="1概述"><a href="#1概述" class="headerlink" title="1概述"></a>1概述</h2><p>我的单片机型号是STC89C52RC，具体参数可见下表<br><img src="https://picdl.sunbangyan.cn/2024/01/15/747d33ce26b484d42c937fde71bd1c7a.jpeg" alt="查看参数"><br>推测这个所谓程序空间指的是ROM<br>单片机简称MCU，是micro control unit的缩写，意为一个微型的计算机。<br>中央处理器（CPU）：STC89C52RC的CPU是8051体系结构的核心，主要负责执行程序指令、数据处理、中断处理等任务。程序的编写使用C语言或汇编语言，通过编译器生成二进制可执行文件，然后通过下载工具将程序下载到STC89C52RC中。</p><p>存储器（FLASH）：STC89C52RC具有64KB的Flash存储器，可以用来存储程序代码和数据。在编程时，需要将程序代码和数据存储到Flash中，以便单片机可以读取执行。</p><p>存储器（RAM）：STC89C52RC具有256字节的RAM存储器，可以用来存储程序中的变量和中间结果。在编程时，需要定义变量并将其存储到RAM中，以便程序可以读写变量的值。</p><p>定时器&#x2F;计数器（Timer）：STC89C52RC具有3个定时器&#x2F;计数器，可以用来产生定时中断、PWM波形输出等功能。在编程时，需要对定时器&#x2F;计数器进行初始化配置，并编写中断服务程序来处理定时中断。</p><p>串口（UART）：STC89C52RC具有一个串口，可以用来进行与外部设备的通信。在编程时，需要对串口进行初始化配置，并编写发送和接收函数来进行数据的传输。</p><p>IO口：STC89C52RC具有32个IO口，可以用来连接各种外部设备，如LED、LCD、按键、传感器等。在编程时，需要对IO口进行初始化配置，并编写IO口的读写函数来控制外部设备的状态。</p><p>中断控制器（INT）：STC89C52RC具有中断控制器，可以用来管理各种中断源和中断服务程序。在编程时，需要对中断控制器进行初始化配置，并编写中断服务程序来处理中断事件。<br>原文链接：<a href="https://blog.csdn.net/m0_61107092/article/details/130212554">https://blog.csdn.net/m0_61107092/article/details/130212554</a></p><h2 id="2-LED灯相关"><a href="#2-LED灯相关" class="headerlink" title="2 LED灯相关"></a>2 LED灯相关</h2><p>基本思想  cpu控制寄存器（ram）控制高低电平</p><h4 id="点亮一个led"><a href="#点亮一个led" class="headerlink" title="点亮一个led"></a>点亮一个led</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;REGX52.H&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>   P2=<span class="hljs-number">0xFE</span>;   <span class="hljs-comment">// 1111 1110</span><br><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="led闪烁-引入延时函数）"><a href="#led闪烁-引入延时函数）" class="headerlink" title="led闪烁(引入延时函数）"></a>led闪烁(引入延时函数）</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;REGX52.H&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;INTRINS.H&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Delay100us</span><span class="hljs-params">()</span><span class="hljs-comment">//@11.0592MHz</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> i, j;               <span class="hljs-comment">//用unsigned 为了节约内存。</span><br><br>_nop_();<br>_nop_();<br>i = <span class="hljs-number">2</span>;<br>j = <span class="hljs-number">15</span>;<br><span class="hljs-keyword">do</span><br>&#123;<br><span class="hljs-keyword">while</span> (--j);<br>&#125; <span class="hljs-keyword">while</span> (--i);<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)<br>&#123;<br>P2=<span class="hljs-number">0xFE</span>;<span class="hljs-comment">//1111 1110</span><br><span class="hljs-built_in">Delay500ms</span>();<br>P2=<span class="hljs-number">0xFF</span>;<span class="hljs-comment">//1111 1111</span><br><span class="hljs-built_in">Delay500ms</span>();<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>流水灯等等也是同样的道理。在单片机中main函数执行完一遍不会退出，而是会循环，因此想要终止在某一处，可以在main函数中加入一个while死循环。</p><h2 id="3-独立按键控制"><a href="#3-独立按键控制" class="headerlink" title="3 独立按键控制"></a>3 独立按键控制</h2><p>前置知识<br>1 控制八位灯中的某一位 采用这种写法<code>P2_i=0/1 </code>   i从0取到7 0为低电平，1为高电平。<br>2 看电路图可知按键接口断开时为1 按下时为2<br>3 按键按下的抖动导致电位并不是平整的，需要通过软件或硬件实现消抖。<br>消除抖动是重点研究对象<br><img src="https://picdl.sunbangyan.cn/2024/01/15/5fdc915810ca20ce99127f1c0f21792d.jpeg" alt="消抖"></p><h4 id="控制一个LED"><a href="#控制一个LED" class="headerlink" title="控制一个LED"></a>控制一个LED</h4><p><img src="https://picdl.sunbangyan.cn/2024/01/16/24c2211b60a8b325cca6b755f536ccf0.jpeg" alt="位运算"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;REGX52.H&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;INTRINS.H&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Delay</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> times)</span><span class="hljs-comment">//@11.0592MHz</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">while</span>(times)<br>&#123;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> i, j;<br><br>_nop_();<br>_nop_();<br>_nop_();<br>i = <span class="hljs-number">11</span>;<br>j = <span class="hljs-number">190</span>;<br><span class="hljs-keyword">do</span><br>&#123;<br><span class="hljs-keyword">while</span> (--j);<br>&#125; <span class="hljs-keyword">while</span> (--i);<br>   times--;<br>&#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">if</span>(P3_1==<span class="hljs-number">0</span>)<br>&#123;<br><br><span class="hljs-built_in">Delay</span>(<span class="hljs-number">20</span>);<br><span class="hljs-keyword">while</span>(P3_1==<span class="hljs-number">0</span>) <span class="hljs-built_in">Delay</span>(<span class="hljs-number">1</span>);    <span class="hljs-comment">//人手按下的速度是有限的，回弹也是如果判定还在按着按键，那么电位还不应该改变，继续截止。</span><br>P2_0=~P2_0;<br><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="独立按键控制LED移位"><a href="#独立按键控制LED移位" class="headerlink" title="独立按键控制LED移位"></a>独立按键控制LED移位</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;REGX52.H&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;INTRINS.H&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Delay</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> times)</span><span class="hljs-comment">//@11.0592MHz</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">while</span>(times)<br>&#123;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> i, j;<br><br>_nop_();<br>_nop_();<br>_nop_();<br>i = <span class="hljs-number">11</span>;<br>j = <span class="hljs-number">190</span>;<br><span class="hljs-keyword">do</span><br>&#123;<br><span class="hljs-keyword">while</span> (--j);<br>&#125; <span class="hljs-keyword">while</span> (--i);<br>   times--;<br>&#125;<br>&#125;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> LEDNum;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>P2=~<span class="hljs-number">0x01</span>;<br><span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)<br>&#123;<br><span class="hljs-keyword">if</span>(P3_1==<span class="hljs-number">0</span>)<br>&#123;<br><span class="hljs-built_in">Delay</span>(<span class="hljs-number">20</span>);<br><span class="hljs-keyword">while</span>(P3_1==<span class="hljs-number">0</span>);<br><span class="hljs-built_in">Delay</span>(<span class="hljs-number">20</span>);<br><br>LEDNum++;<br><span class="hljs-keyword">if</span>(LEDNum&gt;=<span class="hljs-number">8</span>)<br>LEDNum=<span class="hljs-number">0</span>;<br>P2=~(<span class="hljs-number">0x01</span>&lt;&lt;LEDNum);<br>&#125;<br><span class="hljs-keyword">if</span>(P3_0==<span class="hljs-number">0</span>)<br>&#123;<br><span class="hljs-built_in">Delay</span>(<span class="hljs-number">20</span>);<br><span class="hljs-keyword">while</span>(P3_0==<span class="hljs-number">0</span>);<br><span class="hljs-built_in">Delay</span>(<span class="hljs-number">20</span>);<br><br><span class="hljs-keyword">if</span>(LEDNum==<span class="hljs-number">0</span>)<br>LEDNum=<span class="hljs-number">7</span>;<br><span class="hljs-keyword">else</span><br>LEDNum--;<br>P2=~(<span class="hljs-number">0x01</span>&lt;&lt;LEDNum);<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="4-数码管显示"><a href="#4-数码管显示" class="headerlink" title="4 数码管显示"></a>4 数码管显示</h2><p>原理：参见 <a href="https://blog.csdn.net/Curnane0_0/article/details/114024408">51单片机（三）数码管（超详细、必会！）_数码管abcdefg对应-CSDN博客</a></p><h4 id="静态数码管显示数字"><a href="#静态数码管显示数字" class="headerlink" title="静态数码管显示数字"></a>静态数码管显示数字</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;REGX52.H&gt;</span></span><br><br><br><span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> NixieTable[]=&#123;<span class="hljs-number">0x3F</span>,<span class="hljs-number">0x06</span>,<span class="hljs-number">0x5B</span>,<span class="hljs-number">0x4F</span>,<span class="hljs-number">0x66</span>,<span class="hljs-number">0x6D</span>,<span class="hljs-number">0x7D</span>,<span class="hljs-number">0x07</span>,<span class="hljs-number">0x7F</span>,<span class="hljs-number">0x6F</span>&#125;;<br><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Nixie</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> Location,Number)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">switch</span>(Location)<br>&#123;<br><span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:P2_4=<span class="hljs-number">1</span>;P2_3=<span class="hljs-number">1</span>;P2_2=<span class="hljs-number">1</span>;<span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:P2_4=<span class="hljs-number">1</span>;P2_3=<span class="hljs-number">1</span>;P2_2=<span class="hljs-number">0</span>;<span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">case</span> <span class="hljs-number">3</span>:P2_4=<span class="hljs-number">1</span>;P2_3=<span class="hljs-number">0</span>;P2_2=<span class="hljs-number">1</span>;<span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">case</span> <span class="hljs-number">4</span>:P2_4=<span class="hljs-number">1</span>;P2_3=<span class="hljs-number">0</span>;P2_2=<span class="hljs-number">0</span>;<span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">case</span> <span class="hljs-number">5</span>:P2_4=<span class="hljs-number">0</span>;P2_3=<span class="hljs-number">1</span>;P2_2=<span class="hljs-number">1</span>;<span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">case</span> <span class="hljs-number">6</span>:P2_4=<span class="hljs-number">0</span>;P2_3=<span class="hljs-number">1</span>;P2_2=<span class="hljs-number">0</span>;<span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">case</span> <span class="hljs-number">7</span>:P2_4=<span class="hljs-number">0</span>;P2_3=<span class="hljs-number">0</span>;P2_2=<span class="hljs-number">1</span>;<span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">case</span> <span class="hljs-number">8</span>:P2_4=<span class="hljs-number">0</span>;P2_3=<span class="hljs-number">0</span>;P2_2=<span class="hljs-number">0</span>;<span class="hljs-keyword">break</span>;<br>&#125;<br>P0=NixieTable[Number];<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">Nixie</span>(<span class="hljs-number">2</span>,<span class="hljs-number">3</span>);<br><span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)<br>&#123;<br><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>如若想要动态显示，只需要引入延时函数，在显示不同数字的操作之间加上一段延时即可。</p><h2 id="5-模块化编程"><a href="#5-模块化编程" class="headerlink" title="5 模块化编程"></a>5 模块化编程</h2><p>几个图 <img src="https://picst.sunbangyan.cn/2024/01/20/9b967632f843810ba216242f1ad8fa10.jpeg"><br><img src="https://picst.sunbangyan.cn/2024/01/20/d3835b9eff193992e877281d12cf5d50.jpeg"></p><h2 id="6-矩阵键盘"><a href="#6-矩阵键盘" class="headerlink" title="6 矩阵键盘"></a>6 矩阵键盘</h2><p>我们有十六个按键，通过十六个独立通路实现对按键状态的检测是对IO口极大的浪费，因此为了减少I&#x2F;O口的占用，通常将按键排列成矩阵形式。采用逐行或逐列的“扫描”，就可以读出任何位置按键的状态。矩阵键盘扫（输入扫描）的原理：读取第1行(列)→读取第2行(列) →读取第3行(列) → ……，然后快速循环这个过程，最终实现所有按键同时检测的效果。这相当于我们读取了键盘的横纵坐标，因为每排（列）按键总是共用同一纵（横）坐标的，所以节省了资源。例如，要判断第一行S1、S2、S3、S4四个按键是否按下，则只需要先将P17接地，之后判断P13是否为0进而判断按键S1是否被按下，因为P17为低电平，若P13为低电平，则说明S1所在的电路导通了，即说明S1被按下，这与独立按键的原理一样。判断S2是否被按下，只需判断P12是否为0即可。要判断第一列S1、S5、S9、S13是否按下，可先将P13接地，然后判断P17、P16、P15、P14是否为0即可。代码实现矩阵按键数值显示 需要用到LCD1602.c文件（驱动程序）同时涉及到了之前独立按键控制LED灯的操作。</p><h4 id="返回一个整形的“键盘函数”MatrixKey"><a href="#返回一个整形的“键盘函数”MatrixKey" class="headerlink" title="返回一个整形的“键盘函数”MatrixKey()"></a>返回一个整形的“键盘函数”MatrixKey()</h4><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-comment">#include &lt;REGX52.H&gt;</span><br><span class="hljs-comment">#include &quot;Delay.h&quot;</span><br>  * @brief  矩阵键盘读取按键键码<br>  * @param  无<br>  * @retval KeyNumber 按下按键的键码值<br>如果按键按下不放，程序会停留在此函数，松手的一瞬间，返回按键键码，没有按键按下时，返回0<br>  */<br>unsigned char MatrixKey()<br>&#123;<br>unsigned char <span class="hljs-attribute">KeyNumber</span>=0;<br><br><span class="hljs-attribute">P1</span>=0xFF;<br><span class="hljs-attribute">P1_3</span>=0;<br><span class="hljs-keyword">if</span>(<span class="hljs-attribute">P1_7</span>==0)&#123;Delay(20);<span class="hljs-keyword">while</span>(<span class="hljs-attribute">P1_7</span>==0);Delay(20);KeyNumber=1;&#125;<br><span class="hljs-keyword">if</span>(<span class="hljs-attribute">P1_6</span>==0)&#123;Delay(20);<span class="hljs-keyword">while</span>(<span class="hljs-attribute">P1_6</span>==0);Delay(20);KeyNumber=5;&#125;<br><span class="hljs-keyword">if</span>(<span class="hljs-attribute">P1_5</span>==0)&#123;Delay(20);<span class="hljs-keyword">while</span>(<span class="hljs-attribute">P1_5</span>==0);Delay(20);KeyNumber=9;&#125;<br><span class="hljs-keyword">if</span>(<span class="hljs-attribute">P1_4</span>==0)&#123;Delay(20);<span class="hljs-keyword">while</span>(<span class="hljs-attribute">P1_4</span>==0);Delay(20);KeyNumber=13;&#125;<br><br><span class="hljs-attribute">P1</span>=0xFF;<br><span class="hljs-attribute">P1_2</span>=0;<br><span class="hljs-keyword">if</span>(<span class="hljs-attribute">P1_7</span>==0)&#123;Delay(20);<span class="hljs-keyword">while</span>(<span class="hljs-attribute">P1_7</span>==0);Delay(20);KeyNumber=2;&#125;<br><span class="hljs-keyword">if</span>(<span class="hljs-attribute">P1_6</span>==0)&#123;Delay(20);<span class="hljs-keyword">while</span>(<span class="hljs-attribute">P1_6</span>==0);Delay(20);KeyNumber=6;&#125;<br><span class="hljs-keyword">if</span>(<span class="hljs-attribute">P1_5</span>==0)&#123;Delay(20);<span class="hljs-keyword">while</span>(<span class="hljs-attribute">P1_5</span>==0);Delay(20);KeyNumber=10;&#125;<br><span class="hljs-keyword">if</span>(<span class="hljs-attribute">P1_4</span>==0)&#123;Delay(20);<span class="hljs-keyword">while</span>(<span class="hljs-attribute">P1_4</span>==0);Delay(20);KeyNumber=14;&#125;<br><br><span class="hljs-attribute">P1</span>=0xFF;<br><span class="hljs-attribute">P1_1</span>=0;<br><span class="hljs-keyword">if</span>(<span class="hljs-attribute">P1_7</span>==0)&#123;Delay(20);<span class="hljs-keyword">while</span>(<span class="hljs-attribute">P1_7</span>==0);Delay(20);KeyNumber=3;&#125;<br><span class="hljs-keyword">if</span>(<span class="hljs-attribute">P1_6</span>==0)&#123;Delay(20);<span class="hljs-keyword">while</span>(<span class="hljs-attribute">P1_6</span>==0);Delay(20);KeyNumber=7;&#125;<br><span class="hljs-keyword">if</span>(<span class="hljs-attribute">P1_5</span>==0)&#123;Delay(20);<span class="hljs-keyword">while</span>(<span class="hljs-attribute">P1_5</span>==0);Delay(20);KeyNumber=11;&#125;<br><span class="hljs-keyword">if</span>(<span class="hljs-attribute">P1_4</span>==0)&#123;Delay(20);<span class="hljs-keyword">while</span>(<span class="hljs-attribute">P1_4</span>==0);Delay(20);KeyNumber=15;&#125;<br><br><span class="hljs-attribute">P1</span>=0xFF;<br><span class="hljs-attribute">P1_0</span>=0;<br><span class="hljs-keyword">if</span>(<span class="hljs-attribute">P1_7</span>==0)&#123;Delay(20);<span class="hljs-keyword">while</span>(<span class="hljs-attribute">P1_7</span>==0);Delay(20);KeyNumber=4;&#125;<br><span class="hljs-keyword">if</span>(<span class="hljs-attribute">P1_6</span>==0)&#123;Delay(20);<span class="hljs-keyword">while</span>(<span class="hljs-attribute">P1_6</span>==0);Delay(20);KeyNumber=8;&#125;<br><span class="hljs-keyword">if</span>(<span class="hljs-attribute">P1_5</span>==0)&#123;Delay(20);<span class="hljs-keyword">while</span>(<span class="hljs-attribute">P1_5</span>==0);Delay(20);KeyNumber=12;&#125;<br><span class="hljs-keyword">if</span>(<span class="hljs-attribute">P1_4</span>==0)&#123;Delay(20);<span class="hljs-keyword">while</span>(<span class="hljs-attribute">P1_4</span>==0);Delay(20);KeyNumber=16;&#125;<br><br>return KeyNumber;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>EE</category>
      
      <category>51单片机</category>
      
    </categories>
    
    
    <tags>
      
      <tag>51单片机</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>排序算法</title>
    <link href="/2023/12/18/%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    <url>/2023/12/18/%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="排序算法（1）"><a href="#排序算法（1）" class="headerlink" title="排序算法（1）"></a>排序算法（1）</h1><h2 id="1-冒泡排序"><a href="#1-冒泡排序" class="headerlink" title="1.冒泡排序"></a>1.冒泡排序</h2><p>冒泡排序（Bubble Sort）它重复地走访过要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢”浮”到数列的顶端。<br>经典的实现是两层for循环<br>时间复杂度是O（n**2）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">bubble_sort</span><span class="hljs-params">(<span class="hljs-type">int</span> arr[], <span class="hljs-type">int</span> len)</span> </span>&#123;<br>        <span class="hljs-type">int</span> i, j, temp;<br>        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; len - <span class="hljs-number">1</span>; i++)                       <span class="hljs-comment">//背下第一个 i&lt;len-1</span><br>                <span class="hljs-keyword">for</span> (j = <span class="hljs-number">0</span>; j &lt; len - <span class="hljs-number">1</span> - i; j++)          <span class="hljs-comment">//背下第二个  j&lt;len-1-i</span><br>                        <span class="hljs-keyword">if</span> (arr[j] &gt; arr[j + <span class="hljs-number">1</span>]) &#123;<br>                                temp = arr[j];<br>                                arr[j] = arr[j + <span class="hljs-number">1</span>];<br>                                arr[j + <span class="hljs-number">1</span>] = temp;       <span class="hljs-comment">//大数沉底</span><br>                        &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-type">int</span> arr[] = &#123; <span class="hljs-number">22</span>, <span class="hljs-number">34</span>, <span class="hljs-number">3</span>, <span class="hljs-number">32</span>, <span class="hljs-number">82</span>, <span class="hljs-number">55</span>, <span class="hljs-number">89</span>, <span class="hljs-number">50</span>, <span class="hljs-number">37</span>, <span class="hljs-number">5</span>, <span class="hljs-number">64</span>, <span class="hljs-number">35</span>, <span class="hljs-number">9</span>, <span class="hljs-number">70</span> &#125;;<br>        <span class="hljs-type">int</span> len = <span class="hljs-built_in">sizeof</span>(arr) / <span class="hljs-built_in">sizeof</span>(arr[<span class="hljs-number">0</span>]);<br>        <span class="hljs-built_in">bubble_sort</span>(arr, len);<br>        <span class="hljs-type">int</span> i;<br>        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; len; i++)<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>, arr[i]);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>为了优化性能，考虑引入一个flag，当次序正常则不再进行交换</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span>  <span class="hljs-comment">// 冒泡排序，改进后在最优初条件下拥有最小时间复杂度 </span></span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">bubblesort</span><span class="hljs-params">(<span class="hljs-type">int</span>* a,<span class="hljs-type">int</span> n)</span>  <span class="hljs-comment">//规定a为指针则a可以作为数组名 </span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">bool</span> flag=<span class="hljs-literal">true</span>;  <span class="hljs-comment">//规定一个bool量，决定是否继续遍历，我们期望当遍历过一次后所有数据顺序均正确则停止遍历 </span><br><span class="hljs-keyword">while</span>(flag)<br>&#123;<br>flag=<span class="hljs-literal">false</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n<span class="hljs-number">-1</span>;i++)      <span class="hljs-comment">//注意a[i+1]变量范围，这里debug过 </span><br>&#123;<br><span class="hljs-keyword">if</span>(a[i]&gt;a[i<span class="hljs-number">+1</span>])&#123;<br>flag=<span class="hljs-literal">true</span>;<br><span class="hljs-type">int</span> t=a[i];<br>a[i]=a[i<span class="hljs-number">+1</span>];a[i<span class="hljs-number">+1</span>]=t;  <span class="hljs-comment">//经典不传交换 </span><br>&#125;<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> a[]=&#123;<span class="hljs-number">1</span>,<span class="hljs-number">5</span>,<span class="hljs-number">11</span>,<span class="hljs-number">6</span>,<span class="hljs-number">12</span>,<span class="hljs-number">7</span>,<span class="hljs-number">14</span>,<span class="hljs-number">9</span>,<span class="hljs-number">18</span>&#125;;<br><span class="hljs-type">int</span> n= <span class="hljs-built_in">sizeof</span>(a)/<span class="hljs-built_in">sizeof</span>(*a);     <br><span class="hljs-built_in">bubblesort</span>(a,n);<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;=n<span class="hljs-number">-1</span>;j++) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>,a[j]);   <span class="hljs-comment">//代入实参 </span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2-选择排序"><a href="#2-选择排序" class="headerlink" title="2.选择排序"></a>2.选择排序</h2><p>首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置。<br>再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。<br>重复第二步，直到所有元素均排序完毕。<br>无论怎样，这个算法的时间复杂度都是O（n**2）</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(<span class="hljs-type">int</span>*a,<span class="hljs-type">int</span>*b)</span>    <span class="hljs-comment">//传址交换 </span></span><br><span class="hljs-function">  </span>&#123;<br>  <span class="hljs-type">int</span> tem=*a;<br>  *a=*b;<br>  *b=tem;<br>  &#125;<br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">selectinsort</span><span class="hljs-params">(<span class="hljs-type">int</span>*a,<span class="hljs-type">int</span> len)</span></span><br><span class="hljs-function">  </span>&#123;     <br>  <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;=len<span class="hljs-number">-1</span>;i++)    <span class="hljs-comment">//外层遍历 </span><br>  &#123;   <span class="hljs-type">int</span> min=i;                  <span class="hljs-comment">//如果最小数在后len-1个里，那么最小数遍历完后会与数组第一个交换位置</span><br>                                <span class="hljs-comment">//如果第一个就是最小数，那么 最小数不会被比下去 </span><br>  <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=i<span class="hljs-number">+1</span>;j&lt;len;j++)<br>  &#123; <span class="hljs-keyword">if</span>(a[j]&lt;a[min]) min=j;&#125;<br>    <span class="hljs-built_in">swap</span>(&amp;a[i],&amp;a[min]);      <span class="hljs-comment">//每次内层循环出最小数，与a[i]交换位置 </span><br>  <br>&#125;<br>  &#125;<br></code></pre></td></tr></table></figure><h2 id="3-插入排序"><a href="#3-插入排序" class="headerlink" title="3.插入排序"></a>3.插入排序</h2><p>插入排序（英语：Insertion sort）它的工作原理为将待排列元素划分为「已排序」和「未排序」两部分，每次从「未排序的」元素中选择一个插入到「已排序的」元素中的正确位置。<br>演示升序排列算法</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insertion_sort</span><span class="hljs-params">(<span class="hljs-type">int</span> a[], <span class="hljs-type">int</span> len)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;len;i++)     <span class="hljs-comment">// i往后元素是待抽卡的堆 </span><br>&#123;<br><span class="hljs-type">int</span> j=i<span class="hljs-number">-1</span>;              <span class="hljs-comment">//j往前是要被逐个比较的堆 </span><br><span class="hljs-keyword">while</span>(j&gt;=<span class="hljs-number">0</span>&amp;&amp;a[i]&lt;a[j])<br>&#123;<br>a[j<span class="hljs-number">+1</span>]=a[j];<br>j--;<br>&#125;                         <span class="hljs-comment">//当a[j]&lt;a[i]跳出 j前一位空着 </span><br>a[j<span class="hljs-number">+1</span>]=a[i];<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="4-归并排序"><a href="#4-归并排序" class="headerlink" title="4.归并排序"></a>4.归并排序</h2><p>归并排序，先拆后并。将整个数组利用函数递归不断二分，直到无法二分为止。然后合并一个个有序数组。<br>时间复杂度O（nlogn)</p><p>私以为归并排序首先要写出归并函数merge.应当指出,实质性的排序过程发生在merge函数里，下面递归时，堆栈过程中只是在不断二分数组。</p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs excel">void merge(<span class="hljs-built_in">int</span> *a,<span class="hljs-built_in">int</span> <span class="hljs-built_in">left</span>,<span class="hljs-built_in">int</span> <span class="hljs-built_in">mid</span>,<span class="hljs-built_in">int</span> <span class="hljs-built_in">right</span>)                                         //传入<span class="hljs-built_in">int</span>*a是为了方便的使用数组中元素<br>&#123;<br><span class="hljs-built_in">int</span> i=<span class="hljs-built_in">left</span>,j=<span class="hljs-built_in">mid</span>+<span class="hljs-number">1</span>,k=<span class="hljs-number">0</span>;    //i代表左数组起始，j代表右数组起始 <br><span class="hljs-built_in">int</span> *temp=(<span class="hljs-built_in">int</span>*)malloc((<span class="hljs-built_in">right</span>-<span class="hljs-built_in">left</span>+<span class="hljs-number">1</span>)*sizeof(<span class="hljs-built_in">int</span>));<br>while(i&lt;=<span class="hljs-built_in">mid</span>&amp;&amp;j&lt;=<span class="hljs-built_in">right</span>)    //循环直到一个数组变空 <br>&#123;<br><span class="hljs-built_in">if</span>(a[i]&lt;a[j])<br>&#123;<br>temp[k]=a[i];<br>k++;i++;<br>&#125;<br>else<br>&#123;<br>temp[k]=a[j];<br>k++;j++;<br>&#125;<br><br>&#125;<br>for(;i&lt;=<span class="hljs-built_in">mid</span>;i++,k++) temp[k]=a[i];           //把剩下的还有数的数组存放进temp之中去<br>for(;j&lt;=<span class="hljs-built_in">right</span>;j++,k++) temp[k]=a[j];<br>for(i = <span class="hljs-number">0</span>; i &lt; k; i++)               //注意一定要讲temp数组复制到a数组之中去。<br>        a[<span class="hljs-built_in">left</span>++] = temp[i]; <br>&#125;<br></code></pre></td></tr></table></figure><p>然后进行递归即可。</p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs excel">void merge_sort(<span class="hljs-built_in">int</span> arr[], <span class="hljs-built_in">int</span> <span class="hljs-built_in">left</span>, <span class="hljs-built_in">int</span> <span class="hljs-built_in">right</span>)<br>&#123;<br><span class="hljs-built_in">if</span> (<span class="hljs-built_in">left</span> &lt; <span class="hljs-built_in">right</span>) &#123; // 如果左边界小于右边界，说明序列中至少有两个元素<br><span class="hljs-built_in">int</span> <span class="hljs-built_in">mid</span> = (<span class="hljs-built_in">left</span> + <span class="hljs-built_in">right</span>) / <span class="hljs-number">2</span>; //<br>merge_sort(arr, <span class="hljs-built_in">left</span>, <span class="hljs-built_in">mid</span>); // 对左半部分的序列递归<br>merge_sort(arr, <span class="hljs-built_in">mid</span> + <span class="hljs-number">1</span>, <span class="hljs-built_in">right</span>); // 对右半部分的序列递归序<br>merge(arr, <span class="hljs-built_in">left</span>, <span class="hljs-built_in">mid</span>, <span class="hljs-built_in">right</span>); // 将左右两个有序的子序列合并成一个有序的序列<br>&#125;<br>&#125;                     //可以发现只有merge后函数才能到达出口，因此总可以确保最后最小单元序列merge<br></code></pre></td></tr></table></figure><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-comment">// 测试代码</span><br><span class="hljs-function"><span class="hljs-built_in">int</span> <span class="hljs-title">main</span>()</span><br>&#123;<br><span class="hljs-built_in">int</span> arr[] = &#123;<span class="hljs-number">7</span>, <span class="hljs-number">5</span>, <span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-number">1</span>, <span class="hljs-number">6</span>, <span class="hljs-number">3</span>, <span class="hljs-number">0</span>&#125;;     <span class="hljs-built_in">int</span> len = <span class="hljs-keyword">sizeof</span>(arr) / <span class="hljs-keyword">sizeof</span>(<span class="hljs-built_in">int</span>); <span class="hljs-comment">// 计算序列的长度</span><br>merge_sort(arr, <span class="hljs-number">0</span>, len - <span class="hljs-number">1</span>);<br><span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i++)<br>&#123;<br>printf(<span class="hljs-string">&quot;%d &quot;</span>, arr[i]);<br>&#125;<br>printf(<span class="hljs-string">&quot;\n&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="5-快速排序"><a href="#5-快速排序" class="headerlink" title="5.快速排序"></a>5.快速排序</h3><p>快速排序是一种非常巧妙的排序方式，它仍然运用了分治的思想。</p><p>快速排序的思路大概是这样的，取数组中任意一个数为基准base（一般取第一个数），通过下述方法使得base左边的数都比它小，base右边的数都比它大。再对左右子序列分而治之。</p><p>引入两个索引indexl和indexr。取第一个数为base，从最右向左寻找（insexr–），直到找到比base更小的数，交换base与这个数的位置，<strong>此时base右边的数一定都是比base大的数</strong>，此时从左向右（indexl++）寻找，以此类推，直到<code>indexr=indexl</code>,排序结束。我一开始的思路是这样的，自己搓出来一个比较臃肿的函数。</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs routeros">void partition(int<span class="hljs-number">*a</span>,int p,int q)<br>&#123;<br>int temp;<br>int <span class="hljs-attribute">r</span>=q;<br>int <span class="hljs-attribute">l</span>=p;<br>int <span class="hljs-attribute">base</span>=p;<br><span class="hljs-keyword">while</span>(1)<br>&#123;<br><span class="hljs-keyword">while</span>(l&lt;r&amp;&amp;a[r]&gt;=a[base])<br>&#123;<br>r--;<br>&#125;<br><span class="hljs-keyword">if</span>(<span class="hljs-attribute">l</span>==r) break;                                              <br>        <span class="hljs-attribute">temp</span>=a[base];<br>        a[base]=a[r];<br>        a[r]=temp;<br><span class="hljs-attribute">base</span>=r;<br><span class="hljs-keyword">while</span>(l&lt;r&amp;&amp;a[l]&lt;=a[base])<br>&#123;<br>l++;<br>&#125;<br><span class="hljs-keyword">if</span>(<span class="hljs-attribute">l</span>==r) break;<br><span class="hljs-attribute">temp</span>=a[base];<br>        a[base]=a[l];<br>        a[l]=temp;<br><span class="hljs-attribute">base</span>=l;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这个函数不太好的地方在于交换确实是具象的交换，而且还要判定两次break；写起来比较麻烦，但是比较容易理解，动态性比较强。还有一种更简明的写法，就是不把base交换来交换去，最后再把base填回来。<br>从右向左寻找，找到比base小的a[r]之后赋值给a[l],这样a[l]及其左边都比base小，再从左向右找，找到a[l]大于base，a[l]赋值给a[r]······这像一个堆积过程，左边堆积比base小的数，右边堆积比base大的数，当左右相遇，把相遇点赋值为base即可。(此处手模一下l&#x3D;r 的时候发生了什么，这里重合的时候，重合点是等于上一个索引的元素值的这就是说重合点元素重复了两次，所以接下来要把缺失的base放在这个位置。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">partition</span>(<span class="hljs-params"><span class="hljs-built_in">int</span>* a, <span class="hljs-built_in">int</span> p, <span class="hljs-built_in">int</span> q</span>)</span><br>&#123;<br><span class="hljs-built_in">int</span> temp;<br><span class="hljs-built_in">int</span> l = p;<br><span class="hljs-built_in">int</span> r = q;<br><span class="hljs-built_in">int</span> <span class="hljs-keyword">base</span> = a[p];<br><span class="hljs-keyword">while</span>(l &lt; r)<br>&#123;<br><span class="hljs-keyword">while</span>(l &lt; r &amp;&amp; a[r] &gt;= <span class="hljs-keyword">base</span>) r--;<br>a[l] = a[r];<br><span class="hljs-keyword">while</span>(l &lt; r &amp;&amp; a[l] &lt;= <span class="hljs-keyword">base</span>) l++;<br>a[r] = a[l];<br>&#125;<br>a[l] = <span class="hljs-keyword">base</span>;   <span class="hljs-comment">//or a[r]=base</span><br>&#125;<br></code></pre></td></tr></table></figure><p>为了方便下面的操作，我们利用partition函数返回最后的l或者r，作为分治时分区的标准。<br>完整代码如下</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-meta">#include&lt;stdio.h&gt;</span><br><span class="hljs-meta">#include&lt;string.h&gt;</span><br><span class="hljs-meta">#include&lt;stdlib.h&gt;</span><br><span class="hljs-type">int</span> <span class="hljs-keyword">partition</span>(<span class="hljs-type">int</span>* a, <span class="hljs-type">int</span> p, <span class="hljs-type">int</span> q)<br>&#123;<br>    <span class="hljs-type">int</span> <span class="hljs-keyword">temp</span>;<br>    <span class="hljs-type">int</span> l = p;<br>    <span class="hljs-type">int</span> r = q;<br>    <span class="hljs-type">int</span> base = a[p];<br>    <span class="hljs-keyword">while</span>(l &lt; r)<br>    &#123;<br>        <span class="hljs-keyword">while</span>(l &lt; r &amp;&amp; a[r] &gt;= base) r<span class="hljs-comment">--;</span><br>        a[l] = a[r];<br>        <span class="hljs-keyword">while</span>(l &lt; r &amp;&amp; a[l] &lt;= base) l++;<br>        a[r] = a[l];<br>    &#125;<br>    a[l] = base;   //<span class="hljs-keyword">or</span> a[r]=base<br>    <span class="hljs-keyword">return</span> l;<br>&#125;<br><span class="hljs-type">void</span> quick_sort(<span class="hljs-type">int</span> *a,<span class="hljs-type">int</span> p,<span class="hljs-type">int</span> q)<br>&#123;<br><span class="hljs-keyword">if</span>(p&gt;=q)  <span class="hljs-keyword">return</span>;<br><span class="hljs-type">int</span> mid=<span class="hljs-keyword">partition</span>(a,p,q);<br>quick_sort(a,p,mid);<br>quick_sort(a,mid+<span class="hljs-number">1</span>,q);<br>&#125;<br><span class="hljs-type">int</span> main()<br>&#123;<br><span class="hljs-type">int</span> a[<span class="hljs-number">10</span>]=&#123;<span class="hljs-number">2</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">5</span>,<span class="hljs-number">4</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">9</span>,<span class="hljs-number">8</span>&#125;;<br>quick_sort(a,<span class="hljs-number">0</span>,<span class="hljs-number">9</span>);<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">10</span>;i++) printf(&quot;%d &quot;,a[i]);<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>基础算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ctree</title>
    <link href="/2023/12/11/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/ctree/"/>
    <url>/2023/12/11/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/ctree/</url>
    
    <content type="html"><![CDATA[<h1 id="c语言实现树（二叉树）"><a href="#c语言实现树（二叉树）" class="headerlink" title="c语言实现树（二叉树）"></a>c语言实现树（二叉树）</h1><h2 id="树的理解"><a href="#树的理解" class="headerlink" title="树的理解"></a>树的理解</h2><p><strong>树是一种非线性的数据结构，它是由 n (n&gt;&#x3D;0)个有限结点组成的一个具有层次关系的集合。</strong><br>• 结点的度：一个结点含有的子树个数（结点下的分支） 如结点A的度为5；<br>• 树的度：一棵树中最大的结点的度 如上树的度为5；<br>• 结点的层次：根是第1层，根的子节点所在层是第2层，如此递增；<br>• 树的高(深)度：最大的结点的层次 如上树的高(深)度是4；<br>• 叶子结点：度为0的结点（没有子树） 如结点 N，O；<br>• 双亲结点：如A是B，C，D，E，F的双亲结点；<br>• (孩)子结点：如B，C，D，E，F是A的(孩)子结点；<br>• 兄弟结点：具有相同双亲结点的子节点 如G，H；<br>• 堂兄弟结点：双亲在同一层的结点互为堂兄弟结点 如H，I；<br>• 非终端结点&#x2F;分支结点：度不为0的结点 如C，D，E…；<br>• 结点的祖先：从根节点所经分支上的所有结点 如A是所有结点的祖先；</p><h2 id="二叉树插入节点"><a href="#二叉树插入节点" class="headerlink" title="二叉树插入节点"></a>二叉树插入节点</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdlib.h&gt;</span>  <span class="hljs-comment">//左小右大 </span></span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Node</span>&#123;<br><span class="hljs-type">int</span> data;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Node</span>* left;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Node</span>* right;<br>&#125;;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Node</span>*<span class="hljs-built_in">GetNewnode</span>(<span class="hljs-type">int</span> data)<br>&#123;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Node</span>* newnode=(<span class="hljs-keyword">struct</span> Node*)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span>(<span class="hljs-keyword">struct</span> Node));<br>newnode-&gt;data=data;<br>newnode-&gt;left=<span class="hljs-literal">NULL</span>;<br>newnode-&gt;right=<span class="hljs-literal">NULL</span>;<br> &#125; <br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Node</span>*<span class="hljs-built_in">Insert</span>(<span class="hljs-keyword">struct</span> Node* root,<span class="hljs-type">int</span> data)  <span class="hljs-comment">//我们想知道的是基于原有的root，插入一个data得到的新地址 </span><br>   <span class="hljs-keyword">if</span>(root==<span class="hljs-literal">NULL</span>)&#123;<br>   root=<span class="hljs-built_in">GetNewnode</span>(data);<br>   &#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(data&lt;=root-&gt;data)&#123;<br>root-&gt;left=<span class="hljs-built_in">Insert</span>(root-&gt;left,data);<br>&#125;<br><span class="hljs-keyword">else</span> &#123;<br>root-&gt;right=<span class="hljs-built_in">Insert</span>(root-&gt;right,data);<br>&#125;<br><span class="hljs-keyword">return</span> root;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">Search</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> Node* root,<span class="hljs-type">int</span> data)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">if</span>(root==<span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(root-&gt;data==data) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(data&lt;=root-&gt;data) <span class="hljs-keyword">return</span> <span class="hljs-built_in">Search</span>(root-&gt;left,data);<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-built_in">Search</span>(root-&gt;right,data);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="树的高度"><a href="#树的高度" class="headerlink" title="树的高度"></a>树的高度</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Node</span>&#123;<br><span class="hljs-type">int</span> data;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Node</span>* left;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Node</span>* right;<br>&#125;;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Node</span>* root;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">max</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b)</span></span>&#123;<br><span class="hljs-keyword">if</span>(a&gt;=b) <span class="hljs-keyword">return</span> a;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> b;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Height</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> Node*root)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">if</span>(root==<span class="hljs-literal">NULL</span>)<br>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(<span class="hljs-built_in">Height</span>(root-&gt;left),<span class="hljs-built_in">Height</span>(root-&gt;right))<span class="hljs-number">+1</span>;<br><br> &#125;<br></code></pre></td></tr></table></figure><h2 id="寻找最小值"><a href="#寻找最小值" class="headerlink" title="寻找最小值"></a>寻找最小值</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdlib.h&gt;</span> </span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Node</span>&#123;<br><span class="hljs-type">int</span> data;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Node</span>* left;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Node</span>* right;<br>&#125;;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Node</span>* root;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Min</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> Node* root)</span>                                          <span class="hljs-comment">//找最小值函数</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">if</span>(root==<span class="hljs-literal">NULL</span>)<br>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;tree is empty！&quot;</span>); <br><span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;                                                     <span class="hljs-comment">//结束条件</span><br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(root-&gt;left==<span class="hljs-literal">NULL</span>)&#123;<br> <span class="hljs-keyword">return</span> root-&gt;data;                                       <span class="hljs-comment">//不断向左递归</span><br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-built_in">Min</span>(root-&gt;left); <br>&#125;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Node</span>*<span class="hljs-built_in">GetNewnode</span>(<span class="hljs-type">int</span> data)<br>&#123;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Node</span>* newnode=(<span class="hljs-keyword">struct</span> Node*)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span>(<span class="hljs-keyword">struct</span> Node));<br>newnode-&gt;data=data;<br>newnode-&gt;left=<span class="hljs-literal">NULL</span>;<br>newnode-&gt;right=<span class="hljs-literal">NULL</span>;<br> &#125; <br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Node</span>*<span class="hljs-built_in">Insert</span>(<span class="hljs-keyword">struct</span> Node* root,<span class="hljs-type">int</span> data)&#123;  址 <br>   <span class="hljs-keyword">if</span>(root==<span class="hljs-literal">NULL</span>)&#123;<br>   root=<span class="hljs-built_in">GetNewnode</span>(data);<br>   &#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(data&lt;=root-&gt;data)&#123;<br>root-&gt;left=<span class="hljs-built_in">Insert</span>(root-&gt;left,data);<br>&#125;<br><span class="hljs-keyword">else</span> &#123;<br>root-&gt;right=<span class="hljs-built_in">Insert</span>(root-&gt;right,data);<br>&#125;<br><span class="hljs-keyword">return</span> root;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>root=<span class="hljs-literal">NULL</span>;<br>    root=<span class="hljs-built_in">Insert</span>(root,<span class="hljs-number">2</span>);<br>    root=<span class="hljs-built_in">Insert</span>(root,<span class="hljs-number">3</span>);<br>    root=<span class="hljs-built_in">Insert</span>(root,<span class="hljs-number">4</span>);<br>    root=<span class="hljs-built_in">Insert</span>(root,<span class="hljs-number">5</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>,<span class="hljs-built_in">Min</span>(root));<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h2><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-meta">#include&lt;iostream&gt;</span><br><span class="hljs-meta">#include&lt;queue&gt;</span><br><span class="hljs-keyword">using</span> namespace std;<br><br>struct Node &#123;<br><span class="hljs-type">char</span> data;<br>Node *left;<br>Node *right;<br>&#125;;<br><br>// <span class="hljs-keyword">Function</span> <span class="hljs-keyword">to</span> print Nodes <span class="hljs-keyword">in</span> a binary tree <span class="hljs-keyword">in</span> <span class="hljs-keyword">Level</span> <span class="hljs-keyword">order</span><br><span class="hljs-type">void</span> LevelOrder(Node *root) &#123;<br><span class="hljs-keyword">if</span>(root == <span class="hljs-keyword">NULL</span>) <span class="hljs-keyword">return</span>;<br>queue&lt;Node*&gt; Q;<br>Q.push(root);  <br>//<span class="hljs-keyword">while</span> there <span class="hljs-keyword">is</span> at least one discovered node<br><span class="hljs-keyword">while</span>(!Q.empty()) &#123;<br>Node* <span class="hljs-keyword">current</span> = Q.front();<br>Q.pop(); // removing the element at front<br>cout&lt;&lt;<span class="hljs-keyword">current</span>-&gt;data&lt;&lt;&quot; &quot;;<br><span class="hljs-keyword">if</span>(<span class="hljs-keyword">current</span>-&gt;left != <span class="hljs-keyword">NULL</span>) Q.push(<span class="hljs-keyword">current</span>-&gt;left);<br><span class="hljs-keyword">if</span>(<span class="hljs-keyword">current</span>-&gt;right != <span class="hljs-keyword">NULL</span>) Q.push(<span class="hljs-keyword">current</span>-&gt;right);<br>&#125;<br>&#125;<br>// <span class="hljs-keyword">Function</span> <span class="hljs-keyword">to</span> <span class="hljs-keyword">Insert</span> Node <span class="hljs-keyword">in</span> a Binary <span class="hljs-keyword">Search</span> Tree<br>Node* <span class="hljs-keyword">Insert</span>(Node *root,<span class="hljs-type">char</span> data) &#123;<br><span class="hljs-keyword">if</span>(root == <span class="hljs-keyword">NULL</span>) &#123;<br>root = <span class="hljs-built_in">new</span> Node();<br>root-&gt;data = data;<br>root-&gt;left = root-&gt;right = <span class="hljs-keyword">NULL</span>;<br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(data &lt;= root-&gt;data) root-&gt;left = <span class="hljs-keyword">Insert</span>(root-&gt;left,data);<br><span class="hljs-keyword">else</span> root-&gt;right = <span class="hljs-keyword">Insert</span>(root-&gt;right,data);<br><span class="hljs-keyword">return</span> root;<br>&#125;<br><br><span class="hljs-type">int</span> main() &#123;<br><span class="hljs-comment">/*Code To Test the logic</span><br><span class="hljs-comment">  Creating an example tree</span><br><span class="hljs-comment">            M</span><br><span class="hljs-comment">   / \</span><br><span class="hljs-comment">  B   Q</span><br><span class="hljs-comment"> / \   \</span><br><span class="hljs-comment">A   C   Z</span><br><span class="hljs-comment">    */</span><br>Node* root = <span class="hljs-keyword">NULL</span>;<br>root = <span class="hljs-keyword">Insert</span>(root,<span class="hljs-string">&#x27;M&#x27;</span>); root = <span class="hljs-keyword">Insert</span>(root,<span class="hljs-string">&#x27;B&#x27;</span>);<br>root = <span class="hljs-keyword">Insert</span>(root,<span class="hljs-string">&#x27;Q&#x27;</span>); root = <span class="hljs-keyword">Insert</span>(root,<span class="hljs-string">&#x27;Z&#x27;</span>); <br>root = <span class="hljs-keyword">Insert</span>(root,<span class="hljs-string">&#x27;A&#x27;</span>); root = <span class="hljs-keyword">Insert</span>(root,<span class="hljs-string">&#x27;C&#x27;</span>);<br>//Print Nodes <span class="hljs-keyword">in</span> <span class="hljs-keyword">Level</span> <span class="hljs-keyword">Order</span>. <br>LevelOrder(root);<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
      <category>c语言实现基本数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>c语言</tag>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>clist</title>
    <link href="/2023/12/11/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/clist/"/>
    <url>/2023/12/11/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/clist/</url>
    
    <content type="html"><![CDATA[<h1 id="c语言实现队列"><a href="#c语言实现队列" class="headerlink" title="c语言实现队列"></a>c语言实现队列</h1><h2 id="栈的理解"><a href="#栈的理解" class="headerlink" title="栈的理解"></a>栈的理解</h2><p>队列(Queue)需要两个特征描述，队头（front）和队尾（rear），顾名思义，排队时后来者应跟在队尾，最前面的人应当最先出队</p><h2 id="队列实现"><a href="#队列实现" class="headerlink" title="队列实现"></a>队列实现</h2><h4 id="数组实现"><a href="#数组实现" class="headerlink" title="数组实现"></a>数组实现</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAX 3</span><br><span class="hljs-type">int</span> arr[MAX];<br><span class="hljs-type">int</span> front, rear;<br><span class="hljs-type">bool</span> <span class="hljs-title function_">isEmpty</span><span class="hljs-params">()</span>&#123;<br><span class="hljs-keyword">return</span> (front == <span class="hljs-number">-1</span> &amp;&amp; rear == <span class="hljs-number">-1</span>) ? <span class="hljs-literal">true</span> : <span class="hljs-literal">false</span>;<br>&#125;<br><br><span class="hljs-type">bool</span> <span class="hljs-title function_">isFull</span><span class="hljs-params">()</span>&#123;<br><span class="hljs-keyword">return</span> (rear+<span class="hljs-number">1</span>)%MAX == front ? <span class="hljs-literal">true</span> : <span class="hljs-literal">false</span>;<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">enQueue</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span>&#123;<br><span class="hljs-keyword">if</span>(isFull())&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;queue is full\n&quot;</span>);<br><span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-keyword">if</span>(isEmpty())<br>front = rear = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">else</span><br>rear = (rear+<span class="hljs-number">1</span>)%MAX;<br>arr[rear] = x;<br>&#125;<br><span class="hljs-type">void</span> <span class="hljs-title function_">deQueue</span><span class="hljs-params">()</span>&#123;<br><span class="hljs-keyword">if</span>(isEmpty())<br>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;queue is empty\n&quot;</span>);<br><span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(front == rear)<br>front = rear = <span class="hljs-number">-1</span>;<br><span class="hljs-keyword">else</span><br>front = (front+<span class="hljs-number">1</span>)%MAX;<br><br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">Print</span><span class="hljs-params">()</span>&#123;<br><span class="hljs-type">int</span> length = (rear + MAX - front)%MAX + <span class="hljs-number">1</span>;<br><span class="hljs-type">int</span> i;<br><span class="hljs-keyword">for</span>( i = <span class="hljs-number">0</span>; i&lt;length;i++)<br>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>, arr[(front+i)%MAX]);<br>&#125;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>&#123;<br>front = <span class="hljs-number">-1</span>;<br>rear = <span class="hljs-number">-1</span>;<br>enQueue(<span class="hljs-number">2</span>); Print();<br>enQueue(<span class="hljs-number">4</span>); Print();<br>enQueue(<span class="hljs-number">6</span>); Print();<br>deQueue(); Print();<br>enQueue(<span class="hljs-number">10</span>); Print();<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="链表实现-这是真没用）"><a href="#链表实现-这是真没用）" class="headerlink" title="链表实现(这是真没用）"></a>链表实现(这是真没用）</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Node</span> &#123;<br><span class="hljs-type">int</span> data;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Node</span>* next;<br>&#125;;<br><span class="hljs-comment">// Two glboal variables to store address of front and rear nodes. </span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Node</span>* front = <span class="hljs-literal">NULL</span>;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Node</span>* rear = <span class="hljs-literal">NULL</span>;<br><br><span class="hljs-comment">// To Enqueue an integer</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Enqueue</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Node</span>* temp = <br>(<span class="hljs-keyword">struct</span> Node*)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span>(<span class="hljs-keyword">struct</span> Node));<br>temp-&gt;data =x; <br>temp-&gt;next = <span class="hljs-literal">NULL</span>;<br><span class="hljs-keyword">if</span>(front == <span class="hljs-literal">NULL</span> &amp;&amp; rear == <span class="hljs-literal">NULL</span>)&#123;<br>front = rear = temp;<br><span class="hljs-keyword">return</span>;<br>&#125;<br>rear-&gt;next = temp;<br>rear = temp;<br>&#125;<br><br><span class="hljs-comment">// To Dequeue an integer.</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Dequeue</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Node</span>* temp = front;<br><span class="hljs-keyword">if</span>(front == <span class="hljs-literal">NULL</span>) &#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Queue is Empty\n&quot;</span>);<br><span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-keyword">if</span>(front == rear) &#123;<br>front = rear = <span class="hljs-literal">NULL</span>;<br>&#125;<br><span class="hljs-keyword">else</span> &#123;<br>front = front-&gt;next;<br>&#125;<br><span class="hljs-built_in">free</span>(temp);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Front</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">if</span>(front == <span class="hljs-literal">NULL</span>) &#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Queue is empty\n&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-keyword">return</span> front-&gt;data;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Print</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Node</span>* temp = front;<br><span class="hljs-keyword">while</span>(temp != <span class="hljs-literal">NULL</span>) &#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>,temp-&gt;data);<br>temp = temp-&gt;next;<br>&#125;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-comment">/* Drive code to test the implementation. */</span><br><span class="hljs-comment">// Printing elements in Queue after each Enqueue or Dequeue </span><br><span class="hljs-built_in">Enqueue</span>(<span class="hljs-number">2</span>); <span class="hljs-built_in">Print</span>(); <br><span class="hljs-built_in">Enqueue</span>(<span class="hljs-number">4</span>); <span class="hljs-built_in">Print</span>();<br><span class="hljs-built_in">Enqueue</span>(<span class="hljs-number">6</span>); <span class="hljs-built_in">Print</span>();<br><span class="hljs-built_in">Dequeue</span>();  <span class="hljs-built_in">Print</span>();<br><span class="hljs-built_in">Enqueue</span>(<span class="hljs-number">8</span>); <span class="hljs-built_in">Print</span>();<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
      <category>c语言实现基本数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>c语言</tag>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>c栈</title>
    <link href="/2023/12/11/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/c%E6%A0%88/"/>
    <url>/2023/12/11/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/c%E6%A0%88/</url>
    
    <content type="html"><![CDATA[<h1 id="c语言实现栈"><a href="#c语言实现栈" class="headerlink" title="c语言实现栈"></a>c语言实现栈</h1><h2 id="栈的理解"><a href="#栈的理解" class="headerlink" title="栈的理解"></a>栈的理解</h2><p>栈遵从（first in last out）原则，从栈顶弹出的元素是最后放入栈的元素。函数中递归的调用就利用了栈的数据结构。使用数组或链表可以模拟这一数据结构。</p><h2 id="栈的实现"><a href="#栈的实现" class="headerlink" title="栈的实现"></a>栈的实现</h2><h4 id="数组实现栈"><a href="#数组实现栈" class="headerlink" title="数组实现栈"></a>数组实现栈</h4><p>虽然但是，c++stl里面都是有这些函数的，手写一遍只是为了了解底层的实现。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAX_SIZE 101</span><br><span class="hljs-type">int</span> a[MAX_SIZE];<br><span class="hljs-type">int</span> top=<span class="hljs-number">-1</span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Push</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span>      <span class="hljs-comment">//入栈</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">if</span>(top=MAX_SIZE<span class="hljs-number">-1</span>)<br>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;error&quot;</span>);<br><span class="hljs-keyword">return</span>;<br>&#125;<br>top++;<br>a[top]=x;<br><br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Top</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-keyword">return</span> a[top];<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pop</span><span class="hljs-params">()</span>                      <span class="hljs-comment">//弹出栈顶元素</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">if</span>(top==<span class="hljs-number">-1</span>)<br>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;error&quot;</span>);<br><span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-keyword">else</span> top--;<br><br> &#125; <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">Push</span>(<span class="hljs-number">2</span>);<br><span class="hljs-built_in">Push</span>(<span class="hljs-number">3</span>);<br><span class="hljs-built_in">pop</span>();<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="链表实现栈"><a href="#链表实现栈" class="headerlink" title="链表实现栈"></a>链表实现栈</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Node</span>&#123;<br><span class="hljs-type">int</span> data;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Node</span>* next;<br>&#125;;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Node</span>* top=<span class="hljs-literal">NULL</span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Push</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Node</span>* temp=(<span class="hljs-keyword">struct</span> Node*)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span>(<span class="hljs-keyword">struct</span> Node)); <br>temp-&gt;next=top;<br>temp-&gt;data=x;<br>top=temp;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Pop</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Node</span>* temp=top;<br><span class="hljs-keyword">if</span>(top==<span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span>;<br>top=top-&gt;next;<br><span class="hljs-built_in">free</span>(temp);<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Print</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Node</span>* temp;<br>temp=top;<br><span class="hljs-keyword">while</span>(temp!=<span class="hljs-literal">NULL</span>)<br>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>,temp-&gt;data);<br>temp=temp-&gt;next;<br><br>&#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">Push</span>(<span class="hljs-number">1</span>);<br><span class="hljs-built_in">Push</span>(<span class="hljs-number">2</span>);<br><span class="hljs-built_in">Push</span>(<span class="hljs-number">3</span>);<br><span class="hljs-built_in">Push</span>(<span class="hljs-number">4</span>);<br><span class="hljs-built_in">Pop</span>();<br><span class="hljs-built_in">Print</span>();<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="利用栈反转字符串"><a href="#利用栈反转字符串" class="headerlink" title="利用栈反转字符串"></a>利用栈反转字符串</h2><p>使用#include”stack” 内置函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stack&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Reverse</span><span class="hljs-params">(<span class="hljs-type">char</span>*c,<span class="hljs-type">int</span> n)</span></span><br><span class="hljs-function"></span>&#123;<br>stack&lt;<span class="hljs-type">char</span>&gt; S;                         <span class="hljs-comment">//创建一个栈 S</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)<br>&#123;<br>S.<span class="hljs-built_in">push</span>(c[i]);<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)<br>&#123;<br>c[i]=S.<span class="hljs-built_in">top</span>();<br>S.<span class="hljs-built_in">pop</span>();<br><br>&#125;<br> &#125; <br> <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"> </span>&#123;<br> <span class="hljs-type">char</span> c[<span class="hljs-number">100</span>];<br> <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%s&quot;</span>,c);<br> <span class="hljs-built_in">Reverse</span>(c,<span class="hljs-built_in">strlen</span>(c));<br> <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s&quot;</span>,c); <br> &#125;<br></code></pre></td></tr></table></figure><h2 id="利用栈反转一个链表"><a href="#利用栈反转一个链表" class="headerlink" title="利用栈反转一个链表"></a>利用栈反转一个链表</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stack&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Node</span>&#123;<br><span class="hljs-type">int</span> data;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Node</span>* next;<br>&#125;;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Node</span>* head; <br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Reverse</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-keyword">if</span>(head==<span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span>;<br>stack&lt;<span class="hljs-keyword">struct</span> Node*&gt; S;<br>Node* temp=head;<br><span class="hljs-keyword">while</span>(temp!=<span class="hljs-literal">NULL</span>)<br>&#123;<br>S.<span class="hljs-built_in">push</span>(temp);       <span class="hljs-comment">//按链表顺序入栈 栈顶为链表最后一节点 </span><br>temp=temp-&gt;next; <br><br>&#125;<br>temp=S.<span class="hljs-built_in">top</span>();     <span class="hljs-comment">//设置最后一个节点为head </span><br>head=temp;<br>S.<span class="hljs-built_in">pop</span>();            <span class="hljs-comment">//弹栈 栈顶为链表前一个节点 </span><br><span class="hljs-keyword">while</span>(!S.<span class="hljs-built_in">empty</span>())&#123;<br>temp-&gt;next=S.<span class="hljs-built_in">top</span>();     <span class="hljs-comment">//改变指向 </span><br>S.<span class="hljs-built_in">pop</span>();                <span class="hljs-comment">//弹栈 </span><br>temp=temp-&gt;next;        <span class="hljs-comment">//temp 前移 </span><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="经典面试题，检查括号匹配"><a href="#经典面试题，检查括号匹配" class="headerlink" title="经典面试题，检查括号匹配"></a>经典面试题，检查括号匹配</h2><p>这让我想起来学校出的羊了个羊，也可以用栈实现,本质上都是使用了栈先入后出的结构特点。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stack&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">ArePair</span><span class="hljs-params">(<span class="hljs-type">char</span> opening,<span class="hljs-type">char</span> closing)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">if</span>(opening == <span class="hljs-string">&#x27;(&#x27;</span> &amp;&amp; closing == <span class="hljs-string">&#x27;)&#x27;</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(opening == <span class="hljs-string">&#x27;&#123;&#x27;</span> &amp;&amp; closing == <span class="hljs-string">&#x27;&#125;&#x27;</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(opening == <span class="hljs-string">&#x27;[&#x27;</span> &amp;&amp; closing == <span class="hljs-string">&#x27;]&#x27;</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">AreParanthesesBalanced</span><span class="hljs-params">(string exp)</span></span><br><span class="hljs-function"></span>&#123;<br>stack&lt;<span class="hljs-type">char</span>&gt;  S;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i =<span class="hljs-number">0</span>;i&lt;exp.<span class="hljs-built_in">length</span>();i++)<br>&#123;<br><span class="hljs-keyword">if</span>(exp[i] == <span class="hljs-string">&#x27;(&#x27;</span> || exp[i] == <span class="hljs-string">&#x27;&#123;&#x27;</span> || exp[i] == <span class="hljs-string">&#x27;[&#x27;</span>)<br>S.<span class="hljs-built_in">push</span>(exp[i]);                                                   <span class="hljs-comment">//入栈 </span><br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(exp[i] == <span class="hljs-string">&#x27;)&#x27;</span> || exp[i] == <span class="hljs-string">&#x27;&#125;&#x27;</span> || exp[i] == <span class="hljs-string">&#x27;]&#x27;</span>)<br>&#123;<br><span class="hljs-keyword">if</span>(S.<span class="hljs-built_in">empty</span>() || !<span class="hljs-built_in">ArePair</span>(S.<span class="hljs-built_in">top</span>(),exp[i]))<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><span class="hljs-keyword">else</span><br>S.<span class="hljs-built_in">pop</span>();<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> S.<span class="hljs-built_in">empty</span>() ? <span class="hljs-literal">true</span>:<span class="hljs-literal">false</span>;            <span class="hljs-comment">//总有人喜欢三目运算符 </span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><br>string expression;<br>cout&lt;&lt;<span class="hljs-string">&quot;Enter an expression:  &quot;</span>; <br>cin&gt;&gt;expression;<br><span class="hljs-keyword">if</span>(<span class="hljs-built_in">AreParanthesesBalanced</span>(expression))<br>cout&lt;&lt;<span class="hljs-string">&quot;Balanced\n&quot;</span>;<br><span class="hljs-keyword">else</span><br>cout&lt;&lt;<span class="hljs-string">&quot;Not Balanced\n&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
      <category>c语言实现基本数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>c语言</tag>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>链表的c语言实现</title>
    <link href="/2023/12/11/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/test/"/>
    <url>/2023/12/11/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/test/</url>
    
    <content type="html"><![CDATA[<h1 id="c语言实现链表"><a href="#c语言实现链表" class="headerlink" title="c语言实现链表"></a>c语言实现链表</h1><h3 id="链表的理解"><a href="#链表的理解" class="headerlink" title="链表的理解"></a>链表的理解</h3><p>链表是由多个节点（node）组成的，每一个节点存储数据data和下一个数据的地址，由此构成链式结构。引入一个指针型变量head，存储第一个节点的地址。head是一个链表的唯一标识，后续引用链表对其进行操作时都要从head入手。head&#x3D;NULL; 则链表为空。<br>回顾 动态内存分配的步骤如下：<br>1.使用malloc()函数申请一块指定大小的内存空间。<br>2.使用指针变量来接收malloc()函数返回的指向已分配的空间开头的指针。<br>3.使用指针变量来访问已分配的内存空间。<br>4.使用free()函数释放之前申请的内存空间。</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> *ptr;<br>ptr = (<span class="hljs-type">int</span>*) <span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span>(<span class="hljs-type">int</span>));  <span class="hljs-comment">//malloc会返回分配内存块的首地址void指针</span><br><span class="hljs-keyword">if</span> (ptr == <span class="hljs-literal">NULL</span>) &#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Memory allocation failed\n&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br>*ptr = <span class="hljs-number">42</span>;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;The value of the integer is %d\n&quot;</span>, *ptr);<br><span class="hljs-built_in">free</span>(ptr);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>理解一下，链表是对堆(heap)的操作，这使得它具有相对于数组更灵活的特性。</p><h3 id="在头部插入一个节点"><a href="#在头部插入一个节点" class="headerlink" title="在头部插入一个节点"></a>在头部插入一个节点</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdlib.h&gt;</span> </span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Node</span>&#123;<br><span class="hljs-type">int</span> data;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Node</span>* next;<br>&#125;;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Node</span>* head;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Insert</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Node</span>*temp =(Node*)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span>(<span class="hljs-keyword">struct</span> Node));<br>temp-&gt;data=x;                   <span class="hljs-comment">//等价于写法(*temp).data</span><br>temp-&gt;next=head;<br>head=temp;          <span class="hljs-comment">//虽然temp的生命周期是暂时的 但是通过temp对内存的改动是永久的                     </span><br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Print</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Node</span>*temp=head;   <span class="hljs-comment">//遍历一个链表需要调用head，但我们不希望改变head，所以引入temp </span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;List is: &quot;</span>);<br><span class="hljs-keyword">while</span>(temp!=<span class="hljs-literal">NULL</span>)<br>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot; %d&quot;</span>,temp-&gt;data);<br>temp=temp-&gt;next;<br>&#125;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>); <br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>head=<span class="hljs-literal">NULL</span>;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;How many numbers&quot;</span>);<br><span class="hljs-type">int</span> n,i,x;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;n);<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)<br>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Enter the number\n&quot;</span>);<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;x);<br><span class="hljs-built_in">Insert</span>(x);<br><span class="hljs-built_in">Print</span>();<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="任意位置插入一个节点"><a href="#任意位置插入一个节点" class="headerlink" title="任意位置插入一个节点"></a>任意位置插入一个节点</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Node</span>&#123;<br><span class="hljs-type">int</span> data;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Node</span>*next;<br><br>&#125;;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Node</span>* head;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Insert</span><span class="hljs-params">(<span class="hljs-type">int</span> data,<span class="hljs-type">int</span> n)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Node</span>* temp1 =(<span class="hljs-keyword">struct</span> Node*)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span>(<span class="hljs-keyword">struct</span> Node)); <br>temp1-&gt;data=data;<br>temp1-&gt;next=<span class="hljs-literal">NULL</span>;      <span class="hljs-comment">//待插入的节点 temp1 </span><br><span class="hljs-keyword">if</span>(n==<span class="hljs-number">1</span>)<br>&#123;<br>temp1-&gt;next=head;       <span class="hljs-comment">//如果插入头部 </span><br>head=temp1;<br><span class="hljs-keyword">return</span>;<br><br>&#125;<br>Node* temp2=head;           <br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n<span class="hljs-number">-2</span>;i++)      <span class="hljs-comment">//遍历n-2次 temp2此时为第n-1个节点地址 </span><br>&#123;<br>temp2=temp2-&gt;next;       <br>&#125;<br>         <br>temp1-&gt;next=temp2-&gt;next;   <span class="hljs-comment">//temp1后面接上剩下的 </span><br>temp2-&gt;next=temp1;         <span class="hljs-comment">//temp2 接上temp1为车头的链 </span><br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Print</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>Node*temp=head;<br><span class="hljs-keyword">while</span>(temp!=<span class="hljs-literal">NULL</span>)<br>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>,temp-&gt;data);<br>temp=temp-&gt;next;<br>&#125;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br> &#125; <br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>head=<span class="hljs-literal">NULL</span>;<br><span class="hljs-built_in">Insert</span>(<span class="hljs-number">2</span>,<span class="hljs-number">1</span>);  <span class="hljs-comment">//2</span><br><span class="hljs-built_in">Insert</span>(<span class="hljs-number">3</span>,<span class="hljs-number">2</span>);   <span class="hljs-comment">//2 3</span><br><span class="hljs-built_in">Insert</span>(<span class="hljs-number">4</span>,<span class="hljs-number">1</span>);   <span class="hljs-comment">//4 2 3</span><br><span class="hljs-built_in">Insert</span>(<span class="hljs-number">5</span>,<span class="hljs-number">2</span>);     <span class="hljs-comment">//4 5 2 3</span><br><span class="hljs-built_in">Print</span>();<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="任意位置删除一个节点"><a href="#任意位置删除一个节点" class="headerlink" title="任意位置删除一个节点"></a>任意位置删除一个节点</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Node</span>&#123;<br><span class="hljs-type">int</span> data;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Node</span>* next;<br>&#125;;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Node</span>* head;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Print</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Node</span>* temp=head;<br><span class="hljs-keyword">while</span>(temp!=<span class="hljs-literal">NULL</span>)<br>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>,temp-&gt;data);<br>temp=temp-&gt;next;<br>&#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Delete</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Node</span>* temp1=head;<br><span class="hljs-keyword">if</span>(n==<span class="hljs-number">1</span>)&#123;<br>head=temp1-&gt;next;<br><span class="hljs-built_in">free</span>(temp1);<br>&#125;<br><span class="hljs-type">int</span> i;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n<span class="hljs-number">-2</span>;i++)   <br>&#123;<br>temp1=temp1-&gt;next; <br> &#125; <br> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">Node</span>* temp2=temp1-&gt;next;<br> temp1-&gt;next=temp2-&gt;next;<br> <span class="hljs-built_in">free</span>(temp2);<br> <br> <br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Insert</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Node</span>*temp =(Node*)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span>(<span class="hljs-keyword">struct</span> Node));<br>temp-&gt;data=x;<br>temp-&gt;next=head;<br>head=temp;  <br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>head=<span class="hljs-literal">NULL</span>;<br><span class="hljs-built_in">Insert</span>(<span class="hljs-number">2</span>);<br><span class="hljs-built_in">Insert</span>(<span class="hljs-number">4</span>);<br><span class="hljs-built_in">Insert</span>(<span class="hljs-number">6</span>);<br><span class="hljs-built_in">Insert</span>(<span class="hljs-number">5</span>);  <span class="hljs-comment">//此时链表为5 6 4 2</span><br><span class="hljs-type">int</span> n;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;n);<br><span class="hljs-built_in">Delete</span>(n);<br><span class="hljs-built_in">Print</span>(); <br>&#125;<br></code></pre></td></tr></table></figure><h3 id="反转一个链表"><a href="#反转一个链表" class="headerlink" title="反转一个链表"></a>反转一个链表</h3><p>用非递归方式实现，我们的思路是遍历这一个链表每一个节点，逐个改变链表中元素指向</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Node</span>&#123;<br><span class="hljs-type">int</span> data;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Node</span>* next;<br>&#125;;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Node</span>* head;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Insert</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Node</span>*temp =(Node*)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span>(<span class="hljs-keyword">struct</span> Node));<br>temp-&gt;data=x;<br>temp-&gt;next=head;<br>head=temp;                              <br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Print</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Node</span>*temp=head;   <span class="hljs-comment">//遍历一个链表需要调用head，但我们不希望改变head，所以引入temp </span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;List is: &quot;</span>);<br><span class="hljs-keyword">while</span>(temp!=<span class="hljs-literal">NULL</span>)<br>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot; %d&quot;</span>,temp-&gt;data);<br>temp=temp-&gt;next;<br>&#125;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>); <br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Reverse</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Node</span> *current,*prev,*next;<br>current=head;<br>prev=<span class="hljs-literal">NULL</span>;<br><span class="hljs-keyword">while</span>(current!=<span class="hljs-literal">NULL</span>)<br>&#123;<br>next=current-&gt;next;  <span class="hljs-comment">//更新next </span><br>current-&gt;next=prev;  <span class="hljs-comment">//更改两个节点之间指向方向 </span><br>prev=current;        <span class="hljs-comment">//更新prev </span><br>current=next;        <span class="hljs-comment">//更新current </span><br>&#125;   <br>head=prev; <br>      <span class="hljs-comment">//prev是最后一个节点，作为新的head </span><br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;   head=<span class="hljs-literal">NULL</span>; <br><span class="hljs-built_in">Insert</span>(<span class="hljs-number">1</span>);<br><span class="hljs-built_in">Insert</span>(<span class="hljs-number">2</span>);<br><span class="hljs-built_in">Insert</span>(<span class="hljs-number">3</span>);<br><span class="hljs-built_in">Insert</span>(<span class="hljs-number">4</span>);<br><span class="hljs-built_in">Print</span>();<br><span class="hljs-built_in">Reverse</span>();<br><span class="hljs-built_in">Print</span>();<br><br>&#125;<br></code></pre></td></tr></table></figure><p>用递归方法实现，我们的思路是<br>step 1:b-&gt;a<br>step 2:a-&gt;b to a-&gt;NULL</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Node</span>&#123;<br><span class="hljs-type">int</span> data;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Node</span>* next;<br>&#125;; <br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Node</span>* head;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Reverse</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> Node* p)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">if</span>(p-&gt;next==<span class="hljs-literal">NULL</span>)   <span class="hljs-comment">//说明此时的p是尾节点</span><br>&#123;<br>head=p;     <span class="hljs-comment">//头尾倒置</span><br><span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-built_in">Reverse</span>(p-&gt;next);<br>(p-&gt;next)-&gt;next=p;    <span class="hljs-comment">//开始出栈，从尾部开始弹栈过程中，逐次改变节点指向</span><br>p-&gt;next=<span class="hljs-literal">NULL</span>;          <span class="hljs-comment">//null不断被更新，最后的头结点指向null，全部出栈</span><br><br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Insert</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Node</span>*temp =(Node*)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span>(<span class="hljs-keyword">struct</span> Node));<br>temp-&gt;data=x;<br>temp-&gt;next=head;<br>head=temp;                              <br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Print</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Node</span>*temp=head;   <br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;List is: &quot;</span>);<br><span class="hljs-keyword">while</span>(temp!=<span class="hljs-literal">NULL</span>)<br>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot; %d&quot;</span>,temp-&gt;data);<br>temp=temp-&gt;next;<br>&#125;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>); <br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>head=<span class="hljs-literal">NULL</span>; <br><span class="hljs-built_in">Insert</span>(<span class="hljs-number">1</span>);<br><span class="hljs-built_in">Insert</span>(<span class="hljs-number">2</span>);<br><span class="hljs-built_in">Insert</span>(<span class="hljs-number">3</span>);<br><span class="hljs-built_in">Insert</span>(<span class="hljs-number">4</span>);<br><span class="hljs-built_in">Insert</span>(<span class="hljs-number">5</span>);<br><span class="hljs-built_in">Print</span>();<br><span class="hljs-built_in">Reverse</span>(head);<br><span class="hljs-built_in">Print</span>();<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="递归打印一个链表"><a href="#递归打印一个链表" class="headerlink" title="递归打印一个链表"></a>递归打印一个链表</h3><p>很简单的一个递归</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdlib.h&gt;</span> </span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Node</span>&#123;<br><span class="hljs-type">int</span> data;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Node</span>* next;<br>&#125;;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Print</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> Node* p)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">if</span>(p==<span class="hljs-literal">NULL</span>)<br>&#123;<br><span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>,p-&gt;data);<br><span class="hljs-built_in">Print</span>(p-&gt;next);<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ReversePrint</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> Node* p)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">if</span>(p==<span class="hljs-literal">NULL</span>)<br>&#123;<br><span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-built_in">ReversePrint</span>(p-&gt;next);    <span class="hljs-comment">//调用结束，回来执行完下面的printf，栈帧消失 </span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>,p-&gt;data);<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
      <category>c语言实现基本数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>c语言</tag>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>随笔</title>
    <link href="/1024/01/21/%E6%9D%82%E8%B0%88/%E9%9A%8F%E7%AC%94/"/>
    <url>/1024/01/21/%E6%9D%82%E8%B0%88/%E9%9A%8F%E7%AC%94/</url>
    
    <content type="html"><![CDATA[<p>终于告一段落了。1&#x2F;224 3.93&#x2F;4，前后打点，手续提交，尘埃落定。<br>最近常常漫无目的散步，尤其傍晚，看天幕的红色褪去，听心灵的声音归附宁静。无休止的未知和无休止的漂泊里，我如何知道我想要什么呢？<br>这一路似乎并无太多成功的时候，从sju的疫情开始，追逐成了主旋律，心灵在忙乱中寻求闲暇，一次次看到命运的无力，两年多的训练和坚持，CPhOF秋日折戟；半年时间竭尽全力的追赶文化课，终究在最后的夏天结束了最后的梦，一路上的荣耀和赞歌，坚忍与苦闷啊，无人问津的训练，万众瞩目的登场，可惜没能上演少年期望的绝地翻盘的好戏，一场梦被武汉大学一张轻飘飘的纸宣告死刑，另一段咬牙坚持的信念在一个并不喧嚣的夏日轻轻飞走，未曾留下一丝痕迹。 </p><h4 id="不如意事常八九，可与语人无二三。"><a href="#不如意事常八九，可与语人无二三。" class="headerlink" title="不如意事常八九，可与语人无二三。"></a>不如意事常八九，可与语人无二三。</h4><p>现在回想这已然发生的一切，总会想起一句谚语：“我曾踏足山巅，也曾陷入低谷，二者皆让我受益良多”。或许，通往幸福的道路只有一条，那就是用一颗平淡的心，对待我们能力范围之外的事情，对于往事，我已无悔，那种竭尽全力向着目标奔跑的样子，无论何时想起都会觉得漂亮。珍惜当下，用心体会命运所给予的。直面生活的变数，在命运面前做一个自由的灵魂。  </p><h4 id="诗云："><a href="#诗云：" class="headerlink" title="诗云："></a>诗云：</h4><p>穷极一生填不满雄心壮志<br>何不把答案交给远方？<br>虽然现实中<br>有太多我们无法轻易改变的事实<br>有太多我们无奈接受的结果<br>但我们可以选择一颗善良的心<br>一个干净的灵魂<br>带着这些出发我们无所惧怕<br>新的旅途又要开始了，我会珍惜这一路上的每一个故事 正所谓：     </p><h4 id="人生如逆旅，我亦是行人。"><a href="#人生如逆旅，我亦是行人。" class="headerlink" title="人生如逆旅，我亦是行人。"></a>人生如逆旅，我亦是行人。</h4>]]></content>
    
    
    <categories>
      
      <category>随笔</category>
      
    </categories>
    
    
    <tags>
      
      <tag>随笔</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
